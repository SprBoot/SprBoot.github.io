<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>个人类库工具文档(持续更新)</title>
      <link href="/2021/03/27/ge-ren-lei-ku-gong-ju-wen-dang/"/>
      <url>/2021/03/27/ge-ren-lei-ku-gong-ju-wen-dang/</url>
      
        <content type="html"><![CDATA[<h3 id="个人类库工具文档-持续更新">个人类库工具文档(持续更新)</h3><h4 id="文件操作类">文件操作类</h4><table><thead><tr><th>方法名称</th><th>方法注释</th><th>传入参数</th><th>参数注释</th><th>返回结果</th><th>结果注释</th></tr></thead><tbody><tr><td>ImgUpload</td><td>文件上传工具类</td><td>file</td><td>MultipartFile文件类</td><td>Map</td><td>返回Map类型数据，文件uuid名称(uName),封装文件路径(url),文件原名称(filename),文件后缀(suffix),文件类型(type,1为图片,2为文档,3为视频,4为音频)。</td></tr><tr><td></td><td></td><td>path</td><td>文件存储路径</td><td></td><td></td></tr><tr><td></td><td></td><td>mvc</td><td>文件映射路径</td><td></td><td></td></tr><tr><td>getFileType</td><td>获取文件类型</td><td>suffix</td><td>文件后缀</td><td>String</td><td>返回文件类型</td></tr></tbody></table><h4 id="日期操作类">日期操作类</h4><table><thead><tr><th>方法名称</th><th>方法注释</th><th>传入参数</th><th>参数注释</th><th>返回结果</th><th>结果注释</th></tr></thead><tbody><tr><td>format</td><td>日期格式化 日期格式为：yyyy-MM-dd</td><td>Date</td><td>日期</td><td>String</td><td>返回yyyy-MM-dd格式日期</td></tr><tr><td></td><td></td><td>String</td><td>格式，如：DateUtils.DATE_TIME_PATTERN</td><td></td><td></td></tr><tr><td>stringToDate</td><td>日期解析</td><td>String</td><td>日期</td><td>Date</td><td>返回Date</td></tr><tr><td></td><td></td><td>String</td><td>格式，如：DateUtils.DATE_TIME_PATTERN</td><td></td><td></td></tr><tr><td>getWeekStartAndEnd</td><td>根据周数，获取开始日期、结束日期</td><td>int</td><td>周期  0本周，-1上周，-2上上周，1下周，2下下周</td><td>Date数组</td><td>返回date[0]开始日期、date[1]结束日期</td></tr><tr><td>addDateSeconds</td><td>对日期的【秒】进行加/减</td><td>Date</td><td>日期</td><td>Date</td><td>加/减几秒后的日期</td></tr><tr><td></td><td></td><td>int</td><td>秒数，负数为减</td><td></td><td></td></tr><tr><td>addDateMinutes</td><td>对日期的【分钟】进行加/减</td><td>Date</td><td>日期</td><td>Date</td><td>加/减几分钟后的日期</td></tr><tr><td></td><td></td><td>int</td><td>分钟数，负数为减</td><td></td><td></td></tr><tr><td>addDateHours</td><td>对日期的【小时】进行加/减</td><td>Date</td><td>日期</td><td>Date</td><td>加/减几小时后的日期</td></tr><tr><td></td><td></td><td>int</td><td>小时数，负数为减</td><td></td><td></td></tr><tr><td>addDateDays</td><td>对日期的【天】进行加/减</td><td>Date</td><td>日期</td><td>Date</td><td>加/减几天后的日期</td></tr><tr><td></td><td></td><td>int</td><td>天数，负数为减</td><td></td><td></td></tr><tr><td>addDateWeeks</td><td>对日期的【周】进行加/减</td><td>Date</td><td>日期</td><td>Date</td><td>加/减几周后的日期</td></tr><tr><td></td><td></td><td>int</td><td>加/减几周后的日期</td><td></td><td></td></tr><tr><td>addDateMonths</td><td>对日期的【月】进行加/减</td><td>Date</td><td>日期</td><td>Date</td><td>对日期的【月】进行加/减</td></tr><tr><td></td><td></td><td>int</td><td>加/减几月后的日期</td><td></td><td></td></tr><tr><td>addDateYears</td><td>对日期的【年】进行加/减</td><td>Date</td><td>日期</td><td>Date</td><td>加/减几年后的日期</td></tr><tr><td></td><td></td><td>int</td><td>年数，负数为减</td><td></td><td></td></tr></tbody></table><h4 id="Word导出类">Word导出类</h4><table><thead><tr><th>方法名称</th><th>方法注释</th><th>传入参数</th><th>参数注释</th><th>返回结果</th><th>结果注释</th></tr></thead><tbody><tr><td>exportVisitWord</td><td>获取word文件下载地址</td><td>Map</td><td>封装的需要的Map参数</td><td>String</td><td>word文件下载地址</td></tr><tr><td></td><td></td><td>String</td><td>word模板文件所在地址</td><td></td><td></td></tr><tr><td></td><td></td><td>String</td><td>word文件导出地址</td><td></td><td></td></tr><tr><td></td><td></td><td>String</td><td>word模板名称</td><td></td><td></td></tr><tr><td></td><td></td><td>String</td><td>文件映射路径</td><td></td><td></td></tr></tbody></table><h4 id="Spring容器类">Spring容器类</h4><table><thead><tr><th>方法名称</th><th>方法注释</th><th>传入参数</th><th>参数注释</th><th>返回结果</th><th>结果注释</th></tr></thead><tbody><tr><td>getBean</td><td>获取java bean</td><td>Class<t></t></td><td>java类</td><td><t></t></td><td>返回java bean</td></tr><tr><td>getBean</td><td>获取java bean</td><td>String</td><td>类名称</td><td><t></t></td><td>返回java bean</td></tr><tr><td></td><td></td><td>Class<t></t></td><td>java类</td><td></td><td></td></tr><tr><td>containsBean</td><td>是否包含java bean</td><td>String</td><td>类名称</td><td>boolean</td><td>是否包含</td></tr><tr><td>isSingleton</td><td>bean是否为单例</td><td>String</td><td>类名称</td><td>boolean</td><td>是否为单例</td></tr><tr><td>getType</td><td>获取java类型</td><td>String</td><td>类名称</td><td>Class&lt;? extends Object&gt;</td><td>java类型</td></tr></tbody></table><h4 id="Excel工具类">Excel工具类</h4><table><thead><tr><th>方法名称</th><th>方法注释</th><th>传入参数</th><th>参数注释</th><th>返回结果</th><th>结果注释</th></tr></thead><tbody><tr><td>exportExcel</td><td>Excel导出</td><td>HttpServletResponse</td><td>response</td><td>void</td><td></td></tr><tr><td></td><td></td><td>String</td><td>文件名</td><td></td><td></td></tr><tr><td></td><td></td><td>Collection&lt;?&gt;</td><td>数据List</td><td></td><td></td></tr><tr><td></td><td></td><td>Class&lt;?&gt;</td><td>对象Class</td><td></td><td></td></tr><tr><td>getMyCellDate</td><td>excel日期转换</td><td>Cell</td><td>获取excel的日期列</td><td>Date</td><td>日期</td></tr></tbody></table><h3 id="类库文件">类库文件</h3><p><a href="http://dingdm.online/dingdm-1.0-SNAPSHOT.jar" target="_blank" rel="noopener">http://dingdm.online/dingdm-1.0-SNAPSHOT.jar</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jar </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring boot接口防刷</title>
      <link href="/2021/02/17/springboot-jie-kou-fang-shua/"/>
      <url>/2021/02/17/springboot-jie-kou-fang-shua/</url>
      
        <content type="html"><![CDATA[<h3 id="Springboot接口防刷">Springboot接口防刷</h3><p>自定义注解</p><pre class=" language-language-java"><code class="language-language-java">import java.lang.annotation.Retention;import java.lang.annotation.Target; import static java.lang.annotation.ElementType.METHOD;import static java.lang.annotation.RetentionPolicy.RUNTIME; @Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)public @interface AccessLimit {     int seconds();    int maxCount();    boolean needLogin() default true;}</code></pre><p>拦截器</p><p>用户的 ID和请求的路径作为key,首先从redis中根据该key去取得用户的访问次数，如果为null,则根据该key重新设置key,value,value的值是１，能取到key对应的value，则判断vlaue是否小于５，是则处理请求，否则返回error。</p><pre class=" language-language-java"><code class="language-language-java">import com.alibaba.fastjson.JSON;import com.example.demo.action.AccessLimit;import com.example.demo.redis.RedisService;import com.example.demo.result.CodeMsg;import com.example.demo.result.Result;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Component;import org.springframework.web.method.HandlerMethod;import org.springframework.web.servlet.handler.HandlerInterceptorAdapter; import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.OutputStream; @Componentpublic class AntiBrushInterceptor extends HandlerInterceptorAdapter {     @Autowired    private RedisService redisService;     @Override    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {         if(handler instanceof HandlerMethod){             HandlerMethod hm = (HandlerMethod) handler;             AccessLimit accessLimit = hm.getMethodAnnotation(AccessLimit.class);            if(accessLimit == null){                return true;            }            int seconds = accessLimit.seconds();            int maxCount = accessLimit.maxCount();            boolean login = accessLimit.needLogin();            String key = request.getRequestURI();            if(login){                //业务逻辑            }             AccessKey ak = AccessKey.withExpire(seconds);            Integer count = redisService.get(ak,key,Integer.class);            if(count == null){                redisService.set(ak,key,1);            }else if(count &lt; maxCount){                redisService.incr(ak,key);            }else{                render(response,CodeMsg.ACCESS_LIMIT_REACHED);                 return false;            }        }         return true;     }    private void render(HttpServletResponse response, CodeMsg cm)throws Exception {        response.setContentType("application/json;charset=UTF-8");        OutputStream out = response.getOutputStream();        String str  = JSON.toJSONString(Result.error(cm));        out.write(str.getBytes("UTF-8"));        out.flush();        out.close();    }}</code></pre><p>拦截器注册和注解使用</p><pre class=" language-language-java"><code class="language-language-java">import com.example.demo.ExceptionHander.AntiBrushInterceptor;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.context.annotation.Configuration;import org.springframework.web.servlet.config.annotation.InterceptorRegistry;import org.springframework.web.servlet.config.annotation.WebMvcConfigurerAdapter;@Configurationpublic class WebConfig extends WebMvcConfigurerAdapter {     @Autowired    private AntiBrushInterceptor interceptor;      @Override    public void addInterceptors(InterceptorRegistry registry) {        registry.addInterceptor(interceptor);    }}</code></pre><pre class=" language-language-java"><code class="language-language-java">@PostMapping("getNewsModule")@AccessLimit(seconds=5, maxCount=10, needLogin=true)public Result<list<newsmoduledto>&gt; getNewsModule(@ApiIgnore @RequestParam Map<string, object=""> params){        PageData<newsmoduledto> page = newsModuleService.page(params);        return new Result<list<newsmoduledto>&gt;().ok(page.getList());    }</list<newsmoduledto></newsmoduledto></string,></list<newsmoduledto></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 日常随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Boot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用docker创建项目镜像</title>
      <link href="/2021/02/05/shi-yong-docker-chuang-jian-xiang-mu-jing-xiang/"/>
      <url>/2021/02/05/shi-yong-docker-chuang-jian-xiang-mu-jing-xiang/</url>
      
        <content type="html"><![CDATA[<h3 id="使用docker创建项目镜像">使用docker创建项目镜像</h3><p>本文创建的镜像为hexo静态博客的镜像，防止自己的服务器到期之后进行迁移的麻烦。</p><h4 id="确定创建镜像所需的环境">确定创建镜像所需的环境</h4><ul><li>node.js</li><li>git</li><li>nginx</li></ul><h4 id="编写自己的镜像的Dockerfile文件">编写自己的镜像的Dockerfile文件</h4><p>docker指令详解</p><table><thead><tr><th>指令名称</th><th>用法</th><th>作用</th></tr></thead><tbody><tr><td>FROM</td><td>FROM image</td><td>FROM指定构建镜像的基础源镜像，如果本地没有指定的镜像，则会自动从 Docker 的公共库 pull 镜像下来；FROM必须是 Dockerfile 中非注释行的第一个指令，即一个 Dockerfile 从FROM语句开始；FROM可以在一个 Dockerfile 中出现多次，如果有需求在一个 Dockerfile 中创建多个镜像；如果FROM语句没有指定镜像标签，则默认使用latest标签。</td></tr><tr><td>MAINTAINER</td><td>MAINTAINER name</td><td>指定创建镜像的用户</td></tr><tr><td>RUN</td><td>RUN “executable”, “param1”, “param2”</td><td>每条RUN指令将在当前镜像基础上执行指定命令，并提交为新的镜像，后续的RUN都在之前RUN提交后的镜像为基础，镜像是分层的，可以通过一个镜像的任何一个历史提交点来创建，类似源码的版本控制；</td></tr><tr><td></td><td>RUN [ “echo”, “$HOME” ]</td><td></td></tr><tr><td></td><td>RUN [ “sh”, “-c”, “echo”, “$HOME” ]</td><td>RUN产生的缓存在下一次构建的时候是不会失效的，会被重用，可以使用–no-cache选项，即docker build –no-cache，如此便不会缓存。</td></tr><tr><td>CMD</td><td>CMD “executable”,“param1”,“param2”</td><td>CMD指定在 Dockerfile 中只能使用一次，如果有多个，则只有最后一个会生效。</td></tr><tr><td></td><td>CMD “param1”,“param2”</td><td>CMD的目的是为了在启动容器时提供一个默认的命令执行选项。如果用户启动容器时指定了运行的命令，则会覆盖掉CMD指定的命令。</td></tr><tr><td></td><td>CMD command param1 param2 (shell form)</td><td>CMD会在启动容器的时候执行，build 时不执行，而RUN只是在构建镜像的时候执行，后续镜像构建完成之后，启动容器就与RUN无关了</td></tr><tr><td>EXPOSE</td><td>EXPOSE port [port…]</td><td>告诉 Docker 服务端容器对外映射的本地端口，需要在 docker run 的时候使用-p或者-P选项生效。</td></tr><tr><td>ENV</td><td>ENV key value       <em># 只能设置一个变量</em></td><td></td></tr><tr><td></td><td>ENV key=value …   <em># 允许一次设置多个变量</em></td><td>指定一个环境变量，会被后续RUN指令使用，并在容器运行时保留。</td></tr><tr><td>ADD</td><td>ADD src… dest</td><td>ADD复制本地主机文件、目录或者远程文件 URLS 从 并且添加到容器指定路径中 。</td></tr><tr><td>COPY</td><td>COPY src… dest</td><td>COPY复制新文件或者目录从 并且添加到容器指定路径中 。用法同ADD，唯一的不同是不能指定远程文件 URLS。</td></tr><tr><td>ENTRYPOINT</td><td>ENTRYPOINT “executable”, “param1”, “param2”</td><td>每个 Dockerfile 中只能有一个ENTRYPOINT，当指定多个时，只有最后一个生效。</td></tr><tr><td></td><td>ENTRYPOINT command param1 param2 (shell form)</td><td>配置容器启动后执行的命令，并且不可被 docker run 提供的参数覆盖，而CMD是可以被覆盖的。如果需要覆盖，则可以使用<code>docker run --entrypoint</code>选项。</td></tr><tr><td>VOLUME</td><td>VOLUME ["/data"]</td><td>将本地主机目录挂载到目标容器中，或者将其他容器挂载的挂载点 挂载到目标容器中</td></tr><tr><td>USER</td><td>USER daemon</td><td>指定运行容器时的用户名或 UID，后续的RUN、CMD、ENTRYPOINT也会使用指定用户。</td></tr><tr><td>WORKDIR</td><td>WORKDIR /path/to/workdir</td><td>为后续的RUN、CMD、ENTRYPOINT指令配置工作目录。可以使用多个WORKDIR指令，后续命令如果参数是相对路径，则会基于之前命令指定的路径。</td></tr><tr><td>ONBUILD</td><td>ONBUILD [INSTRUCTION]</td><td>使用该dockerfile生成的镜像A，并不执行ONBUILD中命令，如再来个dockerfile 基础镜像为镜像A时，生成的镜像B时就会执行ONBUILD中的命令</td></tr></tbody></table><p><strong>拉取ubuntu环境镜像</strong></p><pre class=" language-language-dockerfile"><code class="language-language-dockerfile">docker pull ubuntu:18.04</code></pre><p><img src="http://dingdm.online/%E6%8B%89%E5%8F%96ubuntu.png" alt=""></p><p>如果拉取镜像慢的话，可以配置一下镜像加速。</p><p>使用<code>docker version</code>查看自己的docker版本，大于1.10可以进行加速配置，小于的更新一下即可。</p><pre><code>mkdir -p /etc/dockertee /etc/docker/daemon.json &lt;&lt;-'EOF'{  "registry-mirrors": ["https://xxxxx.mirror.aliyuncs.com"]  #这里也可以用网易的镜像加速器："http://hub-mirror.c.163.com"}EOFsystemctl daemon-reloadsystemctl restart docker</code></pre><p><strong>配置nginx环境</strong></p><p>安装步骤在后面的Dockerfile中，安装完nginx后，这里以ubuntu18.04为例，nginx的目录为/ect/nginx。我们修改配置文件只需要修改sites-available下的default即可。我这里在之前学习的时候都是不一样的路径，所以我这里以ubuntu为例。准备好一份default配置文件COPY即可。</p><pre><code>server {        listen 80 default_server;        listen [::]:80 default_server;        listen 443 ssl;        ssl off;        ssl_certificate cert/4287626_www.dingdm.club.pem;        ssl_certificate_key cert/4287626_www.dingdm.club.key;        ssl_session_timeout 5m;        #ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aN$        ssl_ciphers ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES128-SHA256:ECDHE-RSA-AES128-SHA256:ECDHE-ECDSA-AES128-SHA:ECDHE-RSA-AES256-SHA384:ECDHE-RSA-AES128-SHA:ECDHE-ECDSA-AES256-SHA384:ECDHE-ECDSA-AES256-SHA:ECDHE-RSA-AES256-SHA:DHE-RSA-AES128-SHA256:DHE-RSA-AES128-SHA:DHE-RSA-AES256-SHA256:DHE-RSA-AES256-SHA:ECDHE-ECDSA-DES-CBC3-SHA:ECDHE-RSA-DES-CBC3-SHA:EDH-RSA-DES-CBC3-SHA:AES128-GCM-SHA256:AES256-GCM-SHA384:AES128-SHA256:AES256-SHA256:AES128-SHA:AES256-SHA:DES-CBC3-SHA:!DSS;        ssl_protocols TLSv1 TLSv1.1 TLSv1.2;        ssl_prefer_server_ciphers on;        root /home/www/hexo;        server_name dingdm.club;}</code></pre><p>server_name为你的域名，root为你的静态网站所在的路径，可以自己创建，<strong>注意这里的路径不是你的hexo博客的路径，如果你在服务器上创建博客的话</strong>。</p><p>ssl的配置为开启https的配置，这里先不赘述，不需要的话可以将ssl相关的配置注释掉即可</p><p><strong>在你使用docker镜像服务器上配一下自己的git环境和仓库。(非docker容器)</strong></p><p>更新频繁因此不将git整合到容器内。</p><pre><code>apt-get update apt-get install gitgit config --global user.name "你的用户名"git config --global user.email "你的注册邮箱"</code></pre><p>添加git用户，使用root账户也可以。</p><pre><code>adduser git</code></pre><p>修改文件内容赋予权限</p><pre><code>chmod 740 /etc/sudoersnano /etc/sudoers</code></pre><p>找到root用户那，在下方添加一条</p><pre><code>git ALL=(ALL) ALL</code></pre><p>将文件权限恢复</p><pre><code>chmod 400 /etc/sudoers</code></pre><p>切换到git用户，并创建ssh文件夹</p><pre><code>su gitcd ~mkdir .sshcd .ssh</code></pre><p>生成密钥公钥并配置</p><pre><code>ssh-keygencp id_rsa.pub authorized_keyschmod 600 ~/.ssh/authorized_keyschmod 700 ~/.ssh</code></pre><p>配置完成之后可以使用<code>ssh -v git@ip</code>连接测试</p><p>新建仓库并设置钩子脚本</p><pre><code>cd ~git init --bare blog.gitnano ~/blog.git/hooks/post-receive</code></pre><p>输入以下内容</p><pre><code>git --work-tree=/home/www/hexo --git-dir=/home/git/blog.git checkout -f</code></pre><p>/home/www/hexo为你刚刚在nginx的配置文件里的root路径，/home/git/blog.git为你的仓库地址</p><p><strong>制作Dockerfile文件</strong></p><p>使用自己刚刚拉取的ubuntu镜像并安装nginx和配置环境</p><pre class=" language-language-dockerfile"><code class="language-language-dockerfile">FROM c090eaba6b94RUN apt-get update &amp;&amp; apt-get install -y nginxCOPY default /etc/nginx/sites-available/COPY www/ /home/wwwCMD ["/usr/sbin/nginx","-g","daemon off;"]</code></pre><p><strong>制作镜像</strong></p><pre><code>docker build -t dingdm:1.0.0 .</code></pre><p><img src="http://dingdm.online/%E8%BF%90%E8%A1%8C%E9%95%9C%E5%83%8F.png" alt=""></p><p><img src="http://dingdm.online/%E8%BF%90%E8%A1%8C%E6%88%90%E5%8A%9F.png" alt=""></p><p><strong>镜像为nginx加静态博客页面。服务器到期后在考虑本地部署，使用ADD加载git仓库里新部署的文件信息并发布新版镜像。</strong></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dockerfile </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>KMP字符串匹配</title>
      <link href="/2020/09/07/kmp-zi-fu-chuan-pi-pei/"/>
      <url>/2020/09/07/kmp-zi-fu-chuan-pi-pei/</url>
      
        <content type="html"><![CDATA[<h3 id="KMP字符串匹配">KMP字符串匹配</h3><pre class=" language-language-java"><code class="language-language-java">package com.zjr.wholesale.config;import java.util.ArrayList;import java.util.List;public class KMP {    /*public static String [] str = new String[]{"b","a","c","b","a","d",            "a","b","a","d","a","b","a","b","a","c","a","m","b","a","b","a","c","a","d","d","a","b","a","b","a","c","a","s","d"};    public static String [] ptr = new String[]{"a","b","a","b","a","c","a"};*/    public static String [] str = new String[]{"a","b","c","a","a","b",            "a","b","a","b","a","a"};    public static String [] ptr = new String[]{"a","b","a","b"};    public static void main(String []args) {        List<integer> array = getPtrArray(ptr);        ifEquals(0,0,array);    }    //递归判断字符串比较    public static void ifEquals(int i,int j,List<integer> array){        if(i &lt; str.length){            if(j &lt; ptr.length){                if(str[i].equals(ptr[j])){                    i++;                    j++;                    ifEquals(i,j,array);                }else{                    if(j == 0){                        i++;                    }else{                        int length = getArrayValue(j,array);                        if(length != 0){                            i = i - length;                        }                        j = 0;                    }                    ifEquals(i,j,array);                }            }else{                System.out.println("Ptr 匹配成功，下标开始位置为:" + (i - ptr.length));                j = 0;                ifEquals(i,j,array);            }        }else{            System.out.println("字符串匹配结束");        }    }    //获取前缀后缀数组中的长度    public static int getArrayValue(int j,List<integer> array){        return array.get(j-1);    }    //获取比较字符串的前缀后缀数组    public static List<integer> getPtrArray(String []str){        int j = 1;        List<integer> array = new ArrayList<integer>();        while(j &lt;= str.length){            List<string> nStr = new ArrayList<string>();            for(int i=0;i<j;i++){ nstr.add(str[i]);="" }="" int="" number="getNStrNumber(nStr);" array.add(number);="" j++;="" return="" array;="" 获取当前列表字符串的前缀后缀个数="" public="" static="" getnstrnumber(list<string=""> nStr){        int length = 0;        if(nStr.size() == 1){            length = 0;        }else{            int i = nStr.size();            boolean flag = true;            while(i &gt; 0 &amp;&amp; flag){                i--;                StringBuilder str = new StringBuilder();                StringBuilder ptr = new StringBuilder();                for(int index = 0;index &lt; i;index++){                    str.append(nStr.get(index));                }                for(int lIndex=(nStr.size() - i);lIndex &lt; nStr.size();lIndex++){                    ptr.append(nStr.get(lIndex));                }                if(str.toString().equals(ptr.toString())){                    flag = false;                    length = str.length();                }            }        }        return length;    }}</j;i++){></string></string></integer></integer></integer></integer></integer></integer></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KMP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>steam及其他免费游戏白嫖(更新)</title>
      <link href="/2020/08/08/steam-ji-qi-ta-mian-fei-you-xi-bai-piao-geng-xin/"/>
      <url>/2020/08/08/steam-ji-qi-ta-mian-fei-you-xi-bai-piao-geng-xin/</url>
      
        <content type="html"><![CDATA[<h3 id="steam及其他免费游戏白嫖-更新">steam及其他免费游戏白嫖(更新)</h3><h4 id="2020-11-05">2020-11-05</h4><p>无主之地3 61元<br><a href="https://www.greenmangaming.com/zh/" target="_blank" rel="noopener">https://www.greenmangaming.com/zh/</a></p><h4 id="2020-09-02">2020-09-02</h4><p>远哭3领取<br><a href="https://register.ubisoft.com/far-cry-3/zh-CN" target="_blank" rel="noopener">https://register.ubisoft.com/far-cry-3/zh-CN</a><br>全境封锁领取<br><a href="https://register.ubisoft.com/the-division/en-US" target="_blank" rel="noopener">https://register.ubisoft.com/the-division/en-US</a><br>全境封锁需挂下梯子，推荐efan</p><h4 id="2020-08-16">2020-08-16</h4><p>NBK 2K20<br><a href="https://www.greenmangaming.com/zh/games/nba-2k20-pc/" target="_blank" rel="noopener">https://www.greenmangaming.com/zh/games/nba-2k20-pc/</a><br>鬼泣5和生化危机2 3优惠<br><a href="https://chinaplay.store/china-keys/" target="_blank" rel="noopener">https://chinaplay.store/china-keys/</a></p><h4 id="2020-08-13">2020-08-13</h4><p>全面战争特洛伊<br>本体领取地址：<a href="https://www.epicgames.com/store/zh-CN/product/a-total-war-saga-troy" target="_blank" rel="noopener">https://www.epicgames.com/store/zh-CN/product/a-total-war-saga-troy</a><br>本体领取时间：8月13日21:00-8月14日21:00<br>DLC领取地址<br>注册地址：<a href="https://access.totalwar.com/auth/email_register/" target="_blank" rel="noopener">https://access.totalwar.com/auth/email_register/</a><br>（如果注册地址打不开去这里https://access.totalwar.com/点击注册）<br>关联账号：<a href="https://access.totalwar.com/auth/control_panel/" target="_blank" rel="noopener">https://access.totalwar.com/auth/control_panel/</a></p><h4 id="2020-08-08">2020-08-08</h4><h5 id="steam">steam</h5><p><a href="https://www.humblebundle.com/store/f1-2018-free-game?hmb_campaign=freegame_2020_homepage_f12018&amp;hmb_medium=banner" target="_blank" rel="noopener">F1 2018</a></p><p>**《F1 2018》**是Codemasters开发制作的一款以世界一级方程式赛车为背景制作的一款赛车竞速类游戏。</p><p><a href="https://store.steampowered.com/app/397540/3/" target="_blank" rel="noopener">无主之地3</a></p><p>无主之地3免费周末试玩</p><h5 id="EPIC">EPIC</h5><p><a href="https://www.epicgames.com/store/zh-CN/free-games" target="_blank" rel="noopener">免费游戏</a></p><p>遗迹灰烬重生还不错</p><h5 id="GMG">GMG</h5><p><a href="https://www.epicgames.com/store/zh-CN/free-games" target="_blank" rel="noopener">GMG夏促</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 游戏 </category>
          
          <category> 白嫖 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> steam </tag>
            
            <tag> epic </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>win10系统的桌面美化</title>
      <link href="/2020/08/05/win10-xi-tong-de-zhuo-mian-mei-hua/"/>
      <url>/2020/08/05/win10-xi-tong-de-zhuo-mian-mei-hua/</url>
      
        <content type="html"><![CDATA[<h3 id="win10系统的桌面美化">win10系统的桌面美化</h3><p>首先放个人桌面和开始菜单的预览图。</p><p><img src="http://dingdm.online/QQ%E6%88%AA%E5%9B%BE20200805114944.png" alt="1596599399928"></p><p><img src="http://dingdm.online/QQ%E6%88%AA%E5%9B%BE20200805115313.png" alt=""></p><p>桌面美化的部分网络实时数据，应用图标美化，任务栏透明图标居中，开始菜单以及鼠标美化。</p><h4 id="美化软件以及相关文件">美化软件以及相关文件</h4><p><a href="http://dingdm.online/TrafficMonitor.rar" target="_blank" rel="noopener">实时数据软件</a></p><p><a href="http://dingdm.online/TrafficMonitor.rar" target="_blank" rel="noopener">任务栏软件</a></p><p><a href="http://dingdm.online/RocketDock-v1.3.5.exe" target="_blank" rel="noopener">应用设置软件</a></p><p><a href="http://dingdm.online/%E7%BE%8E%E5%8C%96.rar" target="_blank" rel="noopener">图标及开始程序按钮美化包</a></p><p><a href="http://dingdm.online/Ori%E9%BC%A0%E6%A0%87%E5%85%89%E6%A0%872.0.rar" target="_blank" rel="noopener">奥日鼠标资源</a></p><h4 id="实时数据美化">实时数据美化</h4><p>下载提供的实时数据软件后进行解压。打开TrafficMonitor.exe软件。这时就会出现相关内容。</p><p><img src="http://dingdm.online/QQ%E6%88%AA%E5%9B%BE20200805120508.png" alt=""></p><h5 id="选项设置">选项设置</h5><p>在实时数据上<strong>右键</strong></p><p><img src="http://dingdm.online/QQ%E6%88%AA%E5%9B%BE20200805120752.png" alt=""></p><p>将显示通知区域图标关掉，打开显示CPU和内存利用率的选项。</p><h5 id="样式更改">样式更改</h5><p>刚开始的位置并不在任务栏上，因此需要对配置进行修改。这里在实时数据上<strong>右键打开选项</strong>，按照以下配置进行修改即可。</p><p><img src="http://dingdm.online/QQ%E6%88%AA%E5%9B%BE20200805145216.png" alt=""></p><p><img src="http://dingdm.online/QQ%E6%88%AA%E5%9B%BE20200805145222.png" alt=""></p><p><img src="http://dingdm.online/QQ%E6%88%AA%E5%9B%BE20200805145229.png" alt=""></p><h4 id="任务栏设置">任务栏设置</h4><p>安装StartIsBack   2.9.exe</p><h5 id="属性设置">属性设置</h5><p>安装完成后右键开始菜单选择<strong>属性</strong>项</p><p><img src="http://dingdm.online/QQ%E6%88%AA%E5%9B%BE20200805150108.png" alt=""></p><h5 id="图标美化">图标美化</h5><p><img src="http://dingdm.online/QQ%E6%88%AA%E5%9B%BE20200805150201.png" alt=""></p><p>下载上面提供的美化图标，点击<strong>加号按钮</strong>添加即可。我这里已经添加过了，所有已经有了新的开始菜单的美化图标。</p><h5 id="任务栏透明">任务栏透明</h5><p><img src="http://dingdm.online/QQ%E6%88%AA%E5%9B%BE20200805150321.png" alt=""></p><p>点击<strong>自定义任务栏特效</strong>，选择任务栏图标居中和动态透明度即可。</p><h4 id="应用图标设置">应用图标设置</h4><p>下载上面提供的应用软件RocketDock-v1.3.5进行安装，安装完成后会出现类似mac的效果，自带默认的图标。</p><p><img src="http://dingdm.online/QQ%E6%88%AA%E5%9B%BE20200805150715.png" alt=""></p><p>因为我这里将我的电脑上的应用添加进来了，所以是完成后的效果。安装完成后将自带的图标移除，然后将自己的软件图标拉入到对应的位置即可。</p><h5 id="配置设置">配置设置</h5><p>在rockeddock上右键程序设置进行配置修改</p><p><img src="http://dingdm.online/QQ%E6%88%AA%E5%9B%BE20200805150823.png" alt=""></p><p>点击程序设置后按照我提供的配置进行修改即可。</p><p><img src="http://dingdm.online/QQ%E6%88%AA%E5%9B%BE20200805150837.png" alt=""></p><p><img src="http://dingdm.online/QQ%E6%88%AA%E5%9B%BE20200805150842.png" alt=""></p><p><img src="http://dingdm.online/QQ%E6%88%AA%E5%9B%BE20200805150848.png" alt=""></p><p>修改完成之后就是我现在的效果。</p><h5 id="图标设置">图标设置</h5><p>如果你想要更改图标的样式的话。在图标上右键点击图标设置。</p><p><img src="http://dingdm.online/QQ%E6%88%AA%E5%9B%BE20200805151023.png" alt=""></p><p><img src="http://dingdm.online/QQ%E6%88%AA%E5%9B%BE20200805151030.png" alt=""></p><p>下载上面提供的美化图标进行替换即可。</p><h5 id="图标分隔">图标分隔</h5><p>如果图标之间想要留出空隙的话，选择**添加项目中的分隔符****即可。</p><p><img src="http://dingdm.online/QQ%E6%88%AA%E5%9B%BE20200805151143.png" alt=""></p><p>至此应用图标的美化完成。</p><h4 id="鼠标设置">鼠标设置</h4><p><img src="http://dingdm.online/QQ%E6%88%AA%E5%9B%BE20200805151400.png" alt=""></p><p>我这里使用的是奥日的图标，如果你想使用的话下载上面的资源即可。</p><h5 id="网站下载">网站下载</h5><p>如果不想使用的话，鉴于国外网站需要翻墙，我这里提供鼠标样式下载的国内网站，自己选择下载即可。</p><p><a href="https://zhutix.com/tag/cursors/" target="_blank" rel="noopener">https://zhutix.com/tag/cursors/</a></p><h5 id="鼠标替换">鼠标替换</h5><p>打开电脑的设置界面，选择设备</p><p><img src="http://dingdm.online/QQ%E6%88%AA%E5%9B%BE20200805152038.png" alt=""></p><p><img src="http://dingdm.online/QQ%E6%88%AA%E5%9B%BE20200805152053.png" alt=""></p><p>切换到鼠标，点击右面的其他鼠标选项</p><p><img src="http://dingdm.online/QQ%E6%88%AA%E5%9B%BE20200805152109.png" alt=""></p><p>选择指针模块，浏览自己下载的鼠标资源进行替换即可。</p><p><img src="http://dingdm.online/QQ%E6%88%AA%E5%9B%BE20200805152118.png" alt=""></p><h3 id="开始菜单切片设置">开始菜单切片设置</h3><p>在win10系统自带的商店下载tile genie软件，下载成功后选择图片切割即可。</p><p>图片切片并不难，主要是需要耗费时间拼。</p><h3 id="win10壁纸设置">win10壁纸设置</h3><h4 id="wallpaper-engine">wallpaper engine</h4><p>这里有条件的小伙伴推荐去steam购买一个壁纸软件wallpaper engine，18块钱你买不了吃亏，你买不了上当。最重要的除了它是一款壁纸软件之外，它还是一块非常牛逼的射击游戏。</p><p>我这里推荐几个壁纸。或者你也可以去哔哩哔哩自行搜索相关的视频。</p><p>The Last of Us</p><p><img src="http://dingdm.online/eafa3cfba8c7a0f380fb792d3e310ffb.jpg" alt=""></p><p>Time lapse + 3D Digital Clock</p><p><img src="http://dingdm.online/d4aab6a9232e65e55778219d64bbd9b4.jpg" alt=""></p><p>Lamp</p><p><img src="http://dingdm.online/97bb304efc12b1e4525274e89bb980bf.jpg" alt=""></p><p>Alone</p><p><img src="http://dingdm.online/fee7c1563c02682d02d17ec00ab878e0.jpg" alt=""></p><p>PCB City</p><p><img src="http://dingdm.online/668df914429c2e529556b6e350b9e6b0.jpg" alt=""></p><h4 id="免费壁纸">免费壁纸</h4><p>如果不想购买的话我这里也推荐几个静态的免费的壁纸。</p><p><img src="http://dingdm.online/v2-02e8a470854063843938274a14cbe238_r.jpg" alt=""></p><p><img src="http://dingdm.online/v2-81b1f2f30d62487bb6f47ab08155cc69_r.jpg" alt=""></p><p><img src="http://dingdm.online/v2-8262525f9d0681e6b996bc758229f90c_r.jpg" alt=""></p><p><img src="http://dingdm.online/v2-c2c137fa7017fc27b454651dafb36b0f_r.jpg" alt=""></p><p><img src="http://dingdm.online/v2-dabcb2e02b94f7c8dfefae1ac7e4f591_r.jpg" alt=""></p><p><img src="http://dingdm.online/v2-db782cbaced5180b9037064ff9905afe_r.jpg" alt=""></p><p><img src="http://dingdm.online/v2-e35ed2b90501aea545ee73e2decebf6a_r.jpg" alt=""></p><p><img src="http://dingdm.online/v2-e3fd094f1f8555c4abcbf98ab9119d70_r.jpg" alt=""></p><p><img src="http://dingdm.online/v2-ff96a816315c9e7c28e48899c9f8df7e_r.jpg" alt=""></p><h4 id="壁纸网站">壁纸网站</h4><p><a href="https://hddesktopwallpapers.in/" target="_blank" rel="noopener">https://hddesktopwallpapers.in/</a></p><p><a href="http://simpledesktops.com/" target="_blank" rel="noopener">http://simpledesktops.com/</a></p><p><a href="http://www.obzhi.com/" target="_blank" rel="noopener">http://www.obzhi.com/</a></p><p><a href="https://ss.netnr.com/wallpaper" target="_blank" rel="noopener">https://ss.netnr.com/wallpaper</a></p><p><a href="http://spotlight.shijuewuyu.com/" target="_blank" rel="noopener">http://spotlight.shijuewuyu.com/</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 美化 </category>
          
          <category> 壁纸 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> win10 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>答辩知识架构及企业OA项目开发汇总</title>
      <link href="/2020/08/02/da-bian-zhi-shi-jia-gou-ji-qi-ye-oa-xiang-mu-kai-fa-hui-zong/"/>
      <url>/2020/08/02/da-bian-zhi-shi-jia-gou-ji-qi-ye-oa-xiang-mu-kai-fa-hui-zong/</url>
      
        <content type="html"><![CDATA[<h3 id="1-Vue框架">1.Vue框架</h3><p><strong>MVVM架构，model，view，viewmodel，model和view之间无法直接交互，通过viewmodel进行交互，创建新的模板，在模板中使用js函数创建监听器，使用vm_patch渲染页面完成数据模板的绑定，当数据更新时自动同步数据。view和model自动同步，开发人员只需要关注业务逻辑，而非操作dom对象。<br>前台使用VUE进行开发，Vue.js是一个构建数据驱动的web界面的渐进式框架。Vue的目标是通过尽可能简单API实现响应的数据绑定和组合的视图组件。核心是一个响应的数据绑定系统。即vue是单页面应用，页面局部刷新，不用每次跳转页面都去请求所有数据和dom对象，这样大大加快了访问速度和提升用户体验。而且他的第三方ui库可以节省很多不必要的开发时间。<br>选用Vue的原因中很重要的一点即为图中的MVVM架构，在MVVM中视图和模型是无法直接进行交互的，而他们中间存在着一个中转站，就是ViewModel。当用户对视图进行相关操作时，和视图相连的ViewModel中的一部分就会通知模型层内容的变化，同理，当模型变化时，ViewModel也可以通知试图层进行改变，这就是Vue中的双向数据绑定。类似于通知者通过关键字来通知订阅者的模式。<br>1.双向数据绑定实现浏览器页面的自动刷新。<br>2.轻量级js库，API简洁易用。<br>3.element-ui库</strong></p><h3 id="2-springboot框架">2.springboot框架</h3><p><strong>后台使用spring boot框架，spring boot 并不是用来替代 Spring 的解决方案，而是和 Spring 框架紧密结合用于提升 Spring 开发者体验的工具。同时它集成了大量常用的第三方库配置，Spring Boot应用中这些第三方库几乎可以是零配置的开箱即用（out-of-the-box），大部分的 Spring Boot 应用都只需要非常少量的配置代码（基于 Java 的配置），开发者能够更加专注于业务逻辑。<br>AOP为spring框架中切面编程的实现，AOP可以降低代码之间的耦合度，方便dang当前系统的扩展和代码复用，在OA系统中，我使用AOP进行日志的相关管理和操作。AOP的自定义标签从AopNamespaceHandler这个类开始解析，进入到AspectJAutoProxyBeanDefinitionParser解析器后，调用BeanDefinitionParser的parser方法将请求转交给registerAspectJAnnotationAutoProxyCreatorIfNecessary去实现。在注册或升级即registerAspectJAnnotationAutoProxyCreatorIfNecessary方法处理完成以后根据proxy-target-class的属性来确定使用什么方式的代理，最后调用registerComponentIfNecessary通知监听器。我在使用中正是运用了此流程，使用自定义的AOP注解，将注解注释在需要记录操作的接口方法上，通过通知类型来获取接口数据，进而和数据库交互存储对应的日志信息。<br>springboot是对spring框架的封装。<br>1.简化配置，无需配置xml<br>2.内置tomcat，可是使用maven打包成jar包之后直接在服务器上运行。<br>3.完美兼容当前成熟的开发组件。</strong></p><h3 id="3-前后端分离">3.前后端分离</h3><p><strong>前台通过ajax向后台restful风格的接口发起请求，获取json格式的数据进行解析展示。<br>1.前后端业务逻辑解耦。<br>2.分担后端服务器承受压力。<br>3.分开部署，解耦操作，更新方便。</strong></p><h3 id="4-JWT">4.JWT</h3><p><strong>由于后台管理系统采用了前后端分离开发的方式，那么就必然存在前端与后端的接口交互，于是就涉及到了安全问题，后端该如何确认收到的请求是合法的客户端发出的。普通的session中存储用户信息的方法在前后端交互中不可避免的会存在资源开销较大的问题，因此，在智慧谷OA系统的开发中，我使用了JWT来进行认证。JWT认证在用户登录时生成token，并且在下次接口请求时携带相同的token，不仅解决了资源开销的问题，而且JWT的信息使用HS256和RS256算法签名，保证了其在传输过程中的安全性。<br>JWT一共由三段内容组成，JWT在认证过程中，使用对称算法时，服务器端就获取到接收的JWT的前两段信息作为数据，用相同的算法和密钥进行签名，得到签名后将服务器端的签名和JWT中的第三段内容进行比较，如果相同认证即为成功。使用非对称加密算法时，由一对密钥构成，私钥由服务器端存储，公钥客户端存储，客户端进行验证的时候，用公钥解密收到的签名,得到JWT三段内容中的前两段，再用这两段内容和JWT进行比较，相同则验证成功。<br>由于JWT不能保证数据在传输中不被窃取，因此除了使用非对称加密算法之外，还需要在JWT的内容中设置合理的过期时间来确保数据的安全性。<br>session方式将用户信息存储到session中，session存储到内存中，当用户数据增多时，增大服务器的开销。<br>token方式将用户数据发送到服务器，服务器使用SHA256或其他算法计算token，客户端接收存储，在请求时将token存储于请求头中。</strong></p><h3 id="5-Activiti">5.Activiti</h3><p><img src="http://dingdm.online/9f2d207d579d4c7ea7114ab042429f0d.png" alt=""><br><strong>Activiti由图中模块构成，Activiti Engine为Activiti的核心，负责数据的处理，Activiti Modeler为模型设计器，Activities Rest支持Restful风格的服务，允许以JSON的格式进行交互，支持跨语言和跨平台。<br>Activiti组件使用Mybatis和数据库进行交互，完全契合当前的智慧谷OA系统，且Activiti具有简单易懂的接口和全面的流程设计器，适合任何人的使用与开发。而Activiti原生支持spring这一特性大大减少了在开发过程中的难度和工作量。<br>引入官方依赖，使用Activiti的可视化流程编辑器整合。<br>编写对应的流程方法和监听器。</strong></p><h3 id="前端代码">前端代码</h3><pre class=" language-language-html"><code class="language-language-html">**配置**<!-- 开发环境 -->  &lt;% if (process.env.VUE_APP_NODE_ENV === 'dev') { %&gt;    <script>window.SITE_CONFIG['apiURL'] = 'http://127.0.0.1:8081/wisdom';</script>  &lt;% } %&gt;  <!-- 集成测试环境 -->  &lt;% if (process.env.VUE_APP_NODE_ENV === 'prod:sit') { %&gt;    <script>window.SITE_CONFIG['apiURL'] = 'http://47.100.126.191:8081/wisdom';</script>  &lt;% } %&gt;  <!-- 验收测试环境 -->  &lt;% if (process.env.VUE_APP_NODE_ENV === 'prod:uat') { %&gt;    <script>window.SITE_CONFIG['apiURL'] = 'http://47.100.126.191:8081/wisdom';</script>  &lt;% } %&gt;  <!-- 生产环境 -->  &lt;% if (process.env.VUE_APP_NODE_ENV === 'prod') { %&gt;    <script>window.SITE_CONFIG['apiURL'] = 'http://47.100.126.191:8081/wisdom';</script>  &lt;% } %&gt;</code></pre><p><strong>数据接口</strong></p><pre class=" language-language-javascript"><code class="language-language-javascript">export default {  data () {    /* eslint-disable */    return {      // 设置属性      mixinViewModuleOptions: {        activatedIsNeed: true,    // 此页面是否在激活（进入）时，调用查询数据列表接口？        getDataListURL: '',       // 数据列表接口，API地址        getDataListIsPage: false, // 数据列表接口，是否需要分页？        deleteURL: '',            // 删除接口，API地址        deleteIsBatch: false,     // 删除接口，是否需要批量？        deleteIsBatchKey: 'id',   // 删除接口，批量状态下由那个key进行标记操作？比如：pid，uid...        exportURL: ''             // 导出接口，API地址      },      // 默认属性      dataForm: {},               // 查询条件      dataList: [],               // 数据列表      order: 'desc',                  // 排序，asc／desc      orderField: 'create_date',             // 排序，字段      page: 1,                    // 当前页码      limit: 10,                  // 每页数      total: 0,                   // 总条数      dataListLoading: false,     // 数据列表，loading状态      dataListSelections: [],     // 数据列表，多选项      addOrUpdateVisible: false   // 新增／更新，弹窗visible状态    }    /* eslint-enable */  },  activated () {    if (this.mixinViewModuleOptions.activatedIsNeed) {      this.getDataList()    }  },  methods: {    // 获取数据列表    getDataList () {      this.dataListLoading = true      this.$http.get(        this.mixinViewModuleOptions.getDataListURL,        {          params: {            order: this.order,            orderField: this.orderField,            page: this.mixinViewModuleOptions.getDataListIsPage ? this.page : null,            limit: this.mixinViewModuleOptions.getDataListIsPage ? this.limit : null,            ...this.dataForm          }        }      ).then(({ data: res }) =&gt; {        this.dataListLoading = false        if (res.code !== 0) {          this.dataList = []          this.total = 0          return this.$message.error(res.msg)        }        this.dataList = this.mixinViewModuleOptions.getDataListIsPage ? res.data.list : res.data        this.total = this.mixinViewModuleOptions.getDataListIsPage ? res.data.total : 0      }).catch(() =&gt; {        this.dataListLoading = false      })    },    // 多选    dataListSelectionChangeHandle (val) {      this.dataListSelections = val    },    // 排序    dataListSortChangeHandle (data) {      if (!data.order || !data.prop) {        this.order = ''        this.orderField = ''        return false      }      this.order = data.order.replace(/ending$/, '')      this.orderField = data.prop.replace(/([A-Z])/g, '_$1').toLowerCase()      this.getDataList()    },    // 分页, 每页条数    pageSizeChangeHandle (val) {      this.page = 1      this.limit = val      this.getDataList()    },    // 分页, 当前页    pageCurrentChangeHandle (val) {      this.page = val      this.getDataList()    },    // 新增 / 修改    addOrUpdateHandle (id) {      this.addOrUpdateVisible = true      this.$nextTick(() =&gt; {        this.$refs.addOrUpdate.dataForm.id = id        this.$refs.addOrUpdate.init()      })    },    // 删除    deleteHandle (id) {      if (this.mixinViewModuleOptions.deleteIsBatch &amp;&amp; !id &amp;&amp; this.dataListSelections.length &lt;= 0) {        return this.$message({          message: this.$t('prompt.deleteBatch'),          type: 'warning',          duration: 500        })      }      this.$confirm(this.$t('prompt.info', { 'handle': this.$t('delete') }), this.$t('prompt.title'), {        confirmButtonText: this.$t('confirm'),        cancelButtonText: this.$t('cancel'),        type: 'warning'      }).then(() =&gt; {        this.$http.delete(          `${this.mixinViewModuleOptions.deleteURL}${this.mixinViewModuleOptions.deleteIsBatch ? '' : '/' + id}`,          this.mixinViewModuleOptions.deleteIsBatch ? {            'data': id ? [id] : this.dataListSelections.map(item =&gt; item[this.mixinViewModuleOptions.deleteIsBatchKey])          } : {}        ).then(({ data: res }) =&gt; {          if (res.code !== 0) {            return this.$message.error(res.msg)          }          this.$message({            message: this.$t('prompt.success'),            type: 'success',            duration: 500,            onClose: () =&gt; {              this.getDataList()            }          })        }).catch(() =&gt; {})      }).catch(() =&gt; {})    },    // 导出    exportHandle () {      var params = qs.stringify({        'token': Cookies.get('token'),        ...this.dataForm      })      window.location.href = `${window.SITE_CONFIG['apiURL']}${this.mixinViewModuleOptions.exportURL}?${params}`    }  }</code></pre><p><strong>缓存</strong></p><pre class=" language-language-javascript"><code class="language-language-javascript">export default new Vuex.Store({  namespaced: true,  state: {    // 导航条, 布局风格, defalut(白色) / colorful(鲜艳)    navbarLayoutType: 'colorful',    // 侧边栏, 布局皮肤, default(白色) / dark(黑色)    sidebarLayoutSkin: 'dark',    // 侧边栏, 折叠状态    sidebarFold: false,    // 侧边栏, 菜单    sidebarMenuList: [],    sidebarMenuActiveName: '',    // 内容, 是否需要刷新    contentIsNeedRefresh: false,    ip: 'http://47.100.126.191:8081',    // 内容, 标签页(默认添加首页)    contentTabs: [      {        ...window.SITE_CONFIG['contentTabDefault'],        'name': 'home',        'title': 'home'      }    ],    contentTabsActiveName: 'home'  },  modules: {    user  },  mutations: {    // 重置vuex本地储存状态    resetStore (state) {      Object.keys(state).forEach((key) =&gt; {        state[key] = cloneDeep(window.SITE_CONFIG['storeState'][key])      })    }  }})</code></pre><p><strong>国际化</strong></p><pre class=" language-language-javascript"><code class="language-language-javascript"><script>import Cookies from 'js-cookie'import { messages } from '@/i18n'export default {  watch: {    '$i18n.locale': 'i18nHandle'  },  created () {    this.i18nHandle(this.$i18n.locale)  },  methods: {    i18nHandle (val, oldVal) {      Cookies.set('language', val)      document.querySelector('html').setAttribute('lang', val)      document.title = messages[val].brand.lg      // 非登录页面，切换语言刷新页面      if (this.$route.name !== 'login' && oldVal) {        window.location.reload()      }    }  }}</script></code></pre><h3 id="后台相关代码">后台相关代码</h3><p><strong>请求头token验证</strong></p><pre class=" language-language-java"><code class="language-language-java">public class Oauth2Filter extends AuthenticatingFilter {    @Override    protected AuthenticationToken createToken(ServletRequest request, ServletResponse response) throws Exception {        //获取请求token        String token = getRequestToken((HttpServletRequest) request);        if(StringUtils.isBlank(token)){            return null;        }        return new Oauth2Token(token);    }    @Override    protected boolean isAccessAllowed(ServletRequest request, ServletResponse response, Object mappedValue) {        if(((HttpServletRequest) request).getMethod().equals(RequestMethod.OPTIONS.name())){            return true;        }        return false;    }    @Override    protected boolean onAccessDenied(ServletRequest request, ServletResponse response) throws Exception {        //获取请求token，如果token不存在，直接返回401        String token = getRequestToken((HttpServletRequest) request);        if(StringUtils.isBlank(token)){            HttpServletResponse httpResponse = (HttpServletResponse) response;            httpResponse.setContentType("application/json;charset=utf-8");            httpResponse.setHeader("Access-Control-Allow-Credentials", "true");            httpResponse.setHeader("Access-Control-Allow-Origin", HttpContextUtils.getOrigin());            String json = new Gson().toJson(new Result().error(ErrorCode.UNAUTHORIZED));            httpResponse.getWriter().print(json);            return false;        }        return executeLogin(request, response);    }    @Override    protected boolean onLoginFailure(AuthenticationToken token, AuthenticationException e, ServletRequest request, ServletResponse response) {        HttpServletResponse httpResponse = (HttpServletResponse) response;        httpResponse.setContentType("application/json;charset=utf-8");        httpResponse.setHeader("Access-Control-Allow-Credentials", "true");        httpResponse.setHeader("Access-Control-Allow-Origin", HttpContextUtils.getOrigin());        try {            //处理登录失败的异常            Throwable throwable = e.getCause() == null ? e : e.getCause();            Result r = new Result().error(HttpStatus.SC_UNAUTHORIZED, throwable.getMessage());            String json = new Gson().toJson(r);            httpResponse.getWriter().print(json);        } catch (IOException e1) {        }        return false;    }    /**     * 获取请求的token     */    private String getRequestToken(HttpServletRequest httpRequest){        //从header中获取token        String token = httpRequest.getHeader(Constant.TOKEN_HEADER);        //如果header中不存在token，则从参数中获取token        if(StringUtils.isBlank(token)){            token = httpRequest.getParameter(Constant.TOKEN_HEADER);        }        return token;    }}</code></pre><p><strong>验证授权</strong></p><pre class=" language-language-java"><code class="language-language-java">@Componentpublic class Oauth2Realm extends AuthorizingRealm {    @Autowired    private ShiroService shiroService;    @Override    public boolean supports(AuthenticationToken token) {        return token instanceof Oauth2Token;    }    /**     * 授权(验证权限时调用)     */    @Override    protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) {        UserDetail user = (UserDetail)principals.getPrimaryPrincipal();        //用户权限列表        Set<string> permsSet = shiroService.getUserPermissions(user);        SimpleAuthorizationInfo info = new SimpleAuthorizationInfo();        info.setStringPermissions(permsSet);        return info;    }    /**     * 认证(登录时调用)     */    @Override    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException {        String accessToken = (String) token.getPrincipal();        //根据accessToken，查询用户信息        SysUserTokenEntity tokenEntity = shiroService.getByToken(accessToken);        //token失效        if(tokenEntity == null || tokenEntity.getExpireDate().getTime() &lt; System.currentTimeMillis()){            throw new IncorrectCredentialsException(MessageUtils.getMessage(ErrorCode.TOKEN_INVALID));        }        //查询用户信息        SysUserEntity userEntity = shiroService.getUser(tokenEntity.getUserId());        //转换成UserDetail对象        UserDetail userDetail = ConvertUtils.sourceToTarget(userEntity, UserDetail.class);        //获取用户对应的部门数据权限        List<long> deptIdList = shiroService.getDataScopeList(userDetail.getId());        userDetail.setDeptIdList(deptIdList);        //账号锁定        if(userDetail.getStatus() == 0){            throw new LockedAccountException(MessageUtils.getMessage(ErrorCode.ACCOUNT_LOCK));        }        SimpleAuthenticationInfo info = new SimpleAuthenticationInfo(userDetail, accessToken, getName());        return info;    }}</long></string></code></pre><p><strong>token生成</strong></p><pre class=" language-language-java"><code class="language-language-java">public class TokenGenerator {    public static String generateValue() {        return generateValue(UUID.randomUUID().toString());    }    private static final char[] HEX_CODE = "0123456789abcdef".toCharArray();    public static String toHexString(byte[] data) {        if(data == null) {            return null;        }        StringBuilder r = new StringBuilder(data.length*2);        for ( byte b : data) {            r.append(HEX_CODE[(b &gt;&gt; 4) &amp; 0xF]);            r.append(HEX_CODE[(b &amp; 0xF)]);        }        return r.toString();    }    public static String generateValue(String param) {        try {            MessageDigest algorithm = MessageDigest.getInstance("MD5");            algorithm.reset();            algorithm.update(param.getBytes());            byte[] messageDigest = algorithm.digest();            return toHexString(messageDigest);        } catch (Exception e) {            throw new RenException("token invalid", e);        }    }}</code></pre><p><strong>监听器</strong></p><pre class=" language-language-java"><code class="language-language-java">public class LeaderListenImpl implements TaskListener{    @Override    public void notify(DelegateTask delegateTask) {        ServletRequestAttributes requestAttributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();        HttpServletRequest request = requestAttributes.getRequest();        WebApplicationContext webApplicationContext = WebApplicationContextUtils.getWebApplicationContext(request.getServletContext());        SysUserService userService = webApplicationContext.getBean(SysUserService.class);        List<string> strings = new ArrayList<string>();        List<sysuserdto> list = userService.getUserByRole(RoleEnum.LEADER.value());        for (SysUserDTO user : list) {            strings.add(user.getUsername());        }        delegateTask.addCandidateUsers(strings);        ApprovalTbService approvalTbService = webApplicationContext.getBean(ApprovalTbService.class);        ApprovalTbDTO approvalTbDTO = (ApprovalTbDTO) delegateTask.getVariable(ActivitiEnum.APPROVAL.value());        approvalTbService.updateType(RoleEnum.LEADERNAME.value(),approvalTbDTO.getId());        if(list.size() &gt; 0){            Long dealId = (Long) delegateTask.getVariable(ActivitiEnum.DEALID.value());            UtilService utilService = webApplicationContext.getBean(UtilService.class);            utilService.updateDeal(dealId,list);        }    }}</sysuserdto></string></string></code></pre><p><strong>定时任务</strong></p><pre class=" language-language-java"><code class="language-language-java">@Component("downTask")public class DownTask implements ITask{private Logger logger = LoggerFactory.getLogger(getClass());@Autowiredprivate ActivityService activityService;@Overridepublic void run(String params){List<activitydto> allActivity = activityService.getAllActivity(ActivityEnum.DOWN.value());if(allActivity.size() &gt; 0){for(ActivityDTO activityDTO : allActivity){activityService.changeState(activityDTO.getId());logger.debug(activityDTO.getId() + "资源已释放！");}}}}</activitydto></code></pre><h3 id="企业项目淮安智慧谷OA相关文件">企业项目淮安智慧谷OA相关文件</h3><h4 id="文档文件">文档文件</h4><p><a href="http://dingdm.online/%E6%99%BA%E6%85%A7%E8%B0%B7OA-%E5%8E%9F%E5%A7%8B%E9%9C%80%E6%B1%8220200110.doc" target="_blank" rel="noopener">智慧谷OA-原始需求20200110.doc</a></p><p><a href="http://dingdm.online/%E6%99%BA%E6%85%A7%E8%B0%B7OA-%E5%88%9D%E6%AD%A5%E9%9C%80%E6%B1%8220200112.docx" target="_blank" rel="noopener">智慧谷OA-初步需求20200112.docx</a></p><p><a href="http://dingdm.online/%E7%B3%BB%E7%BB%9F%E5%AE%8C%E5%96%84%E9%9C%80%E6%B1%82.docx" target="_blank" rel="noopener">系统完善需求.doc</a></p><p><a href="http://dingdm.online/%E7%B3%BB%E7%BB%9F%E5%AE%8C%E5%96%84%E9%9C%80%E6%B1%822.docx" target="_blank" rel="noopener">系统完善需求2.doc</a></p><p><a href="http://dingdm.online/%E5%89%A9%E4%BD%99%E5%A4%84%E7%90%86%E9%A1%B9.docx" target="_blank" rel="noopener">剩余处理项.doc</a></p><p><a href="http://dingdm.online/%E5%89%A9%E4%BD%99%E5%A4%84%E7%90%86%E9%A1%B93.docx" target="_blank" rel="noopener">剩余处理项3.doc</a></p><p><a href="http://dingdm.online/%E5%89%A9%E4%BD%99%E5%A4%84%E7%90%86%E9%A1%B94.1.docx" target="_blank" rel="noopener">剩余处理项4.1.doc</a></p><p><a href="http://dingdm.online/%E5%89%A9%E4%BD%99%E5%A4%84%E7%90%86%E9%A1%B95-%E6%9C%80%E6%96%B0.docx" target="_blank" rel="noopener">剩余处理项4.5-最新.doc</a></p><p><a href="http://dingdm.online/%E5%89%A9%E4%BD%99%E5%A4%84%E7%90%86%E9%A1%B94.2--%E5%A4%84%E7%90%86%E7%BB%93%E6%9E%9C.docx" target="_blank" rel="noopener">剩余处理项4.2.doc</a></p><p><a href="http://dingdm.online/11.27%E5%AE%8C%E5%96%84%E6%95%B4%E7%90%86.docx" target="_blank" rel="noopener">11.27完善整理.doc</a></p><p><a href="http://dingdm.online/11.27%E5%AE%8C%E5%96%84%E6%95%B4%E7%90%86%20-%20%E5%8F%8D%E9%A6%88.docx" target="_blank" rel="noopener">11.27完善整理 - 反馈.doc</a></p><p><a href="http://dingdm.online/1.21.docx" target="_blank" rel="noopener">1.9 后台测试反馈.doc</a></p><p><a href="http://dingdm.online/1.21.docx" target="_blank" rel="noopener">1.21.doc</a></p><p><a href="http://dingdm.online/%E9%A1%B9%E7%9B%AE%E4%BF%A1%E6%81%AF.xlsx" target="_blank" rel="noopener">资产管理模块需求-二期-暂时不做.docx</a></p><h4 id="表单文件">表单文件</h4><p><a href="http://dingdm.online/%E6%9D%A5%E8%AE%BF%E8%A1%A8%E5%8D%95.docx" target="_blank" rel="noopener">来访表单.doc</a></p><p><a href="http://dingdm.online/%E6%B4%BB%E5%8A%A8%E7%94%B3%E8%AF%B7%E8%A1%A8%E5%8D%95.docx" target="_blank" rel="noopener">活动申请表单.doc</a></p><h4 id="xlsx导入模板">xlsx导入模板</h4><p><a href="http://dingdm.online/%E9%A1%B9%E7%9B%AE%E4%BF%A1%E6%81%AF.xlsx" target="_blank" rel="noopener">项目信息.xlsx</a></p><p><a href="http://dingdm.online/%E4%BA%BA%E6%89%8D%E4%BF%A1%E6%81%AF.xlsx" target="_blank" rel="noopener">人才信息.xlsx</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 项目开发 </category>
          
          <category> 答辩 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
            <tag> JWT </tag>
            
            <tag> Avtiviti </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>红黑树</title>
      <link href="/2020/08/01/hong-hei-shu/"/>
      <url>/2020/08/01/hong-hei-shu/</url>
      
        <content type="html"><![CDATA[<h3 id="为什么要使用红黑树">为什么要使用红黑树</h3><p><strong>当冲突的链表长度超过8个时，链表结构就会转为红黑树结构，这样做的好处是避免在极端条件的情况下冲突链表过长而导致查询效率非常慢</strong><br><strong>红黑树是一种近似平衡的二叉查找树，其主要的优点就是平衡，即左右子树高度几乎一致，以此来防止树退化为链表，通过这种方式来保障查找的时间复杂度为log(n)</strong></p><h3 id="红黑树">红黑树</h3><p><img src="http://dingdm.online/QQ%E6%88%AA%E5%9B%BE20200626184132.png" alt="红黑树" title="红黑树"></p><table><thead><tr><th>红黑树要求</th></tr></thead><tbody><tr><td>1.每个节点或者是黑色，或者是红色</td></tr><tr><td>2.根节点是黑色</td></tr><tr><td>3.每个叶子结点（这里的叶子结点不是传统的叶子结点，是指为空的叶子结点）是黑色</td></tr><tr><td>4.如果一个结点是红色的，则它的子结点必须是黑色的</td></tr><tr><td>5.从一个结点到该结点的子孙结点的所有路径上包含相同数目的黑结点</td></tr><tr><td>6.新加入到红黑树的节点为红色节点</td></tr></tbody></table><p><strong>在树的结构发生改变时，往往会破坏红色节点的孩子和父亲都不能是红色的和从任意节点到其子树中每个叶子结点的路径有相同数量的黑色节点这两个条件，需要通过调整使得查找树重新满足红黑树的条件</strong></p><h3 id="调整方式">调整方式</h3><h4 id="颜色调整">颜色调整</h4><p><strong>转换节点的颜色</strong></p><h4 id="结构调整">结构调整</h4><h5 id="左旋">左旋</h5><p><img src="http://dingdm.online/QQ%E6%88%AA%E5%9B%BE20200626185320.png" alt="左旋" title="左旋"></p><table><thead><tr><th>序号</th><th>步骤</th></tr></thead><tbody><tr><td>1</td><td>Y的左孩子设为X的右孩子，即β的父亲为X</td></tr><tr><td>2</td><td>将X的父亲设为Y的父亲</td></tr><tr><td>2.1</td><td>若X的父亲为空，则Y为根节点</td></tr><tr><td>2.2</td><td>X为他父亲的左节点，则Y为X父亲的左节点；X为他父亲的右节点，则Y为X父亲的右节点</td></tr><tr><td>3</td><td>X设为Y的左节点，即X的父亲为Y</td></tr></tbody></table><pre class=" language-language-java"><code class="language-language-java">static final class TreeNode<k,v> extends LinkedHashMap.Entry<k,v> {    //指向父节点的指针 TreeNode<k,v> parent;    //指向左孩子的指针 TreeNode<k,v> left;    //指向右孩子的指针 TreeNode<k,v> right;    //前驱指针，跟next属性相反的指向 TreeNode<k,v> prev;    //是否为红色节点 boolean red;    //左旋方法如下    static <k, v=""> TreeNode<k, v=""> rotateLeft(TreeNode<k, v=""> root,                                            TreeNode<k, v=""> x) {        TreeNode<k, v=""> y, parent, β;//x表示要调整的节点，y表示x的右节点，parent表示x的parent节点，β表示x的右孩子的左孩子节点        //判断y，如果y为空则旋转没有意义        if (y != null &amp;&amp; (β = y.left) != null) {            //设置的β父亲为x，β为x的右节点            if ((β = y.left) != null)                x.right = β;            //判断x的父亲，为空，y为根节点，根节点的话就设置为黑色            if ((parent = x.parent ) == null)                (root = y).red = false;                //判断x节点是左儿子还是右儿子            else if (parent.left == x)                parent.left = y;            else                parent.right = y;            y.left = x;            x.parent = y;        }        return root;    }}</k,></k,></k,></k,></k,></k,v></k,v></k,v></k,v></k,v></k,v></code></pre><h5 id="右旋">右旋</h5><p><img src="http://dingdm.online/QQ%E6%88%AA%E5%9B%BE20200626191905.png" alt="右旋" title="右旋"><br><strong>右旋和左旋的原理相同</strong></p><h5 id="插入新节点调整">插入新节点调整</h5><p><img src="http://dingdm.online/QQ%E6%88%AA%E5%9B%BE20200626192839.png" alt="插入" title="插入"><br><strong>插入新节点为红色是为了不违背特性5</strong><br><strong>当前节点(即，被插入节点)的父节点是红色，且当前节点的祖父节点的另一个子节点（叔叔节点）也是红色</strong><br><strong>(1) 将“父节点”设为黑色。<br>(2) 将“叔叔节点”设为黑色。<br>(3) 将“祖父节点”设为“红色”。<br>(4) 将“祖父节点”设为“当前节点”(红色节点)；即，之后继续对“当前节点”进行操作</strong><br><img src="http://dingdm.online/QQ%E6%88%AA%E5%9B%BE20200626193021.png" alt="调整" title="调整"><br><strong>“当前节点”和“父节点”都是红色，违背“特性(4)”。将“父节点”设置“黑色”以解决这个问题。<br>但是，将“父节点”由“红色”变成“黑色”之后，违背了“特性(5)”：因为，包含“父节点”的分支的黑色节点的总数增加了1。 解决这个问题的办法是：将“祖父节点”由“黑色”变成红色，同时，将“叔叔节点”由“红色”变成“黑色”。关于这里，说明几点：第一，为什么“祖父节点”之前是黑色？这个应该很容易想明白，因为在变换操作之前，该树是红黑树，“父节点”是红色，那么“祖父节点”一定是黑色。 第二，为什么将“祖父节点”由“黑色”变成红色，同时，将“叔叔节点”由“红色”变成“黑色”；能解决“包含‘父节点’的分支的黑色节点的总数增加了1”的问题。这个道理也很简单。“包含‘父节点’的分支的黑色节点的总数增加了1” 同时也意味着 “包含‘祖父节点’的分支的黑色节点的总数增加了1”，既然这样，我们通过将“祖父节点”由“黑色”变成“红色”以解决“包含‘祖父节点’的分支的黑色节点的总数增加了1”的问题； 但是，这样处理之后又会引起另一个问题“包含‘叔叔’节点的分支的黑色节点的总数减少了1”，现在我们已知“叔叔节点”是“红色”，将“叔叔节点”设为“黑色”就能解决这个问题。 所以，将“祖父节点”由“黑色”变成红色，同时，将“叔叔节点”由“红色”变成“黑色”；就解决了该问题。<br>按照上面的步骤处理之后：当前节点、父节点、叔叔节点之间都不会违背红黑树特性，但祖父节点却不一定。若此时，祖父节点是根节点，直接将祖父节点设为“黑色”，那就完全解决这个问题了；若祖父节点不是根节点，那我们需要将“祖父节点”设为“新的当前节点”，接着对“新的当前节点”进行分析。</strong><br><img src="http://dingdm.online/QQ%E6%88%AA%E5%9B%BE20200626193519.png" alt=""><br><img src="http://dingdm.online/QQ%E6%88%AA%E5%9B%BE20200626193543.png" alt=""></p><h5 id="红黑树的查询">红黑树的查询</h5><p><img src="http://dingdm.online/QQ%E6%88%AA%E5%9B%BE20200626193712.png" alt="红黑树查询" title="红黑树查询"></p><h5 id="红黑树的删除">红黑树的删除</h5><h6 id="被删除的D节点为红色。这种情况，则与D相关的颜色以及结构关系必然只有如下一种情况">被删除的D节点为红色。这种情况，则与D相关的颜色以及结构关系必然只有如下一种情况</h6><p><img src="http://dingdm.online/317300-20160505091642982-1989959722.png" alt="D节点为红色" title="D节点为红色"><br><strong>因为D为红色，所以P为黑色，同时DR不可能为红色(否则违反性质4)。同时由于性质5，则DR必为Nil，否则就D树来说，经过DR与不经过DR的路径的黑节点数必不相同。现在要删除D节点，只需要直接将D节点删除，并将DR作为P的左子节点</strong></p><h6 id="被删除的D节点为黑色">被删除的D节点为黑色</h6><p><img src="http://dingdm.online/317300-20160505091836732-1760252339.png" alt="D为黑色" title="D为黑色"><br><strong>由于删除的D为黑色，删除后P的左子树的黑节点数必少1，此时刚好DR为黑色，并且删除后DR可以占据D的位置，然后再将DR的颜色改为黑色，刚好可以填补P左子树所减少的黑节点数。</strong></p><h6 id="被删除的D为黑色，且DR为Nil">被删除的D为黑色，且DR为Nil</h6><p><img src="http://dingdm.online/317300-20160505091941513-167154460.png" alt=""><br><img src="http://dingdm.online/317300-20160505092013701-2109174939.png" alt=""><br><strong>转换后，虽然对于P树的左子树的黑节点数仍然会比右子树的黑节点数少1，但此时DR的兄弟(以前的S节点)现在已经变为SL，即已经由红色变为黑色，并且非常重要的此时的DR的兄弟节点SL的子结点(即：DR的两个侄子节点)，要不就是红色节点要不就必为Nil节点，而这种情况正是D为黑色、S也黑色的情况</strong></p><p><strong>所有图片来源于网络。</strong></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HashMap </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo插件及优化</title>
      <link href="/2020/07/31/hexo-cha-jian-tui-jian/"/>
      <url>/2020/07/31/hexo-cha-jian-tui-jian/</url>
      
        <content type="html"><![CDATA[<h3 id="hexo常用插件及优化">hexo常用插件及优化</h3><p>这里使用的主题为matery，闪烁之狐，matery主题的<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank" rel="noopener">github</a>仓库，作者提供的文档里已经给出了像代码高亮，拼音转换等插件，所以本文介绍的是除了作者提供的之外的其他简约插件。</p><h4 id="matery使用需知">matery使用需知</h4><h5 id="背景粒子和彩带设置">背景粒子和彩带设置</h5><p>matery的主题提供了这几项功能，但是默认是没有开启的，因此使用该主题需要手动开启，在themes/hexo-theme-matery目录下的_config.yml配置文件中修改以下几项。</p><pre class=" language-language-yml"><code class="language-language-yml">#背景canvas-nestcanvas_nest:  enable: true  color: 0,0,255 # 线条颜色, 默认: '0,0,0' ；三个数字分别为(R,G,B)，注意用,分$  pointColor: 0,0,255 # 交点颜色, 默认: '0,0,0' ；三个数字分别为(R,G,B)，注意$  opacity: 0.7 # 线条透明度（0~1）, 默认: 0.5  zIndex: -1 # 背景的 z-index 属性，css 属性用于控制所在层的位置, 默认: -1.  count: 99 # 线条的总数量, 默认: 99  # 背景静止彩带.ribbon:  enable: true  size: 150 # 彩带大小, 默认: 90.  alpha: 0.6 # 彩带透明度 (0 ~ 1), 默认: 0.6.  zIndex: -1 # 背景的z-index属性，css属性用于控制所在层的位置, 默认: -1.  clickChange: false  # 设置是否每次点击都更换彩带.# 背景动态彩带.ribbon_dynamic:  enable: true</code></pre><p>enable选项设置为true即可。</p><p>因为我这里的hexo博客是放在我的阿里云服务器上的，因此如果要修改内容我推荐smartty软件进行远程并修改文件相对方便。</p><h5 id="导航栏以及底部的配色修改">导航栏以及底部的配色修改</h5><p>matery的自带的导航栏鲜艳的配色有点问题，所以这里可以自己修改一下。</p><p>在主题下source下的css目录下，修改matery.css。分别修改第268和280行。</p><pre class=" language-language-css"><code class="language-language-css">.bg-color {    background-image: linear-gradient(to right, #4cbf30 0%, #0f9d58 100%);}.progress-bar {    height: 4px;    position: fixed;    bottom: 0;    z-index: 300;    background: linear-gradient(to right, #4cbf30 0%, #0f9d58 100%);    opacity: 0.8;}</code></pre><p>我这里修改为#4cbf30 0%, #0f9d58 100%</p><p><img src="http://dingdm.online/%E6%B8%90%E5%8F%98.png" alt=""></p><p>你也可以修改为自己看着好看的颜色，我这里放上几个配色的网站，可以由自己选择。</p><p><a href="https://coolors.co/" target="_blank" rel="noopener">https://coolors.co/</a></p><p><a href="http://www.materialpalette.com/" target="_blank" rel="noopener">http://www.materialpalette.com/</a></p><h5 id="轮播图和笔记展示图">轮播图和笔记展示图</h5><p>如果你在写笔记的时候不想自己上传封面的话而使用默认的图片的话，这里可以对封面的图片进行重新上传，选择好看的即可。</p><p>分别替换掉主题下source下medias中的banner和featureimages这两个文件夹下的图片即可。</p><p>同时如果想要增加featureimages下的图片，还需同步更改主题下_config.yml配置文件里的featureImages模块</p><pre class=" language-language-yml"><code class="language-language-yml"># The post featured images that needs to be displayed when there is no image.# 无文章特色图片时需要显示的文章特色图片.featureImages:- /medias/featureimages/0.jpg- /medias/featureimages/1.jpg- /medias/featureimages/2.jpg- /medias/featureimages/3.jpg- /medias/featureimages/4.jpg- /medias/featureimages/5.jpg- /medias/featureimages/6.jpg- /medias/featureimages/7.jpg- /medias/featureimages/8.jpg- /medias/featureimages/9.jpg- /medias/featureimages/10.jpg- /medias/featureimages/11.jpg- /medias/featureimages/12.jpg- /medias/featureimages/13.jpg- /medias/featureimages/14.jpg- /medias/featureimages/15.jpg- /medias/featureimages/16.jpg- /medias/featureimages/17.jpg- /medias/featureimages/18.jpg- /medias/featureimages/19.jpg- /medias/featureimages/20.jpg- /medias/featureimages/21.jpg- /medias/featureimages/22.jpg- /medias/featureimages/23.jpg</code></pre><p>同样，这里提供几个图片网站。替换图片时，图片的分辨率无需修改。</p><p><a href="https://wallhaven.cc/(%E8%B6%85%E6%A3%92)" target="_blank" rel="noopener">https://wallhaven.cc/(超棒)</a></p><p><a href="https://konachan.net/post" target="_blank" rel="noopener">https://konachan.net/post</a></p><h3 id="看板娘插件">看板娘插件</h3><p>注：如果你使用了matery的卜算子来统计数据的话，官方的helper-live的看板娘插件会使卜算子失效，同时官方提供的插件功能也较少，我这里推荐使用<a href="https://github.com/stevenjoezhang/live2d-widget" target="_blank" rel="noopener">该插件</a>。</p><p>如果是新手可以直接使用作者提供的js即可。</p><p><a href="https://cdn.jsdelivr.net/gh/stevenjoezhang/live2d-widget@latest/autoload.js" target="_blank" rel="noopener">https://cdn.jsdelivr.net/gh/stevenjoezhang/live2d-widget@latest/autoload.js</a></p><p>如果使用这个插件，会覆盖原matery主题的吸底模式的音乐播放插件。这里提供两种方式解决。</p><h4 id="fork新的仓库">fork新的仓库</h4><p>通过fork作者新的仓库，修改对应的css和js文件，这里在作者的github仓库下有对应的介绍，因此不再赘述。</p><p><img src="http://dingdm.online/fork.png" alt=""></p><p>修改适合自己的css和js文件后，发布新的版本，使用github的cdn加速获取js即可。</p><p>src=“<a href="https://cdn.jsdelivr.net/gh/username/live2d-widget@latest/autoload.js" target="_blank" rel="noopener">https://cdn.jsdelivr.net/gh/username/live2d-widget@latest/autoload.js</a>”</p><p>将这里的用户名替换自己的即可。若直接访问js文件访问失败403的话，因为缓存的原因可能不能显示，但是在自己的博客使用没有问题。</p><h4 id="修改吸底模式的音乐插件。">修改吸底模式的音乐插件。</h4><p>因为修改看板娘的文件之后还要修改回到顶端插件，如果你设置了在线聊天也要修改。如果你这里不想麻烦的话，直接将音乐插件的吸底模式取消即可。</p><p>在主题下的_config.yml配置文件中，修改music模块。将吸底模式关闭即可。</p><pre class=" language-language-yml"><code class="language-language-yml"># Whether to display the musics.# 是否在首页显示音乐.music:  enable: true  title: #非吸底模式有效    enable: true    show: 听听音乐  autoHide: true    # hide automaticaly  server: netease   #requiremusic platform: netease, tencent, kugou, xiami, baidu  type: playlist    #require song, playlist, album, search, artist  id: 503838841     #requiresong id / playlist id / album id / search keyword  fixed: false       # 开启吸底模式  autoplay: false   # 是否自动播放  theme: '#42b983'  loop: 'all'       # 音频循环播放, 可选值: 'all', 'one', 'none'  order: 'random'   # 音频循环顺序, 可选值: 'list', 'random'  preload: 'auto'   # 预加载，可选值: 'none', 'metadata', 'auto'  volume: 0.7       # 默认音量，请注意播放器会记忆用户设置，用户手动设置音量后默认音量即失效  listFolded: true  # 列表默认折叠  hideLrc: true     # 隐藏歌词</code></pre><h3 id="小地球插件">小地球插件</h3><p>小地球插件的地址<br><a href="https://www.revolvermaps.com/?target=setupgl">https://www.revolvermaps.com/?target=setupgl</a></p><p><img src="http://dingdm.online/%E5%B0%8F%E5%9C%B0%E7%90%83.png" alt=""></p><p>复制上面的srcipt标签放在自己的博客中合适的位置即可。</p><h3 id="天气插件">天气插件</h3><p>生成js地址</p><p><a href="https://cj.weather.com.cn/plugin/index" target="_blank" rel="noopener">https://cj.weather.com.cn/plugin/index</a></p><p>根据自己的需求选择对应的插件即可，我这里选择的是简约插件，UI比较漂亮</p><p><img src="http://dingdm.online/%E6%A0%B9%E6%8D%AE%E8%87%AA%E5%B7%B1%E9%80%89%E6%8B%A9%E5%AF%B9%E5%BA%94%E6%A8%A1%E5%9D%97.png" alt=""></p><p>选择对应的选项，在下方生成对应的js文件即可。</p><p><img src="http://dingdm.online/%E7%94%9F%E6%88%90js.png" alt=""></p><p>复制你的js文件放到你的主题下的相应的文件里即可，这里不对主题的文件进行介绍了，有一些vue基础就可以看懂了。</p><h3 id="阿里云部署博客">阿里云部署博客</h3><p>如果使用github来部署的话访问较慢，所以我这里推荐阿里云服务器部署，学生机10块钱一个月很便宜。如果是上班族的话，找个亲戚或朋友家的大学生不是计算机专业的认证一下就好。</p><h4 id="安装node-以ubuntu16-04为例">安装node(以ubuntu16.04为例)</h4><p>更新一下服务器的源</p><pre><code>apt-get updateapt-get install -y python-software-properties software-properties-commonadd-apt-repository ppa:chris-lea/node.jsapt-get update</code></pre><p>node安装</p><pre><code>apt-get install nodejsapt install nodejs-legacyapt install npm</code></pre><p>将npm的源设置为淘宝源，下载加速。</p><pre><code>npm config set registry https://registry.npm.taobao.orgnpm config list</code></pre><p>安装版本管理器</p><pre><code>npm install n -g</code></pre><h4 id="安装git">安装git</h4><pre><code>apt-get install git</code></pre><p>配置用户名和邮箱</p><pre><code>git config --global user.name "你的用户名"git config --global user.email "你的注册邮箱"</code></pre><h4 id="安装nginx">安装nginx</h4><pre><code>apt-get install nginx</code></pre><p>安装完nginx后，这里以ubuntu16.04为例，nginx的目录为/ect/nginx。我们修改配置文件只需要修改sites-available下的default即可。我这里在之前学习的时候都是不一样的路径，所以我这里以ubuntu为例。</p><pre><code>server {        listen 80 default_server;        listen [::]:80 default_server;        listen 443 ssl;        ssl off;        ssl_certificate cert/4287626_www.dingdm.club.pem;        ssl_certificate_key cert/4287626_www.dingdm.club.key;        ssl_session_timeout 5m;        #ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aN$        ssl_ciphers ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES128-SHA256:ECDHE-RSA-AES128-SHA256:ECDHE-ECDSA-AES128-SHA:ECDHE-RSA-AES256-SHA384:ECDHE-RSA-AES128-SHA:ECDHE-ECDSA-AES256-SHA384:ECDHE-ECDSA-AES256-SHA:ECDHE-RSA-AES256-SHA:DHE-RSA-AES128-SHA256:DHE-RSA-AES128-SHA:DHE-RSA-AES256-SHA256:DHE-RSA-AES256-SHA:ECDHE-ECDSA-DES-CBC3-SHA:ECDHE-RSA-DES-CBC3-SHA:EDH-RSA-DES-CBC3-SHA:AES128-GCM-SHA256:AES256-GCM-SHA384:AES128-SHA256:AES256-SHA256:AES128-SHA:AES256-SHA:DES-CBC3-SHA:!DSS;        ssl_protocols TLSv1 TLSv1.1 TLSv1.2;        ssl_prefer_server_ciphers on;        root /home/www/hexo;        server_name dingdm.club;}</code></pre><p>server_name为你的域名，root为你的静态网站所在的路径，可以自己创建，<strong>注意这里的路径不是你的hexo博客的路径，如果你在服务器上创建博客的话</strong>。</p><p>ssl的配置为开启https的配置，这里先不赘述，不需要的话可以将ssl相关的配置注释掉即可。</p><h4 id="初始化git仓库">初始化git仓库</h4><p>添加git用户，使用root账户也可以。</p><pre><code>adduser git</code></pre><p>修改文件内容赋予权限</p><pre><code>chmod 740 /etc/sudoersnano /etc/sudoers</code></pre><p>找到root用户那，在下方添加一条</p><pre><code>git ALL=(ALL) ALL</code></pre><p>将文件权限恢复</p><pre><code>chmod 400 /etc/sudoers</code></pre><p>切换到git用户，并创建ssh文件夹</p><pre><code>su gitcd ~mkdir .sshcd .ssh</code></pre><p>生成密钥公钥并配置</p><pre><code>ssh-keygencp id_rsa.pub authorized_keyschmod 600 ~/.ssh/authorized_keyschmod 700 ~/.ssh</code></pre><p>配置完成之后可以使用<code>ssh -v git@ip</code>连接测试</p><p>新建仓库并设置钩子脚本</p><pre><code>cd ~git init --bare blog.gitnano ~/blog.git/hooks/post-receive</code></pre><p>输入以下内容</p><pre><code>git --work-tree=/home/www/hexo --git-dir=/home/git/blog.git checkout -f</code></pre><p>/home/www/hexo为你刚刚在nginx的配置文件里的root路径，/home/git/blog.git为你的仓库地址</p><h4 id="hexo部署">hexo部署</h4><p>在你的hexo博客下的_config.yml配置文件中修改deploy模块</p><pre class=" language-language-yml"><code class="language-language-yml">deploy:  type: git  repo: git@公网IP:/home/git/blog.git    </code></pre><p>修改完成之后运行<code>hexo clean &amp;&amp; hexo deploy</code>部署你的hexo博客即可。</p><p>部署完成之后，使用/etc/init.d/nginx configtest检查一下nginx的配置是否有问题，如果没问题，运行<code>/etc/init.d/nginx restart</code>重启nginx服务即可。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
          <category> 美化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nginx </tag>
            
            <tag> git </tag>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一次steam个人资料动态设置</title>
      <link href="/2020/07/30/yi-ci-steam-ge-ren-zi-liao-dong-tai-she-zhi/"/>
      <url>/2020/07/30/yi-ci-steam-ge-ren-zi-liao-dong-tai-she-zhi/</url>
      
        <content type="html"><![CDATA[<h3 id="首先放上预览图">首先放上预览图</h3><p><a href="https://steamcommunity.com/profiles/76561198366411843" target="_blank" rel="noopener">https://steamcommunity.com/profiles/76561198366411843</a></p><h3 id="资料背景设置">资料背景设置</h3><p><strong>需要steam等级到达十级，拥有自己的艺术展柜。</strong><br><strong>首先需要在steam的社区-市场购买自己想要的个人资料背景，当然目前处于夏季促销，可以通过点数购买比较好看的背景。如果没有游戏的话，可以先买游戏，买完背景之后在退款就好了。</strong><br><strong>这里登陆不上市场需要挂加速器，UU加速器的免费steam加速就可以。</strong><br><strong>我这里选择的是Meteor Shower</strong><br><img src="https://steamcdn-a.akamaihd.net/steamcommunity/public/images/items/645690/06e52a6057125c91e4d88fd00e1f486bdee9a654.jpg" alt=""></p><h4 id="资料背景切割">资料背景切割</h4><p><a href="http://sapic.github.io/" target="_blank" rel="noopener">http://sapic.github.io/</a><br><strong>在当前页面上进行steam的登录，他会自动检索你的库存中的背景资料，自己选择即可。</strong><br><img src="http://dingdm.online/QQ%E6%88%AA%E5%9B%BE20200628231317.png" alt="下载" title="下载"><br><strong>自行下载对应的文件然后解压就可以看到对应的三个文件。</strong></p><h4 id="PS进行动态设置">PS进行动态设置</h4><p><strong>首先打开静态背景图片，然后调出时间轴，创建帧动画。</strong><br><img src="http://dingdm.online/QQ%E6%88%AA%E5%9B%BE20200628231525.png" alt="静态图片" title="静态图片"><br><strong>导入你自己的动态图片，然后选择所有帧之后，在选择拷贝所有帧。</strong><br><img src="http://dingdm.online/QQ%E6%88%AA%E5%9B%BE20200628231735.png" alt="选择所有帧" title="选择所有帧"><br><img src="http://dingdm.online/QQ%E6%88%AA%E5%9B%BE20200628231748.png" alt="拷贝所有帧" title="拷贝所有帧"><br><strong>选择静态背景，粘贴所有的帧，并置于图层之上</strong><br><img src="http://dingdm.online/QQ%E6%88%AA%E5%9B%BE20200628231911.png" alt="粘贴所有帧" title="粘贴所有帧"><br><img src="http://144.202.57.217:8080/uploadImages/63ac0df5b0ee466e83c0945faa381be8.png" alt="图层之上" title="图层之上"><br><strong>调整动画位置，设置动画循环，导出即可。</strong><br><img src="http://dingdm.online/QQ%E6%88%AA%E5%9B%BE20200628232116.png" alt="循环" title="循环"><br><img src="http://dingdm.online/QQ%E6%88%AA%E5%9B%BE20200628232133.png" alt="导出" title="导出"><br><strong>预览没有问题，导出即可。注意gif的大小不应超过8M</strong><br><img src="http://dingdm.online/QQ%E6%88%AA%E5%9B%BE20200628232148.png" alt="保存" title="保存"></p><h4 id="背景资料上传">背景资料上传</h4><p><a href="https://steamcommunity.com/login/home/?goto=%2Fsharedfiles%2Fedititem%2F767%2F3%2F" target="_blank" rel="noopener">https://steamcommunity.com/login/home/?goto=%2Fsharedfiles%2Fedititem%2F767%2F3%2F</a><br><strong>打开网页版的steam进行背景上传。</strong><br><strong>艺术作品的名字为空，防止上传完成之后出现名字。直接复制即可。</strong><br><code>⁡⁡⁡ ⁡⁠</code><br><strong>上传自己的除了头像外的其他两张图片，侧边和自己的gif。图片需要一张一张传</strong><br><strong>注意</strong><br><strong>上传完图片和添加完名字后，打开网页的console控制台。chrome右键检查即可。输入以下代码。</strong></p><pre class=" language-language-javascript"><code class="language-language-javascript">var num= document.getElementsByName("image_width")[0].value;document.getElementsByName("image_height")[0].value = num-(num-1);document.getElementsByName("image_width")[0].value= num*100;</code></pre><p><strong>这里代码的运行结果不为0即可，为0的话重复运行。</strong><br><img src="http://dingdm.online/QQ%E6%88%AA%E5%9B%BE20200628232812.png" alt="代码" title="代码"></p><h4 id="展柜设置">展柜设置</h4><p><strong>选择刚刚上传的图片保存即可。</strong><br><img src="http://dingdm.online/QQ%E6%88%AA%E5%9B%BE20200628232908.png" alt="艺术展柜" title="艺术展柜"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 游戏 </category>
          
          <category> 美化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> steam </tag>
            
            <tag> ps </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记一次服务器部署内容</title>
      <link href="/2020/07/28/ji-yi-ci-fu-wu-qi-bu-shu-nei-rong/"/>
      <url>/2020/07/28/ji-yi-ci-fu-wu-qi-bu-shu-nei-rong/</url>
      
        <content type="html"><![CDATA[<hr><p><strong>由于目前国内的域名需要备案，因此购买国外的域名，同时由于国外的域名解析到国内的服务器也需要备案，因此服务器也使用国外的，当然，需要一个备案的国内域名用于七牛CDN使用。</strong></p><h1>1.服务器域名选择</h1><p><strong>之前一直用的搬瓦工的服务器，但是现在搬瓦工的服务器配置高了，价格很贵，不是很划算，于是就用了vultr的服务器，五美元一个月，价格还可以，除了建站之外，当作梯子也是划算的。<br>vultr的平台需要先充值，最低额度十美元，支持支付宝付款还是可以的。</strong></p><h2 id="1-1-服务器购买">1.1 服务器购买</h2><p><img src="http://dingdm.online/%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%80%89%E6%8B%A9.png" alt=""><br><strong>服务器类型选择Cloud Compute就可以，用来个人需求绰绰有余。</strong><br><img src="http://dingdm.online/fuwuqixuanze" alt=""><br><strong>国家及城市根据自己需求选择就可以。<br>服务器操作系统我推荐Ubuntu16.04</strong><br><img src="http://dingdm.online/QQ%E6%88%AA%E5%9B%BE20200624211528.png" alt=""><br><strong>其他默认就好，购买完成就会看到自己的服务器</strong></p><h3 id="1-1-1">1.1.1</h3><p><strong>这里推荐两个软件，smarrty用于远程连接，Filezilla用于向服务器传输文件。<br>安装包我放在资源里面，可以在下载中自行下载。</strong></p><h2 id="1-2-域名购买">1.2 域名购买</h2><p><strong>域名购买我推荐nameSilo，不必要购买特别贵的，自己可以使用的就好<br>购买时挂梯子应该打开会快一点</strong><br><strong>官方网址<br><a href="https://www.namesilo.com/" target="_blank" rel="noopener">https://www.namesilo.com/</a><br>搜索自己想要的域名，然后进行购买</strong><br><img src="http://dingdm.online/QQ%E6%88%AA%E5%9B%BE20200624220852.png" alt=""><br><strong>选择第一个就可以了</strong><br><img src="http://dingdm.online/QQ%E6%88%AA%E5%9B%BE20200624220934.png" alt=""><br><strong>选择对应的配置和优惠码，优惠码百度一下，很多的，基本都是减一美元</strong><br><img src="http://dingdm.online/QQ%E6%88%AA%E5%9B%BE20200624221137.png" alt=""></p><h3 id="1-2-1-域名解析">1.2.1 域名解析</h3><p><strong>域名购买完成之后，点击manage my domains进入自己的域名管理页面</strong><br><img src="http://dingdm.online/QQ%E6%88%AA%E5%9B%BE20200624221243.png" alt=""><br><strong>下面显示的就是你刚刚购买的域名，然后点击蓝色的小球，dns设置</strong><br><img src="http://dingdm.online/QQ%E6%88%AA%E5%9B%BE20200624221256.png" alt=""><br><strong>进入到域名解析页面你会看到五条记录，将第三条和第四条删掉，然后编辑第一条和第二条。<br>第一条编辑的时候在ipv4栏输入你的服务器ip地址<br>第二条编辑的时候在1的基础上还要在hostname输入www</strong><br><img src="http://dingdm.online/QQ%E6%88%AA%E5%9B%BE20200624221324.png" alt=""></p><p><img src="http://dingdm.online/QQ%E6%88%AA%E5%9B%BE20200624221337.png" alt=""></p><h1>2.服务器配置及部署</h1><h2 id="2-1-服务器配置">2.1 服务器配置</h2><h3 id="2-1-1-java环境安装">2.1.1 java环境安装</h3><p><strong>由于我的项目是基于java开发的，所以安装Java环境。</strong><br><strong>首先卸载之前安装或参与的项，如果没有请忽略</strong><br><code>apt-get remove openjdk</code><br><strong>可以通过Oracle官网下载对应的jdk和在线安装两种方式进行安装</strong><br><strong>可以通过<code>apt install openjdk-8-jdk</code>的方式在线安装<br>也可以通过https://www.oracle.com/java/technologies/javase/javase-jdk8-downloads.html<br>官网下载对应的版本的jdk进行解压安装</strong></p><h4 id="2-1-1-1-配置环境变量">2.1.1.1 配置环境变量</h4><p><code>vim  ~/.bashrc</code><strong>也可以使用nano或vi 如果未安装vim</strong><br><strong>文件末尾添加以下内容</strong></p><pre class=" language-language-shell"><code class="language-language-shell">export JAVA_HOME=/usr/local/jdk1.8.0_211export JRE_HOME=${JAVA_HOME}/jreexport CLASSPATH=.:${JAVA_HOME}/lib:${JRE_HOME}/libexport PATH=.:${JAVA_HOME}/bin:$PATH</code></pre><p><strong>记得更换为自己文件所在的路径</strong><br><strong>保存变量并更新应用</strong><br><code>source ~/.bashrc</code><br><strong>使用</strong><code>java -version</code><strong>查看自己的java版本即可</strong></p><h3 id="2-1-2-docker安装">2.1.2 docker安装</h3><p><strong>由于项目使用到的redis，rabbitmq，mongodb都是基于docker容器的，因此先进行配置。</strong><br><strong>卸载存在的docker的旧版本</strong><br><code>apt-get remove docker docker-engine docker-ce docker.io</code><br><strong>更新apt包</strong><br><code>apt-get update</code><br><strong>安装以下包通过https使用存储库</strong><br><code>apt-get install -y apt-transport-https ca-certificates curl software-properties-common</code><br><strong>添加docker的GPG密钥</strong><br><code>curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -</code><br><strong>设置stable存储库</strong><br><code>add-apt-repository "deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable"</code><br><strong>更新apt包</strong><br><code>apt-get update</code><br><strong>安装docker</strong><br><code>apt-get install -y docker-ce</code><br><strong>验证服务是否启动</strong><br><code>systemctl status docker</code><br><strong>docker未启动，则手动启动docker</strong><br><code>systemctl start docker</code><br><strong>docker安装完成</strong></p><h4 id="2-1-2-1-docker安装mongodb">2.1.2.1 docker安装mongodb</h4><p><strong>下载镜像</strong><br><code>docker pull registry.docker-cn.com/library/mongo</code><br><strong>创建数据文件夹</strong><br><code>mkdir /data/mongodb0</code><br><strong>启动容器</strong><br><code>docker run --name mongodb-server0 -v /data/mongodb0:/data/db -p 27017:27017 -d 镜像ID --auth</code><br><strong>-v后面的参数表示把数据文件挂载到宿主机的路径<br>-p把mongo端口映射到宿主机的指定端口<br>–auth表示连接mongodb需要授权</strong></p><h4 id="2-1-2-2-docker安装redis">2.1.2.2 docker安装redis</h4><p><strong>拉取镜像</strong><br><code>docker pull redis</code><br><strong>启动镜像</strong><br><code>docker run -p 6379:6379 -d redis:latest redis-server</code><br><strong>-p 6379:6379 : 将容器的6379端口映射到主机的6379端口<br>-v $PWD/data:/data : 将主机中当前目录下的data挂载到容器的/data<br>redis-server --appendonly yes : 在容器执行redis-server启动命令，并打开redis持久化配置</strong><br><strong>docker的相关命令在其他笔记中已经说明过</strong><br><strong>redis的操作软件在附件中也已经上传，可以自行下载</strong></p><h4 id="2-1-2-3-docker安装rabbitMq">2.1.2.3 docker安装rabbitMq</h4><p><strong>拉取镜像</strong><br><code>docker pull rabbitmq:management</code><br><strong>运行镜像</strong><br><code>docker run -d -p 5672:5672 -p 15672:15672 --name rabbitmq rabbitmq:management</code><br><strong>访问管理页面<br>http://[宿主机IP]:15672</strong></p><h3 id="2-1-3-nginx安装">2.1.3 nginx安装</h3><p><strong>因为我使用了两个域名，一个为8080端口，一个为8060端口，因此需要使用nginx来进行端口的转发。</strong><br>安装nginx<br><code>apt-get install nginx</code><br><strong>安装好以后，nginx默认安装位置在etc目录下，这里我在使用的时候出现了nginx文件限制的问题，因此在这里统一进行说明。<br>在nginx下的nginx.conf配置文件中的http段对文件大小进行设置。</strong><br><code>client_max_body_size 100m;</code><br><strong>在sites-available下进行对应的端口转发配置</strong></p><pre class=" language-language-shell"><code class="language-language-shell">server {listen 80 default_server;listen [::]:80 default_server;root /var/www/html;index index.html index.htm index.nginx-debian.html;server_name dinggc.info;location / {      proxy_set_header   X-Real-IP        $remote_addr;      proxy_set_header   X-Forwarded-For  $proxy_add_x_forwarded_for;      proxy_set_header   Host             $http_host;      proxy_set_header   Upgrade          $http_upgrade;      proxy_set_header   X-NginX-Proxy    true;      proxy_set_header   Connection "upgrade";      proxy_http_version 1.1;      proxy_pass         http://localhost:8080;   }}</code></pre><pre class=" language-language-shell"><code class="language-language-shell">server {listen 80;   # 修改为你的域名   server_name dinggc.online;   location / {      proxy_set_header   X-Real-IP        $remote_addr;      proxy_set_header   X-Forwarded-For  $proxy_add_x_forwarded_for;      proxy_set_header   Host             $http_host;      proxy_set_header   Upgrade          $http_upgrade;      proxy_set_header   X-NginX-Proxy    true;      proxy_set_header   Connection "upgrade";      proxy_http_version 1.1;      proxy_pass         http://localhost:8060;   }}</code></pre><p><strong>使用</strong><code>/etc/init.d/nginx configtest</code><strong>进行配置测试如果成功则使用</strong><code>/etc/init.d/nginx reload</code><strong>重启nginx即可</strong><br><strong>至此，相关的服务器配置安装完成。</strong></p><h1>3 项目部署</h1><p><strong>使用filezilla软件将相关文件上传到服务器之后在线运行即可。<br>若使用nohup后台运行的话，注意不要直接关掉smartty，而应该使用exit命令退出命令行。</strong></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nginx </tag>
            
            <tag> ubuntu </tag>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springboot的启动流程</title>
      <link href="/2020/07/28/springboot-de-qi-dong-liu-cheng/"/>
      <url>/2020/07/28/springboot-de-qi-dong-liu-cheng/</url>
      
        <content type="html"><![CDATA[<h3 id="spring-boot的启动流程图">spring boot的启动流程图</h3><p><img src="http://dingdm.online/qidongliucheng.png" alt="启动流程图" title="启动流程图"><br><strong>springboot的流程启动主要为三个部分</strong></p><ul><li>SpringApplication的初始化，配置基础的环境变量，构造器，监听器等。</li><li>流程启动，主要为启动流程的监听，加载配置环境，创建上下文</li><li>自动化配置</li></ul><p><strong>springboot的主启动类入口</strong></p><pre class=" language-language-java"><code class="language-language-java">@SpringBootApplication(exclude = SecurityAutoConfiguration.class)@MapperScan(value = "cn.dingdm.website.mapper")@EnableCachingpublic class WebsiteApplication {    public static void main(String[] args) {        SpringApplication.run(WebsiteApplication.class, args);    }}</code></pre><p><strong>SpringBootApplication注解详解</strong></p><pre class=" language-language-java"><code class="language-language-java">@Target({ElementType.TYPE}) //注解的适用范围，其中TYPE用于描述类、接口（包括包注解类型）或enum声明@Retention(RetentionPolicy.RUNTIME) // 注解的生命周期，保留到class文件中（三个生命周期）@Documented // 表明这个注解应该被javadoc记录@Inherited // 子类可以继承该注解@SpringBootConfiguration // 继承了Configuration，表示当前是注解类@EnableAutoConfiguration // 开启springboot的注解功能，springboot的四大神器之一，其借助@import的帮助@ComponentScan( // 扫描路径设置    excludeFilters = {@Filter(    type = FilterType.CUSTOM,    classes = {TypeExcludeFilter.class}), @Filter(    type = FilterType.CUSTOM,    classes = {AutoConfigurationExcludeFilter.class})})public @interface SpringBootApplication {</code></pre><p><strong>ElementType枚举类</strong></p><pre class=" language-language-java"><code class="language-language-java">public enum ElementType {    TYPE,    FIELD,    METHOD,    PARAMETER,    CONSTRUCTOR,    LOCAL_VARIABLE,    ANNOTATION_TYPE,    PACKAGE,    TYPE_PARAMETER,    TYPE_USE}</code></pre><p><strong>生命周期枚举类</strong></p><pre class=" language-language-java"><code class="language-language-java">public enum RetentionPolicy {    SOURCE,    CLASS,    RUNTIME}</code></pre><p><strong>1、RetentionPolicy.SOURCE：注解只保留在源文件，当Java文件编译成class文件的时候，注解被遗弃；<br>2、RetentionPolicy.CLASS：注解被保留到class文件，但jvm加载class文件时候被遗弃，这是默认的生命周期；<br>3、RetentionPolicy.RUNTIME：注解不仅被保存到class文件中，jvm加载class文件之后，仍然存在；</strong><br><strong>首先要明确生命周期长度&nbsp;SOURCE &lt; CLASS &lt; RUNTIME ，所以前者能作用的地方后者一定也能作用。一般如果需要在运行时去动态获取注解信息，那只能用&nbsp;RUNTIME 注解；如果要在编译时进行一些预处理操作，比如生成一些辅助代码（如&nbsp;ButterKnife），就用&nbsp;CLASS注解；如果只是做一些检查性的操作，比如&nbsp;@Override 和&nbsp;@SuppressWarnings，则可选用&nbsp;SOURCE 注解。</strong></p><table><thead><tr><th>注解</th><th>父类</th><th>作用</th></tr></thead><tbody><tr><td>SpringBootConfiguration</td><td>Configuration</td><td>标注当前类是Java config配置类，会被扫描并加载到ioc容器</td></tr><tr><td>ComponentScan</td><td></td><td>扫描默认包或指定包下面符合条件的组件并加载</td></tr><tr><td>EnableAutoConfiguration</td><td></td><td>从classpath中搜寻所有的META-INF/spring.factories配置文件，并将其中org.springframework.boot.autoconfig.EnableAutoConfiguration对应的配置项通过反射实例化为对应的标注了@Configuration的java config形式的ioc容器配置类，汇总并加载到ioc容器</td></tr><tr><td></td><td>@AutoConfigurationPackages</td><td>注册当前主程序类的同级以及子级的包中的符合条件的Bean的定义</td></tr><tr><td></td><td>@Import(AutoConfigurationImportSelector.class)</td><td>扫描各个组件jar META-INIF目录下的spring.dactories文件，将下面的包名.类名中的工厂类全部加载到IOC容器中；将所有符合条件的bean的定义加载到ioc容器中</td></tr></tbody></table><h3 id="springboot启动">springboot启动</h3><p><strong>执行主函数main方法</strong><br><img src="http://dingdm.online/main.png" alt="main函数" title="main函数"><br><strong>创建SpringApplication对象对象，并运行SpringApplication对象的run方法</strong><br><img src="http://dingdm.online/chuangjianduixiang.png" alt="创建对象" title="创建对象"><br><strong>加载接口</strong><br><img src="http://dingdm.online/jiazaijiekou.png" alt="加载接口" title="加载接口"></p><pre class=" language-language-java"><code class="language-language-java">        this.primarySources = new LinkedHashSet(Arrays.asList(primarySources));        this.webApplicationType = this.deduceWebApplicationType();       // 扫描当前路径下META-INF/spring.factories文件的，加载ApplicationContextInitializer接口实例    this.setInitializers(this.getSpringFactoriesInstances(ApplicationContextInitializer.class));// 扫描当前路径下META-INF/spring.factories文件的，加载ApplicationListener接口实例        this.setListeners(this.getSpringFactoriesInstances(ApplicationListener.class));        this.mainApplicationClass = this.deduceMainApplicationClass();</code></pre><p><strong>ApplicationContextInitializer 这个类当springboot上下文Context初始化完成后会调用<br>ApplicationListener 当springboot启动时事件change后都会触发</strong><br><strong>这两个接口均可自己进行定义</strong><br><strong>实现接口后自己配置自己的实现类</strong></p><pre class=" language-language-java"><code class="language-language-java">org.springframework.context.ApplicationContextInitializer=\org.admin.starter.test.listener.StarterApplicationContextInitializerorg.springframework.context.ApplicationListener=\org.admin.starter.test.listener.StarterApplicationListener</code></pre><p><strong>实现run方法</strong><br><img src="http://dingdm.online/run.png" alt="run方法" title="run方法"></p><pre class=" language-language-java"><code class="language-language-java">public ConfigurableApplicationContext run(String... args) {        // 计时器StopWatch stopWatch = new StopWatch();stopWatch.start();ConfigurableApplicationContext context = null;Collection<springbootexceptionreporter> exceptionReporters = new ArrayList&lt;&gt;();        // 设置环境变量        configureHeadlessProperty();        // 获取事件监听器SpringApplicationRunListener类型，并且执行starting()方法SpringApplicationRunListeners listeners = getRunListeners(args);listeners.starting();try {            // 参数args封装成DefaultApplicationArgumentsApplicationArguments applicationArguments = new DefaultApplicationArguments(args);            // 把环境跟spring上下文绑定好，并且执行environmentPrepared()方法ConfigurableEnvironment environment = prepareEnvironment(listeners,applicationArguments);            // 判断一些环境的值，设置一些环境的值configureIgnoreBeanInfo(environment);            // 打印bannerBanner printedBanner = printBanner(environment);            // 根据项目类型创建上下文context = createApplicationContext();            // 获取异常报告事件监听exceptionReporters = getSpringFactoriesInstances(SpringBootExceptionReporter.class,new Class[] { ConfigurableApplicationContext.class }, context);            // 准备上下文，执行完成后调用contextPrepared()方法,contextLoaded()方法prepareContext(context, environment, listeners, applicationArguments,printedBanner);            // spring启动的代码，这里就回去里面就回去扫描并且初始化单实列bean了            // 这个refreshContext()加载了bean，启动了内置web容器refreshContext(context);afterRefresh(context, applicationArguments);stopWatch.stop();if (this.logStartupInfo) {new StartupInfoLogger(this.mainApplicationClass).logStarted(getApplicationLog(), stopWatch);}           // 执行ApplicationRunListeners中的started()方法listeners.started(context);            <!--执行Runner（ApplicationRunner和CommandLineRunner）-->callRunners(context, applicationArguments);}catch (Throwable ex) {handleRunFailure(context, listeners, exceptionReporters, ex);throw new IllegalStateException(ex);}listeners.running(context);return context;}</springbootexceptionreporter></code></pre><p><strong>根据项目类型创建上下文，并且注入几个核心组件类。</strong><br><img src="http://dingdm.online/chuangjianshangxiawen.png" alt="创建上下文" title="创建上下文"><br><strong>refreshContext(context)方法启动spring的代码加载了bean，还启动了内置web容器</strong><br><img src="http://dingdm.online/jiazaibean.png" alt="加载bean" title="加载bean"></p><pre class=" language-language-java"><code class="language-language-java">public void refresh() throws BeansException, IllegalStateException {        synchronized(this.startupShutdownMonitor) {            this.prepareRefresh();            ConfigurableListableBeanFactory beanFactory = this.obtainFreshBeanFactory();            this.prepareBeanFactory(beanFactory);            try {                this.postProcessBeanFactory(beanFactory);                this.invokeBeanFactoryPostProcessors(beanFactory);                this.registerBeanPostProcessors(beanFactory);                this.initMessageSource();                this.initApplicationEventMulticaster();                this.onRefresh();                this.registerListeners();                this.finishBeanFactoryInitialization(beanFactory);                this.finishRefresh();            } catch (BeansException var9) {                if (this.logger.isWarnEnabled()) {                    this.logger.warn("Exception encountered during context initialization - cancelling refresh attempt: " + var9);                }                this.destroyBeans();                this.cancelRefresh(var9);                throw var9;            } finally {                this.resetCommonCaches();            }        }    }</code></pre><p><strong>onRefresh钩子方法</strong><br><img src="http://dingdm.online/gouzi.png" alt=""><br>钩子方法，它会钩到它子类重写onRefresh()方法。所以去看子类里面的onRefresh()<br><img src="http://dingdm.online/zileishixian.png" alt="子类实现" title="子类实现"><br><strong>内置容器</strong><br><img src="http://dingdm.online/neizhirongqi.png" alt="内置容器" title="内置容器"><br><img src="http://dingdm.online/neizhirongqi2.png" alt="内置容器" title="内置容器"><br><strong>容器选择</strong><br><img src="http://dingdm.online/rongqixuanze.png" alt="容器选择" title="容器选择"><br><strong>tomcat容器</strong><img src="http://dingdm.online/tomcat.png" alt="tomcat" title="tomcat"></p><h3 id="springboot的自动化配置">springboot的自动化配置</h3><p><img src="http://dingdm.online/zidonghua.png" alt="自动化配置" title="自动化配置"><br><strong>该配置模块的主要使用到了SpringFactoriesLoader，即Spring工厂加载器，该对象提供了loadFactoryNames方法，入参为factoryClass和classLoader，即需要传入上图中的工厂类名称和对应的类加载器，方法会根据指定的classLoader，加载该类加器搜索路径下的指定文件，即spring.factories文件，传入的工厂类为接口，而文件中对应的类则是接口的实现类，或最终作为实现类，所以文件中一般为如下图这种一对多的类名集合，获取到这些实现类的类名后，loadFactoryNames方法返回类名集合，方法调用方得到这些集合后，再通过反射获取这些类的类对象、构造方法，最终生成实例。</strong><br><img src="http://dingdm.online/jiekoupeizhi.png" alt="接口配置" title="接口配置"><br><strong>EnableAutoConfiguration最终实现了ImportSelector(选择器)和BeanClassLoaderAware(bean类加载器中间件)，重点关注一下AutoConfigurationImportSelector的selectImports方法</strong><br><img src="http://dingdm.online/leixinxiliebiao.png" alt="类信息列表" title="类信息列表"><br><strong>该方法在springboot启动流程——bean实例化前被执行，返回要实例化的类信息列表。我们知道，如果获取到类信息，spring自然可以通过类加载器将类加载到jvm中，现在我们已经通过spring-boot的starter依赖方式依赖了我们需要的组件，那么这些组建的类信息在select方法中也是可以被获取到的</strong><br><strong>方法中的getCandidateConfigurations方法，通过方法注释了解到，其返回一个自动配置类的类名列表，方法调用了loadFactoryNames方法</strong></p><pre class=" language-language-java"><code class="language-language-java">    protected List<string> getCandidateConfigurations(AnnotationMetadata metadata, AnnotationAttributes attributes) {        List<string> configurations = SpringFactoriesLoader.loadFactoryNames(this.getSpringFactoriesLoaderFactoryClass(), this.getBeanClassLoader());        Assert.notEmpty(configurations, "No auto configuration classes found in META-INF/spring.factories. If you are using a custom packaging, make sure that file is correct.");        return configurations;    }</string></string></code></pre><p><strong>自动配置器会根据传入的factoryClass.getName()到项目系统路径下所有的spring.factories文件中找到相应的key，从而加载里面的类</strong><br><img src="http://dingdm.online/jiazailei.png" alt="加载类" title="加载类"></p><pre class=" language-language-java"><code class="language-language-java">private static Map<string, list<string="">&gt; loadSpringFactories(@Nullable ClassLoader classLoader) {        MultiValueMap<string, string=""> result = (MultiValueMap)cache.get(classLoader);        if (result != null) {            return result;        } else {            try {                Enumeration<url> urls = classLoader != null ? classLoader.getResources("META-INF/spring.factories") : ClassLoader.getSystemResources("META-INF/spring.factories");                LinkedMultiValueMap result = new LinkedMultiValueMap();                while(urls.hasMoreElements()) {                    URL url = (URL)urls.nextElement();                    UrlResource resource = new UrlResource(url);                    Properties properties = PropertiesLoaderUtils.loadProperties(resource);                    Iterator var6 = properties.entrySet().iterator();                    while(var6.hasNext()) {                        Entry<!--?, ?--> entry = (Entry)var6.next();                        List<string> factoryClassNames = Arrays.asList(StringUtils.commaDelimitedListToStringArray((String)entry.getValue()));                        result.addAll((String)entry.getKey(), factoryClassNames);                    }                }                cache.put(classLoader, result);                return result;            } catch (IOException var9) {                throw new IllegalArgumentException("Unable to load factories from location [META-INF/spring.factories]", var9);            }        }    }</string></url></string,></string,></code></pre><p><strong>自动配置</strong><br><img src="http://dingdm.online/zidongpeizhi2.png" alt="自动配置" title="自动配置"></p><pre class=" language-language-java"><code class="language-language-java">@Configuration@ConditionalOnClass({EnableAspectJAutoProxy.class, Aspect.class, Advice.class, AnnotatedElement.class})@ConditionalOnProperty(    prefix = "spring.aop",    name = {"auto"},    havingValue = "true",    matchIfMissing = true)public class AopAutoConfiguration {    public AopAutoConfiguration() {    }    @Configuration    @EnableAspectJAutoProxy(        proxyTargetClass = true    )    @ConditionalOnProperty(        prefix = "spring.aop",        name = {"proxy-target-class"},        havingValue = "true",        matchIfMissing = true    )    public static class CglibAutoProxyConfiguration {        public CglibAutoProxyConfiguration() {        }    }    @Configuration    @EnableAspectJAutoProxy(        proxyTargetClass = false    )    @ConditionalOnProperty(        prefix = "spring.aop",        name = {"proxy-target-class"},        havingValue = "false",        matchIfMissing = false    )    public static class JdkDynamicAutoProxyConfiguration {        public JdkDynamicAutoProxyConfiguration() {        }    }}</code></pre><p><strong>@Configuration，是一个通过注解标注的springBean</strong><br><strong>@ConditionalOnClass({EnableAspectJAutoProxy.class, Aspect.class, Advice.class, AnnotatedElement.class})这个注解的意思是：EnableAspectJAutoProxy.class, Aspect.class，Advice.class，AnnotatedElement.class这几个类时才解析AopAutoConfiguration配置类，否则不解析这一个配置类</strong><br><strong>因为maven依赖的传递性，我们只要依赖starter就可以依赖到所有需要自动配置的类，实现开箱即用的功能。也体现出Springboot简化了Spring框架带来的大量XML配置以及复杂的依赖管理，让开发人员可以更加关注业务逻辑的开发。</strong></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot </tag>
            
            <tag> tomcat </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络</title>
      <link href="/2020/05/08/ji-suan-ji-wang-luo/"/>
      <url>/2020/05/08/ji-suan-ji-wang-luo/</url>
      
        <content type="html"><![CDATA[<h3 id="应用进程跨越网络的通信">应用进程跨越网络的通信</h3><p><strong>解决的问题</strong>：一些特定的应用需要互联网但是不能使用标准化的互联网应用协议<br>系统调用：<br>流程：应用进程启动系统调用，控制进程传递给了系统调用接口，接口将控制权交给操作系统。即应用进程的控制权和操作系统的权限转换的接口。<br>应用进程只要使用标准的系统调用函数就可得到操作系统的服务。所以系统调用接口又称为应用编程接口。<br>其中TCP/IP协议软件驻留在操作系统中。<br>在编写java代码时有一些公用的API：<br>通过传入简单的字符串，java通过API来进行切割字符串</p><pre class=" language-language-java"><code class="language-language-java">/**  * String 类得split方法解析。  * 实际是调用Pattern类得split方法  */  public class AboutSplit {      public String[] split(String regex, int limit) {          return Pattern.compile(regex).split("本String字符串", limit);      }      /**      * 关于limit：limit决定数组的长度      * 当limit为0时数组长度不受限制,并且将剔除尾部空串      * 当limit为负时数组长度不受限制      * 当limit长度大于0，数组长度将&lt;=limit，而且数组的最后一个元素将包含匹配符后面的所有字符      */      public String[] split(CharSequence input, int limit) {          int index = 0;          boolean matchLimited = limit &gt; 0;          ArrayList<string> matchList = new ArrayList<string>();          Matcher m = Pattern.matcher(input); //此pattern为Pattern.compile(regex)返回的Pattern对象            // Add segments before each match found          while(m.find()) {              if (!matchLimited || matchList.size() &lt; limit - 1) { //默认limit为0                  String match = input.subSequence(index, m.start()).toString();  //比如a:b:c，返回a。m.start()返回第一个匹配字符的索引即1                  matchList.add(match);   //存入List                  index = m.end();    //返回最后一个匹配字符的后一个字符的索引，这里是2              } else if (matchList.size() == limit - 1) { // 最后一个元素                  String match = input.subSequence(index,                                                   input.length()).toString();                  matchList.add(match);                  index = m.end();              }          }            // 没有找到匹配串          if (index == 0)              return new String[] {input.toString()};            // 把最后一部分的片段添加进来          if (!matchLimited || matchList.size() &lt; limit)              matchList.add(input.subSequence(index, input.length()).toString());            // Construct result          int resultSize = matchList.size();          if (limit == 0) //如果limit为0              while (resultSize &gt; 0 &amp;&amp; matchList.get(resultSize-1).equals(""))                  resultSize--;   //剔除尾部空串          String[] result = new String[resultSize];          return matchList.subList(0, resultSize).toArray(result);      }  }  </string></string></code></pre><p>目前的应用编程接口API：套接字接口(插口接口)<br>这里需要注意一点，websocket在连接的时候有一个握手阶段，但是这和TCP的三次握手又是不一样的。TCP的三次握手是为了保证连接可靠，当TCP三次握手成功的时候，websocket的握手阶段才真正开始。TCP三次握手传送的是TCP报文，而websocket的握手传送的是HTTP报文，这个是不太一样的地方。</p><p>握手开始的时候，我们需要现发送一个HTTP 1.1的请求头部：</p><pre class=" language-language-shell"><code class="language-language-shell">GET /chat HTTP/1.1Host: server.example.comUpgrade: websocketConnection: UpgradeSec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==Origin: http://example.comSec-WebSocket-Protocol: chat, superchatSec-WebSocket-Version: 13</code></pre><p>服务端返回的成功握手请求头部如下：</p><pre class=" language-language-java"><code class="language-language-java">HTTP/1.1 101 Switching ProtocolsUpgrade: websocketConnection: UpgradeSec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=Sec-WebSocket-Protocol: chat</code></pre><p>Upgrade:WebSocket表示这是一个特殊的 HTTP 请求，请求的目的就是要将客户端和服务器端的通讯协议从 HTTP 协议升级到 WebSocket 协议。</p><h3 id="常用的系统调用">常用的系统调用</h3><p>TCP服务：<br><img src="http://dingdm.online/f0afb365fe254a1485a3460b13776aef.png" alt=""></p><h3 id="鉴别">鉴别</h3><p><strong>概念</strong>：验证通信的对方的确是自己要通信的对象，所传送的报文是完整的。</p><h4 id="报文鉴别">报文鉴别</h4><p>密码散列函数(Hash函数)<br>特点：输入长度可以很长，但其输出长度是固定的，并且较短。<br>不同的散列值肯定对应不同的输入，不同的输入却可能得到相同的散列值。<br>一个优良的Hash函数必须满足如下几个性质:</p><ul><li>任意y，找x，使得H(x) = y，非常困难</li><li>给定x1, 找x2, 使得H(x1) == H(x2), 非常困难</li><li>找任意的x1, x2, 使得H(x1) == H(x2), 非常困难 生日定理</li></ul><p><strong>常用的Hash算法</strong><br>MD5<br>SHA1<br>SHA224<br>SHA256<br>SHA384<br>SHA512<br>SM3</p><pre class=" language-language-java"><code class="language-language-java">#!/usr/bin/python#coding:utf8import hashlibdef b2s(bytes):    rets = []    for c in bytes:        rets.append("%02X" % (ord(c)))    r = ' '.join(rets)    return rdef md5(data):    hashobj = hashlib.md5()    hashobj.update(data)    return hashobj.digest()def sha1(data):    hashobj = hashlib.sha1()    hashobj.update(data)    return hashobj.digest()def sha224(data):    hashobj = hashlib.sha224()    hashobj.update(data)    return hashobj.digest()def sha256(data):    hashobj = hashlib.sha256()    hashobj.update(data)    return hashobj.digest()def sha384(data):    hashobj = hashlib.sha384()    hashobj.update(data)    return hashobj.digest()def sha512(data):    hashobj = hashlib.sha512()    hashobj.update(data)    return hashobj.digest()def main():    hash_fun_list = (md5, sha1, sha224, sha256, sha384, sha512)    data = '\x12\x34'    for fun in hash_fun_list:        print fun        r = fun(data)        print b2s(r)if __name__ == '__main__':    main()</code></pre><h4 id="MD5">MD5</h4><p>算法过程：<br>先将报文按模2^64计算余数，追加在报文后面<br>报文和余数之填充1~512位，填充的首位时1，后面都是0<br>报文分割为一个个512位的数据块，每个512位的报文数据再分成4个128位的数据块依次送到不同的散列函数进行4轮计算，每一轮又按32位的小数据块进行运算</p><pre class=" language-language-java"><code class="language-language-java">public class MD5 {    static final String hexs[]={"0","1","2","3","4","5","6","7","8","9","A","B","C","D","E","F"};    //标准的幻数    private static final long A=0x67452301L;    private static final long B=0xefcdab89L;    private static final long C=0x98badcfeL;    private static final long D=0x10325476L;    //下面这些S11-S44实际上是一个4*4的矩阵，在四轮循环运算中用到    static final int S11 = 7;    static final int S12 = 12;    static final int S13 = 17;    static final int S14 = 22;    static final int S21 = 5;    static final int S22 = 9;    static final int S23 = 14;    static final int S24 = 20;    static final int S31 = 4;    static final int S32 = 11;    static final int S33 = 16;    static final int S34 = 23;    static final int S41 = 6;    static final int S42 = 10;    static final int S43 = 15;    static final int S44 = 21;    //java不支持无符号的基本数据（unsigned）    private long [] result={A,B,C,D};//存储hash结果，共4×32=128位，初始化值为（幻数的级联）    public static void main(String []args){        MD5 md=new MD5();        System.out.println("md5(abc)="+md.digest("abc"));    }    private String digest(String inputStr){        byte [] inputBytes=inputStr.getBytes();        int byteLen=inputBytes.length;//长度（字节）        int groupCount=0;//完整分组的个数        groupCount=byteLen/64;//每组512位（64字节）        long []groups=null;//每个小组(64字节)再细分后的16个小组(4字节)        //处理每一个完整 分组        for(int step=0;step<groupcount;step++){ groups="divGroup(inputBytes,step*64);" trans(groups);="" 处理分组，核心算法="" }="" 处理完整分组后的尾巴="" int="" rest="byteLen%64;//512位分组后的余数" byte="" []="" tempbytes="new" byte[64];="" if(rest<="56){" for(int="" i="0;i<rest;i++)" tempbytes[i]="inputBytes[byteLen-rest+i];" if(rest<56){="" tempbytes[rest]="(byte)(1<<7);" tempbytes[rest+i]="0;" long="" len="(long)(byteLen<<3);" tempbytes[56+i]="(byte)(len&amp;0xFFL);">&gt;8;            }            groups=divGroup(tempBytes,0);            trans(groups);//处理分组        }else{            for(int i=0;i<rest;i++) tempbytes[i]="inputBytes[byteLen-rest+i];" tempbytes[rest]="(byte)(1<<7);" for(int="" i="rest+1;i<64;i++)" groups="divGroup(tempBytes,0);" trans(groups);="" 处理分组="" long="" len="(long)(byteLen<<3);" tempbytes[56+i]="(byte)(len&amp;0xFFL);">&gt;8;            }            groups=divGroup(tempBytes,0);            trans(groups);//处理分组        }        //将Hash值转换成十六进制的字符串        String resStr="";        long temp=0;        for(int i=0;i&lt;4;i++){            for(int j=0;j&lt;4;j++){                temp=result[i]&amp;0x0FL;                String a=hexs[(int)(temp)];                result[i]=result[i]&gt;&gt;4;                temp=result[i]&amp;0x0FL;                resStr+=hexs[(int)(temp)]+a;                result[i]=result[i]&gt;&gt;4;            }        }        return resStr;    }    /**     * 从inputBytes的index开始取512位，作为新的分组     * 将每一个512位的分组再细分成16个小组，每个小组64位（8个字节）     * @param inputBytes     * @param index     * @return     */    private static long[] divGroup(byte[] inputBytes,int index){        long [] temp=new long[16];        for(int i=0;i&lt;16;i++){            temp[i]=b2iu(inputBytes[4*i+index])|                (b2iu(inputBytes[4*i+1+index]))&lt;&lt;8|                (b2iu(inputBytes[4*i+2+index]))&lt;&lt;16|                (b2iu(inputBytes[4*i+3+index]))&lt;&lt;24;        }        return temp;    }    /**     * 这时不存在符号位（符号位存储不再是代表正负），所以需要处理一下     * @param b     * @return     */    public static long b2iu(byte b){        return b &lt; 0 ? b &amp; 0x7F + 128 : b;     }    /**     * 主要的操作，四轮循环     * @param groups[]--每一个分组512位（64字节）     */    private void trans(long[] groups) {        long a = result[0], b = result[1], c = result[2], d = result[3];        /*第一轮*/        a = FF(a, b, c, d, groups[0], S11, 0xd76aa478L); /* 1 */        d = FF(d, a, b, c, groups[1], S12, 0xe8c7b756L); /* 2 */        c = FF(c, d, a, b, groups[2], S13, 0x242070dbL); /* 3 */        b = FF(b, c, d, a, groups[3], S14, 0xc1bdceeeL); /* 4 */        a = FF(a, b, c, d, groups[4], S11, 0xf57c0fafL); /* 5 */        d = FF(d, a, b, c, groups[5], S12, 0x4787c62aL); /* 6 */        c = FF(c, d, a, b, groups[6], S13, 0xa8304613L); /* 7 */        b = FF(b, c, d, a, groups[7], S14, 0xfd469501L); /* 8 */        a = FF(a, b, c, d, groups[8], S11, 0x698098d8L); /* 9 */        d = FF(d, a, b, c, groups[9], S12, 0x8b44f7afL); /* 10 */        c = FF(c, d, a, b, groups[10], S13, 0xffff5bb1L); /* 11 */        b = FF(b, c, d, a, groups[11], S14, 0x895cd7beL); /* 12 */        a = FF(a, b, c, d, groups[12], S11, 0x6b901122L); /* 13 */        d = FF(d, a, b, c, groups[13], S12, 0xfd987193L); /* 14 */        c = FF(c, d, a, b, groups[14], S13, 0xa679438eL); /* 15 */        b = FF(b, c, d, a, groups[15], S14, 0x49b40821L); /* 16 */        /*第二轮*/        a = GG(a, b, c, d, groups[1], S21, 0xf61e2562L); /* 17 */        d = GG(d, a, b, c, groups[6], S22, 0xc040b340L); /* 18 */        c = GG(c, d, a, b, groups[11], S23, 0x265e5a51L); /* 19 */        b = GG(b, c, d, a, groups[0], S24, 0xe9b6c7aaL); /* 20 */        a = GG(a, b, c, d, groups[5], S21, 0xd62f105dL); /* 21 */        d = GG(d, a, b, c, groups[10], S22, 0x2441453L); /* 22 */        c = GG(c, d, a, b, groups[15], S23, 0xd8a1e681L); /* 23 */        b = GG(b, c, d, a, groups[4], S24, 0xe7d3fbc8L); /* 24 */        a = GG(a, b, c, d, groups[9], S21, 0x21e1cde6L); /* 25 */        d = GG(d, a, b, c, groups[14], S22, 0xc33707d6L); /* 26 */        c = GG(c, d, a, b, groups[3], S23, 0xf4d50d87L); /* 27 */        b = GG(b, c, d, a, groups[8], S24, 0x455a14edL); /* 28 */        a = GG(a, b, c, d, groups[13], S21, 0xa9e3e905L); /* 29 */        d = GG(d, a, b, c, groups[2], S22, 0xfcefa3f8L); /* 30 */        c = GG(c, d, a, b, groups[7], S23, 0x676f02d9L); /* 31 */        b = GG(b, c, d, a, groups[12], S24, 0x8d2a4c8aL); /* 32 */        /*第三轮*/        a = HH(a, b, c, d, groups[5], S31, 0xfffa3942L); /* 33 */        d = HH(d, a, b, c, groups[8], S32, 0x8771f681L); /* 34 */        c = HH(c, d, a, b, groups[11], S33, 0x6d9d6122L); /* 35 */        b = HH(b, c, d, a, groups[14], S34, 0xfde5380cL); /* 36 */        a = HH(a, b, c, d, groups[1], S31, 0xa4beea44L); /* 37 */        d = HH(d, a, b, c, groups[4], S32, 0x4bdecfa9L); /* 38 */        c = HH(c, d, a, b, groups[7], S33, 0xf6bb4b60L); /* 39 */        b = HH(b, c, d, a, groups[10], S34, 0xbebfbc70L); /* 40 */        a = HH(a, b, c, d, groups[13], S31, 0x289b7ec6L); /* 41 */        d = HH(d, a, b, c, groups[0], S32, 0xeaa127faL); /* 42 */        c = HH(c, d, a, b, groups[3], S33, 0xd4ef3085L); /* 43 */        b = HH(b, c, d, a, groups[6], S34, 0x4881d05L); /* 44 */        a = HH(a, b, c, d, groups[9], S31, 0xd9d4d039L); /* 45 */        d = HH(d, a, b, c, groups[12], S32, 0xe6db99e5L); /* 46 */        c = HH(c, d, a, b, groups[15], S33, 0x1fa27cf8L); /* 47 */        b = HH(b, c, d, a, groups[2], S34, 0xc4ac5665L); /* 48 */        /*第四轮*/        a = II(a, b, c, d, groups[0], S41, 0xf4292244L); /* 49 */        d = II(d, a, b, c, groups[7], S42, 0x432aff97L); /* 50 */        c = II(c, d, a, b, groups[14], S43, 0xab9423a7L); /* 51 */        b = II(b, c, d, a, groups[5], S44, 0xfc93a039L); /* 52 */        a = II(a, b, c, d, groups[12], S41, 0x655b59c3L); /* 53 */        d = II(d, a, b, c, groups[3], S42, 0x8f0ccc92L); /* 54 */        c = II(c, d, a, b, groups[10], S43, 0xffeff47dL); /* 55 */        b = II(b, c, d, a, groups[1], S44, 0x85845dd1L); /* 56 */        a = II(a, b, c, d, groups[8], S41, 0x6fa87e4fL); /* 57 */        d = II(d, a, b, c, groups[15], S42, 0xfe2ce6e0L); /* 58 */        c = II(c, d, a, b, groups[6], S43, 0xa3014314L); /* 59 */        b = II(b, c, d, a, groups[13], S44, 0x4e0811a1L); /* 60 */        a = II(a, b, c, d, groups[4], S41, 0xf7537e82L); /* 61 */        d = II(d, a, b, c, groups[11], S42, 0xbd3af235L); /* 62 */        c = II(c, d, a, b, groups[2], S43, 0x2ad7d2bbL); /* 63 */        b = II(b, c, d, a, groups[9], S44, 0xeb86d391L); /* 64 */        /*加入到之前计算的结果当中*/        result[0] += a;        result[1] += b;        result[2] += c;        result[3] += d;        result[0]=result[0]&amp;0xFFFFFFFFL;        result[1]=result[1]&amp;0xFFFFFFFFL;        result[2]=result[2]&amp;0xFFFFFFFFL;        result[3]=result[3]&amp;0xFFFFFFFFL;    }    /**     * 下面是处理要用到的线性函数     */    private static long F(long x, long y, long z) {        return (x &amp; y) | ((~x) &amp; z);    }    private static long G(long x, long y, long z) {        return (x &amp; z) | (y &amp; (~z));    }    private static long H(long x, long y, long z) {        return x ^ y ^ z;    }    private static long I(long x, long y, long z) {        return y ^ (x | (~z));    }    private static long FF(long a, long b, long c, long d, long x, long s,            long ac) {        a += (F(b, c, d)&amp;0xFFFFFFFFL) + x + ac;        a = ((a&amp;0xFFFFFFFFL)&lt;&lt; s) | ((a&amp;0xFFFFFFFFL) &gt;&gt;&gt; (32 - s));        a += b;        return (a&amp;0xFFFFFFFFL);    }    private static long GG(long a, long b, long c, long d, long x, long s,            long ac) {        a += (G(b, c, d)&amp;0xFFFFFFFFL) + x + ac;        a = ((a&amp;0xFFFFFFFFL) &lt;&lt; s) | ((a&amp;0xFFFFFFFFL) &gt;&gt;&gt; (32 - s));        a += b;        return (a&amp;0xFFFFFFFFL);    }    private static long HH(long a, long b, long c, long d, long x, long s,            long ac) {        a += (H(b, c, d)&amp;0xFFFFFFFFL) + x + ac;        a = ((a&amp;0xFFFFFFFFL) &lt;&lt; s) | ((a&amp;0xFFFFFFFFL) &gt;&gt;&gt; (32 - s));        a += b;        return (a&amp;0xFFFFFFFFL);    }    private static long II(long a, long b, long c, long d, long x, long s,            long ac) {        a += (I(b, c, d)&amp;0xFFFFFFFFL) + x + ac;        a = ((a&amp;0xFFFFFFFFL) &lt;&lt; s) | ((a&amp;0xFFFFFFFFL) &gt;&gt;&gt; (32 - s));        a += b;        return (a&amp;0xFFFFFFFFL);    }}</rest;i++)></groupcount;step++){></code></pre><h4 id="报文鉴别使用散列函数">报文鉴别使用散列函数</h4><hr><ul><li>用户A首先根据自己的明文X计算出散列H(X)，</li><li>用户A把散列H拼接在明文X的后面，生成了扩展的报文(X,H)，然后发送给B</li><li>用户B收到了这个扩展的报文(X,H)，因为散列的长度H是已知道的固定值，因此可以把收到的散列H和明文X分离开。B通过散列函数的计算，计算出明文X的散列H(X)。</li></ul><p>散列加密防止伪造报文<br><img src="http://dingdm.online/5181df2368ec4c359bc18a6737b3212f.png" alt=""></p><h3 id="密钥分配">密钥分配</h3><p>密钥管理：密码的产生、分配、注入、验证和使用</p><h4 id="对称密钥的分配">对称密钥的分配</h4><p>目前密钥分发的方式：<br>　　1、A选择一个密钥后以物理的方式传递给B<br>　　2、第三方选择密钥后物理地传给A和B<br>　　3、如果A和B先前或最近使用过一个密钥，则一方可以将 新密钥用旧密钥发送给另一方<br>　　4、如果A和B到第三方C有加密连接，则C可以在加密连接上发送密钥给A、B<br>分析：<br>1和2都需要人工交付，对链路加密（设备一对一连接）可行，对网络通信则不可行，因为网络通信涉及大量密钥<br>对于3，一旦攻击者获得一个密钥，则后序所有密钥便都不再安全。<br>4需要第三方即密钥分发中心，在网络通信中得到了广泛的应用<br>举例：</p><ol><li>你带好身份证和相应的材料去派出所，向JCSS说明你要办居住证，需要开据相应的证明。</li><li>JCSS根据他们的内部系统，核实了你提供的材料并开据了证明，上面盖有派出所的红章。</li><li>你再拿着这个证明再去社区事务中心，社区事务中心的工作人员看到了JCSS提供的证明，就可以确定你的身份，便开始给你办理业务。<br>图解：<br><img src="http://dingdm.online/QQ%E6%88%AA%E5%9B%BE20200805112435.png" alt=""></li></ol><ul><li>A携带A、B的身份以及唯一标识通过明文的方式向KDC发送请求</li><li>KDC通过通话密钥和收到的请求判断消息到达之前是否被篡改，然后把响应的信息用A的密钥加密返回给Ａ</li><li>KDC通过通话密钥和Ａ的身份，将Ｂ的信息用B的密钥加密然后送给Ａ</li><li>A、B进行通话验证，Ｂ使用会话密钥和唯一标识发送给Ａ，Ａ对标识进行函数变换发送给Ｂ验证</li><li>Ａ发送信息给B</li></ul><h4 id="公钥的分配">公钥的分配</h4><p><img src="http://dingdm.online/0dec14b8796f425091844c2b97ae1400.png" alt=""></p><ul><li>Ａ向管理员发送请求，申请Ｂ的公钥</li><li>管理员通过自己的加密方式将请求响应给Ａ，Ａ通过管理员加密的方式解密来获得消息</li><li>Ａ通过Ｂ的公钥和自身的标识以及随机数加密消息发送给Ｂ<br>缺点：管理员的缺陷</li></ul><h3 id="安全协议">安全协议</h3><h4 id="SSH">SSH</h4><p><strong>概念</strong><br>传统的网络服务程序，如：ftp、pop和telnet在本质上都是不安全的，因为它们在网络上用明文传送口令和数据， 别有用心的人非常容易就可以截获这些口令和数据。而且，这些服务程序的安全验证方式也是有其弱点的， 就是很容易受到“中间人”（man-in-the-middle）这种方式的攻击。所谓“中间人”的攻击方式， 就是“中间人”冒充真正的服务器接收你的传给服务器的数据，然后再冒充你把数据传给真正的服务器。 服务器和你之间的数据传送被“中间人”一转手做了手脚之后，就会出现很严重的问题。<br><strong>两种级别的安全验证</strong><br>第一种级别（基于口令的安全验证）只要你知道自己帐号和口令，就可以登录到远程主机。所有传输的数据都会被加密， 但是不能保证你正在连接的服务器就是你想连接的服务器。可能会有别的服务器在冒充真正的服务器， 也就是受到“中间人”这种方式的攻击。<br>第二种级别（基于密匙的安全验证）需要依靠密匙，也就是你必须为自己创建一对密匙，并把公用密匙放在需要访问的服务器上。 如果你要连接到SSH服务器上，客户端软件就会向服务器发出请求，请求用你的密匙进行安全验证。服务器收到请求之后， 先在你在该服务器的家目录下寻找你的公用密匙，然后把它和你发送过来的公用密匙进行比较。如果两个密匙一致， 服务器就用公用密匙加密“质询”（challenge）并把它发送给客户端软件。 客户端软件收到“质询”之后就可以用你的私人密匙解密再把它发送给服务器。</p><h4 id="SSL">SSL</h4><p>举例：<br>当顾客想从 Web 站点购买某个产品时，顾客和 Web 站点都要进行认证。顾客通常是以提供名字和密码的方式来认证他自己。 另一方面，Web 站点通过交换一块签名数据和一个有效的 X.509 证书（作为 SSL 握手的一部分）来认证它自己。 顾客的浏览器验证该证书并用所附的公用密钥验证签名数据。一旦双方都认证了，则交易就可以开始了。<br>安全套接字层（Secure Sockets Layer（SSL）） ，SSL 是一种安全协议，它为网络（例如因特网）的通信提供私密性。SSL 使应用程序在通信时不用担心被窃听和篡改。 SSL 实际上是共同工作的两个协议：“SSL 记录协议”（SSL Record Protocol）和“SSL 握手协议” （SSL Handshake Protocol）。“SSL 记录协议”是两个协议中较低级别的协议，它为较高级别的协议， 例如 SSL 握手协议对数据的变长的记录进行加密和解密。SSL 握手协议处理应用程序凭证的交换和验证。<br>名为 A 和 B 的两台对等机想安全地进行通信。在我们简单的 p2p 应用程序的环境中，对等机 A 想查询对等机 B 上的一个资源。 每个对等机都有包含其专用密钥的一个数据库（名为 keystore）和包含其公用密钥的证书。密码保护数据库的内容。 该数据库还包含一个或多个来自被信任的对等机的自签名证书。 对等机 A 发起这项事务，每台对等机相互认证，两台对等机协商采用的密码及其长度并建立一个安全通道。完成这些操作之后， 每个对等机都知道它正在跟谁交谈并且知道通道是安全的。 SSL (Secure socket Layer)安全套接层协议主要是使用公开密钥体制和X.509数字证书技术保护信息传输的机密性和完整性， 它不能保证信息的不可抵赖性，主要适用于点对点之间的信息传输，常用Web Server方式。</p><h4 id="PKI">PKI</h4><p>PKI体系结构采用证书管理公钥，通过第三方的可信机构CA， 把用户的公钥和用户的其他标识信息（如名称、e-mail、身份证号等）捆绑在一起，在Internet网上验证用户的身份， PKI体系结构把公钥密码和对称密码结合起来，在Internet网上实现密钥的自动管理，保证网上数据的机密性、完整性。</p><h4 id="SET">SET</h4><p>SET(Secure Electronic Transaction)安全电子交易协议是由美国Visa和MasterCard两大信用卡组织提出的应用于 Internet上的以信用卡为基础的电子支付系统协议。它采用公钥密码体制和X.509数字证书标准， 主要应用于B to C模式中保障支付信息的安全性。SET协议本身比较复杂，设计比较严格，安全性高， 它能保证信息传输的机密性、真实性、完整性和不可否认性。SET协议是PKI框架下的一个典型实现，同时也在不断升级和完善， 如SET 2.0将支持借记卡电子交易。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
          <category> 加密算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
            <tag> TCP </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
