<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>深度学习笔记一</title>
      <link href="/2021/04/15/shen-du-xue-xi-bi-ji-yi/"/>
      <url>/2021/04/15/shen-du-xue-xi-bi-ji-yi/</url>
      
        <content type="html"><![CDATA[<h3 id="深度学习笔记一">深度学习笔记一</h3><h4 id="名词">名词</h4><p>函数的Loss：深度学习的错误率<br>Regression：回归算法，找到一个函数 function，通过输入特征 x ，输出一个数值 Scalar 。与其他任务不同的是输出一个数值<br>Classification：分类，输入参数，通过某种模型计算后，输出所属类别<br>Meta Learning：让机器学会学习，第一个任务是语音识别，第二个任务是图像识别，第一百个任务是文本分类，机器会因为之前所学到得任务，所以在后面得任务学习得更好。<br>Unsupervised Learning：无监督学习，数据没有label，需要根据数据自身结构特性来将数据分类<br>Life-long Learning：终身学习，对多个任务使用一个模型进行学习，期望机器学完第一个任务后，再学习学第二个任务后，不会遗忘第一个任务，继续学习第三个任务后，不会忘记第一个和第二个任务。<br>Reinforcement Learning：强化学习，估计未来的收益，并根据这些收益对<strong>当前动作进行强化</strong>的算法设计思想是<strong>强化学习</strong><br>Domain Adversarial Learning：对抗训练，在对抗训练的过程中，样本会被混合一些微小的扰动（改变很小，但是很可能造成误分类），然后使神经网络适应这种改变，从而对对抗样本具有鲁棒性。<br>Network Compression：模型压缩<br>Anomaly Detection：<strong>异常检测</strong>，目的在于让机器知道我所不知道的事情<br>Explainable AI：可解释AI</p><h4 id="Regression">Regression</h4><p>Step1:Model<br>视频通过宝可梦的例子进行讲解，这里我通过新闻推荐的方式对相关内容进行理解。<br>函数，即通过线性模型构造函数。y = b + w*x(similar)；<br>这里的y为推荐新闻的推荐指数，而b可以为新闻分类的相似度下时间发表的前后或者新闻的阅读量等因素构成的推荐数值。而w为用户行为(点赞，评论，收藏，分享)分析的推荐数值。x(similar)则为被推荐新闻与用户阅读过新闻关键字的匹配值。<br>其中x中的各种属性，即关键字匹配度或者发表机构的匹配度等为输入特征。w为权重，x为偏差。</p><p>Step2:Goodness of Function<br>获取多个数据通过表格，折线等多种形式进行分析。<br>定义Loss function L：衡量参数的好坏<br>通过对应的估测误差的函数来计算所有已有样本根据不同function计算的Loss值。</p><p><img src="http://dingdm.online/ss.png" alt=""></p><p>Step3:Best Function<br>根据Loss值获取最好的function。<br>gradient descent：处理function找到最优值<br>1.穷举<br>2.Gradient Descent<br>单参<br>随机选取或者其他方法找到一个初始点w0；<br>计算w0位置的微分。为负的话应该增加w的值。为正的话应该减少w的值。<br>增量选取：根据微分的大小(陡峭程度)；常数项learning rate(事先定义好的值)。<br>重复之前的步骤。<br>经过t次的更新，找到local optimal微分为0的位置。局部最优解。<br>双参<br>和单参数相同，不过是计算双参数的微分。使用同一个常数项learning rate。<br>对于三维Loss Function函数的计算是根据选取点的，而对线性模型得到的是同一组参数。<br>根据原图像与得到的最优的function进行误差估测。<br>获取新的模型用于测试得到的最优函数，在进行误差估测。</p><p>Step4：新的模型误差较大或者某个局部预测不准<br>引入二次式进行再次预测或继续引入三次方再次预测。<br>由于现有模型的不足和分布不均，使用较高的次方进行预测的原数据模型对当前数据模型误差可能增大。产生overfitting。<br>高次方程的范围是低次方程的超集，在找出最优function的情况下，根据最优function在找到最优的误差。</p><p>Step5：根据较大的数据模型和分布重新设计function<br>显然根据不同的新闻的分类或者不同的新闻分类下的再次细分设计不同的function。<br>使用switch区分分类来构成线性函数。线性函数则由x的多个特征来设计。</p><p>Step6：若仍想取最优<br>将所有x的特征都加入到function中，并采取多次函数进行预测。可能会产生overfitting。<br>Regularization：<br>第二步中的估计误差的loss function选取更好的误差估计函数。<br>在进行regularization的时候，进行图像的平滑程度调整不需要考虑偏差，偏差只是让图像上下移动而已。<br>误差函数新增的项的值应该较小，使加上的项产生的函数较平滑。输入对输出的影响较小。<br>根据结果得出，新增的变量的值越大，图像越平滑。变量的值越大，越依赖于w，则error越大。<br>而对于新的测试数据，平滑图像的最优也可能导致error更大。</p><h4 id="Error来源">Error来源</h4><p>f*来自于训练得出的最优function，而程序使用的function为fhat<br>其中f*距fhat的‘距离’来自于bias和variance。<br>计算f*的数学期望 E[f*] 。bias即E[f*] 与f hat的误差，而variance即E[f*] 与f*的方差。<br>对于简单的模型函数拥有较低的variance，拥有较大的bias。而对于复杂的模型函数拥有较大的variance，拥有较小的bias。<br>对于简单的模型函数可能不包含你的fhat，而较复杂的模型函数可能包含你的fhat，但是variance较大。<br>对于模型函数来讲，当准度高即bias越来越小的时候，你的精度低即variance会越来越大。<br>对于训练数据得到的f*没有fit的情况下，bias较大。而对于测试数据测试f*时，产生的error较大，则应该考虑variance较大。<br>当bias较大时，应输入更多特征，优化模型函数。而variance较大时，应增大训练数据或者regularization(可能平滑之后无法包含fhat)。<br><strong>训练数据应分为两组，一组为Training set，另一组为Validation set。通过训练得到的f*在Validation set上进行验证，或者使用全部的训练数据。</strong><br>N-fold Cross Validation：将训练数据分为三份，以组合的形式(两份训练，一份验证)训练模型函数得到f*，再在全部的训练数据中进行测试。</p><h4 id="Gradient-Descent">Gradient Descent</h4><p>表达式：</p><p><img src="http://dingdm.online/grad.png" alt=""></p><h4 id="tuning-your-learning-rate">tuning your learning rate</h4><p>可视化参数的变化对loss的影响，当折线平稳下降时，rate较小，而折现下降平稳之后，则rate较大，当折线开始上升则rate错误。<br>learning rate会随着参数的更新越来越小。每一个不同的参数都应该有不同的learning rate。</p><p><img src="http://dingdm.online/desct.png" alt=""></p><p>Adagrad：选取一个数值为参数之前的均方根进行更新</p><p><img src="http://dingdm.online/Adagrad.png" alt=""></p><p>g为偏微分。</p><p>推荐使用Adam。</p><p>Adagrad会使用除值来弥补反差。当进行跨参数时，分子和一次微分成正比，分母和二次微分成反比。</p><p><img src="http://dingdm.online/er.png" alt=""></p><p>对于跨参数而言，参考如图即可得知，在a位置的一次微分较小，二次微分也较小。而对于c的位置一次微分较大，同时二次微分也较大。Adagrad就是通过分母预估二次微分的值。</p><h4 id="Stochastic-Gradient-Descent">Stochastic Gradient Descent</h4><p>计算单个样本的Loss和单个Gradient</p><p><img src="http://dingdm.online/sss.png" alt=""></p><p><img src="http://dingdm.online/sgrad.png" alt=""></p><p>每个样本更新一次参数，计算较快。</p><h4 id="Feature-Scaling">Feature Scaling</h4><p>当输入时考虑多个特征，且多个特征的规模相差较大时，可以rescaling将多个特征的规模调整到基本一致。<br>当多特征的选值相差较大时，会发现较大的特征值变更时对于loss的变化是较大的，而特征值小变化较小。所以小的特征值方向上比较平滑，而特征值大方向上的比较陡峭。这个时候参数的update寻找f*时是比较难的，消耗的时间较长。<br>而对特征进行rescaling之后，正圆形的参数更新是比较方便的。</p><p>rescaling的方法</p><p><img src="http://dingdm.online/resc.png" alt=""></p><h4 id="Gradient-Descent背后原理">Gradient Descent背后原理</h4><p>在使用gradient descent的时候，随着每次参数的更新，loss的值可能增大也可能也减小。</p><p>泰勒公式：有</p><p><img src="http://dingdm.online/tai.png" alt="img"></p><p>这是在对函数进行局部线性化处理时常用的公式之一。从几何上看，它是用切线近似代替曲线。<br><strong>让近似多项式函数在x=x0处的y值, 一阶导, 二阶导 …n阶导的值 = 原始函数在x=x0处的y值, 一阶导, 二阶导 …n阶导</strong><br>泰勒公式几何意义，一看就懂。<a href="https://www.zhihu.com/question/21149770" target="_blank" rel="noopener">https://www.zhihu.com/question/21149770</a><br>多维也是如此。</p><p><img src="http://dingdm.online/sasa.png" alt=""></p><p>而对于gradient descent来说，给定一个初始点和范围，可以使用泰勒公式计算最小的loss；而计算最小值的计算公式即为gradient。而learning rate设置时即要保证使用到的泰勒公式要成立，即x-x0的高阶导为无穷小量时。</p><p><img src="http://dingdm.online/tr.png" alt=""></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线性回归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记一次查漏补缺一</title>
      <link href="/2021/04/14/ji-yi-ci-cha-lou-bu-que-yi/"/>
      <url>/2021/04/14/ji-yi-ci-cha-lou-bu-que-yi/</url>
      
        <content type="html"><![CDATA[<h3 id="记一次查漏补缺一">记一次查漏补缺一</h3><h4 id="业务功能：不使用mysql或oracle实现持续签到领奖">业务功能：不使用mysql或oracle实现持续签到领奖</h4><p>技术实现：使用redis的bitmap实现</p><p>bitmap基于最小的单位bit进行存储，设置时候时间复杂度O(1)、读取时候时间复杂度O(n)，方便扩容。</p><p>签到信息以用户id和年数月数为key，所在天数为偏移值进行签到，1为签到，0为未签到。</p><p>伪代码实现</p><pre class=" language-language-java"><code class="language-language-java">//签到jedis.setbit(getKey(userId,keyDate), dayDate, true);//获取签到情况//获取位于偏移量 0 上的 monthDayLength 位长无符号数List<long> list = jedis.bitfield(getKey(userId,keyDate), "GET", monthDayLength, "0");//业务逻辑处理断签...//统计签到次数jedis.bitcount(getKey(userId,keyDate))</long></code></pre><p>redis的接口文档地址：<a href="http://redisdoc.com/bitmap/index.html" target="_blank" rel="noopener">http://redisdoc.com/bitmap/index.html</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python学习笔记二</title>
      <link href="/2021/04/14/python-xue-xi-bi-ji-er/"/>
      <url>/2021/04/14/python-xue-xi-bi-ji-er/</url>
      
        <content type="html"><![CDATA[<h3 id="python学习笔记二">python学习笔记二</h3><h4 id="循环结构">循环结构</h4><p>语法：<br>while a &gt; 0:<br>print(a)<br>for a in list:<br>print(a)<br>对于for in循环，不需要使用到自定义变量，可将自定义变量写为_</p><h4 id="列表">列表</h4><p>语法：<br>list = [“string”,int,float]<br>其中list()为内置函数<br>lst2 = list([“string”,int,float])<br>混淆点：python中列表中任意数据类型混存，列表的索引存在负值的索引</p><p>API：<br>.index(var) var：列表中的元素 列表中有相同元素，只返回列表中相同元素的第一个元素的索引<br>.index(var,start,end) start,end：指定查找的列表索引范围，前闭后开。<br>list[start:stop:step] step：步长 获取列表中的多个元素。获取到的对象为新对象，占用新的内存空间，而非对原数据的操作。步长为负时，将截取的列表逆序输出。相应的start与stop也逆序设置。<br>var in list：判断元素在列表中是否存在<br>.append(var)：在列表尾追加一个元素。对原数据进行操作，不产生新的对象。元素的类型可以为列表。<br>.extend(var)：追加元素时，若添加的元素为列表，则解析列表，以单元素的方式追加。<br>.insert(index,var)：在索引为index的位置上插入var元素<br>list[start:] = lst：将切掉的部分进行替换<br>.remove(var)：移除列表中的var元素，存在相同元素时，只移除第一个<br>.pop(index)：根据列表索引index移除元素。参数列表为空移除列表的最后一个元素<br>list[start:stop] = []：使用空元素替代<br>.clear()：清除列表中的所有元素<br>del var：删除列表，回收列表占用的内存空间<br>.sort(reverse=True)：对当前列表进行排序，默认由小至大排序。reverse设置为true进行降序排序。<br>sorted(var,reverse=True)：使用内置函数对列表进行排序，默认生序排序，排序生成新的列表对象。使用reverse参数值进行降序排序。</p><p>列表生成式：<br>[i for i in range(1,10)] 将1到9产生的整数作为列表，for之前的元素可以作为表达式进行对列表元素进行设置</p><h4 id="字典">字典</h4><p>语法：<br>map = {key:value, key:value,key:value}<br>dict()为内置函数<br>dict(name=‘var’,age=20)<br>面向对象，json序列化<br>字典中的key无法重复，同时必须是不可变对象。根据hash值存放元素，因此字典是无序的。</p><p>API：<br>map[key]：根据key获取value值<br>get(key,default)：根据key获取value值。不存在key时返回None，不报错。可以使用default指定查找失败时的默认值。<br>del map[key]：删除指定key的键值对<br>clear()：清空字典的元素<br>keys()：获取字典中的所有key，类型为dict_keys。可以通过list()进行转换<br>values()：获取字典中的所有values，类型为dict_values。<br>items()：获取字典中的所有键值对。</p><p>字典生成式：<br>zip(var1,var2)：var1与var2为可遍历对象。遍历时根据两个列表的索引动态生成字典。<br>{item:price for item, price in zip(items,prices)} 打包时以短的列表为基准，for之前为表达式</p><h4 id="元组">元组</h4><p>语法：<br>(‘var’,‘str’,int) 可以省略括号进行简写<br>使用内置函数tuple()<br>tuple((‘str’,int,float))<br>元组中只包含一个元素时，需要添加逗号。否则会被认定为String<br>元组的不可变类比于java中的final。</p><h4 id="集合">集合</h4><p>集合是没有value的字典，对比于java的set集合<br>语法：<br>{2,3,3,4,5,6,7} 集合中的value值不允许重复<br>使用内置函数set()<br>set(range(6))</p><p>API：<br>add(var)：向集合中添加元素<br>update({var1,var2,var3})：向集合中添加多个元素。同时可以向集合中添加列表和元组，列表和元组会被解析为单个元素添加。<br>remove(var)：删除集合中的元素<br>discard(var)：删除集合中的元素，不会报错值不存在异常<br>pop()：无参api，删除任意元素<br>clear()：清空集合元素<br>==和!=：判断时判断集合中的数据，而非地址<br>var1.issubset(var2)：var1是var2的子集判断<br>var2.issuperset(var1)：var2是var1的超集判断<br>var1.isdisjoint(var2)：var1和var2的交集判断</p><p>集合的数学操作：<br>交集：var1.intersection(var2)     var1 &amp; var2     集合不变化<br>并集：var1.union(var2)     var1 | var2     集合不变化<br>差集：var1.difference(var2)   var1-var2    集合不变化<br>对称差集：var1.symmetric_difference(var2)</p><p>集合生成式：<br>{i for i in range(1,10)} 和列表生成式一致，区别在于{}和[]</p><h4 id="字符串的操作">字符串的操作</h4><p>字符串驻留，与java相同。<br>驻留机制：<br>1.字符串长度为0或者1<br>2.符合标识符的字符串<br>3.只在编译时进行驻留，在程序运行时会开辟新的空间。<br>4.[-5,256]间的整数数字</p><p>API：<br>index(var)：查找子串第一次出现的位置，未出现子串报异常<br>find(var)：查找子串第一次出现的位置，未出现子串返回-1<br>rindex(var)：查找子串最后一次出现的位置<br>rfind(var)：查找子串最后一次出现的位置<br>upper()：转换字符为大写字母，产生一个新的字符串对象<br>lower()：转换字符为小写字母，产生一个新的字符串对象<br>swapcase()：大小写互相转换<br>capitalize()：第一个字符转换为大写，其余字符转换为小写<br>title()：把每个单词的第一个字符转换为大写，把每个单词的剩余字符转换为小写。<br>center(var1,var2)：居中对齐，var1指定宽度，var2指定填充符，var2可选，默认为空格，如果设置宽度小于实际宽度则返回原字符串<br>ljust(var1,var2)：左对齐，var1指定宽度，var2指定填充符，var2可选，默认为空格，如果设置宽度小于实际宽度则返回原字符串<br>rjust(var1,var2)：右对齐，var1指定宽度，var2指定填充符，var2可选，默认为空格，如果设置宽度小于实际宽度则返回原字符串<br>zfill(var)：右对齐，左边用0填充，该方法只接收一个参数，用于指定字符串的宽度，如果设置宽度小于实际宽度则返回原字符串<br>split(var1,var2)：从字符串的左侧开始劈分，默认为空格，返回一个列表。通过var1参数设置劈分的字符，通过var2设置劈分的最大次数，剩余的子串会单独做为一部分保存。<br>rsplit(var1,var2)：从字符串的右侧开始劈分，默认为空格，返回一个列表。通过var1参数设置劈分的字符，通过var2设置劈分的最大次数，剩余的子串会单独做为一部分保存。<br>isidentifier()：判断指定的字符串是不是合法的标识符<br>isspace()：判断指定的字符串是否全部由空白字符组成<br>isaplha()：判断指定的字符串是否全部由字母组成<br>isdecimal()：判断指定字符串是否全部由十进制的数字组成<br>isnumeric()：判断指定的字符串是否全部由数字组成<br>isalnum()：判断指定字符串是否全部由字母和数字组成<br>replace(var1,var2,var3)：var1指定被替换的子串，var2指定替换子串的字符串，该方法返回替换后得到的字符串，替换前的字符串不发生变化，调用该方法可以通过var3指定最大替换次数<br>join()：将列表或元组中的字符串合并成一个字符串</p><p>格式化字符串</p><p>%s %d % (name,age)<br>{0} {1} .format(name,age)<br>f {name} {age}<br>%10d 10表示宽度<br>%.3f % 3.1415926 .3保留小数<br>{0:.3}.format(3.1415926) .3一共表示三位数<br>{0:.3f}.format(3.1415926) .3f表示三位小数<br>{0:10.3f}.format(3.1415926) 宽度为10</p><p>字符串的编码转换</p><p>即序列化<br>encode(var) var即编码格式 GBK中文两个字节 UTF-8中文三个字节<br>decode(var) var即解码格式</p><h4 id="函数">函数</h4><p>语法：<br>def main(var1,var2):<br>业务逻辑<br>return var3<br>Python函数为值传递 具体的详细业务与java一样<br>函数返回值为多个时，返回的数据类型为元组</p><p>参数：<br>可变的位置参数：*args，传入的参数为一个元组。可变的位置参数只能为一个<br>个数可变的关键字形参：**args，传入的参数为一个字典。个数可变的关键字形参只能为一个。<br>在一个函数的定义过程中，既有个数可变的关键字形参，也有个数可变的位置形参，要求个数可变的位置参数在个数可变的关键字形参之前。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>个人类库工具文档(持续更新)</title>
      <link href="/2021/03/31/ge-ren-lei-ku-gong-ju-wen-dang/"/>
      <url>/2021/03/31/ge-ren-lei-ku-gong-ju-wen-dang/</url>
      
        <content type="html"><![CDATA[<h3 id="个人类库工具文档-持续更新">个人类库工具文档(持续更新)</h3><h4 id="文件操作类">文件操作类</h4><table><thead><tr><th>方法名称</th><th>方法注释</th><th>传入参数</th><th>参数注释</th><th>返回结果</th><th>结果注释</th></tr></thead><tbody><tr><td>FileUtils.ImgUpload()</td><td>文件上传工具类</td><td>file</td><td>MultipartFile文件类</td><td>Map</td><td>返回Map类型数据，文件uuid名称(uName),封装文件路径(url),文件原名称(filename),文件后缀(suffix),文件类型(type,1为图片,2为文档,3为视频,4为音频)。</td></tr><tr><td></td><td></td><td>path</td><td>文件存储路径</td><td></td><td></td></tr><tr><td></td><td></td><td>mvc</td><td>文件映射路径</td><td></td><td></td></tr><tr><td>FileUtils.getFileType()</td><td>获取文件类型</td><td>suffix</td><td>文件后缀</td><td>String</td><td>返回文件类型</td></tr></tbody></table><h4 id="日期操作类">日期操作类</h4><table><thead><tr><th>方法名称</th><th>方法注释</th><th>传入参数</th><th>参数注释</th><th>返回结果</th><th>结果注释</th></tr></thead><tbody><tr><td>DateUtils.format()</td><td>日期格式化 日期格式为：yyyy-MM-dd</td><td>Date</td><td>日期</td><td>String</td><td>返回yyyy-MM-dd格式日期</td></tr><tr><td></td><td></td><td>String</td><td>格式，如：DateUtils.DATE_TIME_PATTERN</td><td></td><td></td></tr><tr><td>DateUtils.stringToDate()</td><td>日期解析</td><td>String</td><td>日期</td><td>Date</td><td>返回Date</td></tr><tr><td></td><td></td><td>String</td><td>格式，如：DateUtils.DATE_TIME_PATTERN</td><td></td><td></td></tr><tr><td>DateUtils.getWeekStartAndEnd()</td><td>根据周数，获取开始日期、结束日期</td><td>int</td><td>周期  0本周，-1上周，-2上上周，1下周，2下下周</td><td>Date数组</td><td>返回date[0]开始日期、date[1]结束日期</td></tr><tr><td>DateUtils.addDateSeconds()</td><td>对日期的【秒】进行加/减</td><td>Date</td><td>日期</td><td>Date</td><td>加/减几秒后的日期</td></tr><tr><td></td><td></td><td>int</td><td>秒数，负数为减</td><td></td><td></td></tr><tr><td>DateUtils.addDateMinutes()</td><td>对日期的【分钟】进行加/减</td><td>Date</td><td>日期</td><td>Date</td><td>加/减几分钟后的日期</td></tr><tr><td></td><td></td><td>int</td><td>分钟数，负数为减</td><td></td><td></td></tr><tr><td>DateUtils.addDateHours()</td><td>对日期的【小时】进行加/减</td><td>Date</td><td>日期</td><td>Date</td><td>加/减几小时后的日期</td></tr><tr><td></td><td></td><td>int</td><td>小时数，负数为减</td><td></td><td></td></tr><tr><td>DateUtils.addDateDays()</td><td>对日期的【天】进行加/减</td><td>Date</td><td>日期</td><td>Date</td><td>加/减几天后的日期</td></tr><tr><td></td><td></td><td>int</td><td>天数，负数为减</td><td></td><td></td></tr><tr><td>DateUtils.addDateWeeks()</td><td>对日期的【周】进行加/减</td><td>Date</td><td>日期</td><td>Date</td><td>加/减几周后的日期</td></tr><tr><td></td><td></td><td>int</td><td>加/减几周后的日期</td><td></td><td></td></tr><tr><td>DateUtils.addDateMonths()</td><td>对日期的【月】进行加/减</td><td>Date</td><td>日期</td><td>Date</td><td>对日期的【月】进行加/减</td></tr><tr><td></td><td></td><td>int</td><td>加/减几月后的日期</td><td></td><td></td></tr><tr><td>DateUtils.addDateYears()</td><td>对日期的【年】进行加/减</td><td>Date</td><td>日期</td><td>Date</td><td>加/减几年后的日期</td></tr><tr><td></td><td></td><td>int</td><td>年数，负数为减</td><td></td><td></td></tr></tbody></table><h4 id="Word导出类">Word导出类</h4><table><thead><tr><th>方法名称</th><th>方法注释</th><th>传入参数</th><th>参数注释</th><th>返回结果</th><th>结果注释</th></tr></thead><tbody><tr><td>WordUtils.exportWord()</td><td>获取word文件下载地址</td><td>Map</td><td>封装的需要的Map参数</td><td>String</td><td>word文件下载地址</td></tr><tr><td></td><td></td><td>String</td><td>word模板文件所在地址</td><td></td><td></td></tr><tr><td></td><td></td><td>String</td><td>word文件导出地址</td><td></td><td></td></tr><tr><td></td><td></td><td>String</td><td>word模板名称</td><td></td><td></td></tr><tr><td></td><td></td><td>String</td><td>文件映射路径</td><td></td><td></td></tr></tbody></table><h4 id="Spring容器类">Spring容器类</h4><table><thead><tr><th>方法名称</th><th>方法注释</th><th>传入参数</th><th>参数注释</th><th>返回结果</th><th>结果注释</th></tr></thead><tbody><tr><td>SpringContextUtils.getBean()</td><td>获取java bean</td><td>Class<t></t></td><td>java类</td><td><t></t></td><td>返回java bean</td></tr><tr><td>SpringContextUtils.getBean()</td><td>获取java bean</td><td>String</td><td>类名称</td><td><t></t></td><td>返回java bean</td></tr><tr><td></td><td></td><td>Class<t></t></td><td>java类</td><td></td><td></td></tr><tr><td>SpringContextUtils.containsBean()</td><td>是否包含java bean</td><td>String</td><td>类名称</td><td>boolean</td><td>是否包含</td></tr><tr><td>SpringContextUtils.isSingleton()</td><td>bean是否为单例</td><td>String</td><td>类名称</td><td>boolean</td><td>是否为单例</td></tr><tr><td>SpringContextUtils.getType()</td><td>获取java类型</td><td>String</td><td>类名称</td><td>Class&lt;? extends Object&gt;</td><td>java类型</td></tr></tbody></table><h4 id="Excel工具类">Excel工具类</h4><table><thead><tr><th>方法名称</th><th>方法注释</th><th>传入参数</th><th>参数注释</th><th>返回结果</th><th>结果注释</th></tr></thead><tbody><tr><td>ExcelUtils.exportExcel()</td><td>Excel导出</td><td>HttpServletResponse</td><td>response</td><td>void</td><td></td></tr><tr><td></td><td></td><td>String</td><td>文件名</td><td></td><td></td></tr><tr><td></td><td></td><td>Collection&lt;?&gt;</td><td>数据List</td><td></td><td></td></tr><tr><td></td><td></td><td>Class&lt;?&gt;</td><td>对象Class</td><td></td><td></td></tr><tr><td>ExcelUtils.getMyCellDate()</td><td>excel日期转换</td><td>Cell</td><td>获取excel的日期列</td><td>Date</td><td>日期</td></tr></tbody></table><h4 id="个人邮件类">个人邮件类</h4><table><thead><tr><th>方法名称</th><th>方法注释</th><th>传入参数</th><th>参数注释</th><th>返回结果</th><th>结果注释</th></tr></thead><tbody><tr><td>new Thread(new MailUtils(email,sendEmail,password,host,html,title,qq)).start();</td><td>创建线程发送邮件</td><td>String</td><td>接收人邮箱</td><td>void</td><td>控制台打印信息</td></tr><tr><td></td><td></td><td>String</td><td>发送人邮箱</td><td></td><td></td></tr><tr><td></td><td></td><td>String</td><td>发送人邮箱授权码</td><td></td><td></td></tr><tr><td></td><td></td><td>String</td><td><a href="http://xn--smtp-zh5ft2bu2us9p2xpj2jcm6bd61dj3b.qq.com" target="_blank" rel="noopener">指定发送邮件的主机smtp.qq.com</a>(QQ)|<a href="http://smtp.163.com" target="_blank" rel="noopener">smtp.163.com</a>(网易)</td><td></td><td></td></tr><tr><td></td><td></td><td>String</td><td>邮件html内容</td><td></td><td></td></tr><tr><td></td><td></td><td>String</td><td>邮件标题</td><td></td><td></td></tr><tr><td></td><td></td><td>boolean</td><td>是否为qq邮箱</td><td></td><td></td></tr></tbody></table><h4 id="MessageUtils工具类">MessageUtils工具类</h4><table><thead><tr><th>方法名称</th><th>方法注释</th><th>传入参数</th><th>参数注释</th><th>返回结果</th><th>结果注释</th></tr></thead><tbody><tr><td>SnowFlake.nextId()</td><td>获取雪花id</td><td>无</td><td>无</td><td>Long</td><td>雪花id</td></tr></tbody></table><h4 id="Ip工具类">Ip工具类</h4><table><thead><tr><th>方法名称</th><th>方法注释</th><th>传入参数</th><th>参数注释</th><th>返回结果</th><th>结果注释</th></tr></thead><tbody><tr><td>IpUtils.getIpAddr()</td><td>获取ip地址</td><td>HttpServletRequest</td><td>request请求对象</td><td>String</td><td>ip地址</td></tr></tbody></table><h4 id="加密工具类">加密工具类</h4><table><thead><tr><th>方法名称</th><th>方法注释</th><th>传入参数</th><th>参数注释</th><th>返回结果</th><th>结果注释</th></tr></thead><tbody><tr><td>MD5Utils.MD5()</td><td>md5加密</td><td>String</td><td>加密内容</td><td>String</td><td>加密结果</td></tr></tbody></table><h4 id="类型转换工具类">类型转换工具类</h4><table><thead><tr><th>方法名称</th><th>方法注释</th><th>传入参数</th><th>参数注释</th><th>返回结果</th><th>结果注释</th></tr></thead><tbody><tr><td>TransformUtils.mapToXml()</td><td>将Map转换为XML格式的字符串</td><td>Map&lt;String, String&gt;</td><td>原数据</td><td>String</td><td>返回xml</td></tr><tr><td>TransformUtils.xmlToMap()</td><td>XML格式字符串转换为Map</td><td>String</td><td>xml数据</td><td>Map&lt;String, String&gt;</td><td>Map数据</td></tr></tbody></table><h4 id="支付工具类">支付工具类</h4><p>创建代理对象</p><table><thead><tr><th>方法名称</th><th>方法注释</th><th>传入参数</th><th>参数注释</th><th>返回结果</th><th>结果注释</th></tr></thead><tbody><tr><td>new AliPay()</td><td>创建ali支付参数类</td><td>String</td><td>appId</td><td>AliPay</td><td>Alipay对象</td></tr><tr><td></td><td></td><td>String</td><td>网关</td><td></td><td></td></tr><tr><td></td><td></td><td>String</td><td>商户私钥</td><td></td><td></td></tr><tr><td></td><td></td><td>String</td><td>编码格式</td><td></td><td></td></tr><tr><td></td><td></td><td>String</td><td>支付宝公钥</td><td></td><td></td></tr><tr><td></td><td></td><td>String</td><td>签名方式</td><td></td><td></td></tr><tr><td></td><td></td><td>String</td><td>异步通知页面</td><td></td><td></td></tr><tr><td></td><td></td><td>String</td><td>同步通知页面</td><td></td><td></td></tr></tbody></table><p>封装响应数据</p><table><thead><tr><th>方法名称</th><th>方法注释</th><th>传入参数</th><th>参数注释</th><th>返回结果</th><th>结果注释</th></tr></thead><tbody><tr><td>AliPayUtils.aliParam()</td><td>构造响应内容</td><td>String</td><td>biz_content，请求参数的集合，最大长度不限，除公共参数外所有请求参数都必须放在这个参数中传递</td><td>String</td><td>响应内容</td></tr><tr><td></td><td></td><td>AliPay</td><td>alipay对象</td><td></td><td></td></tr></tbody></table><p>创建微信参数对象</p><table><thead><tr><th>方法名称</th><th>方法注释</th><th>传入参数</th><th>参数注释</th><th>返回结果</th><th>结果注释</th></tr></thead><tbody><tr><td>new WxPay()</td><td>创建微信支付参数类</td><td>String</td><td>微信id</td><td>WxPay</td><td>WxPay对象</td></tr><tr><td></td><td></td><td>String</td><td>商户号</td><td></td><td></td></tr><tr><td></td><td></td><td>String</td><td>key</td><td></td><td></td></tr><tr><td></td><td></td><td>String</td><td>异步通知页面</td><td></td><td></td></tr></tbody></table><p>创建微信签名</p><table><thead><tr><th>方法名称</th><th>方法注释</th><th>传入参数</th><th>参数注释</th><th>返回结果</th><th>结果注释</th></tr></thead><tbody><tr><td>WxPayUtils.createWxParam()</td><td>创建微信签名</td><td>HttpServletRequest</td><td>request请求参数</td><td>String</td><td>微信支付签名</td></tr><tr><td></td><td></td><td>WxPay</td><td>微信请求参数对象</td><td></td><td></td></tr><tr><td></td><td></td><td>String</td><td>body</td><td></td><td></td></tr><tr><td></td><td></td><td>String</td><td>订单编号</td><td></td><td></td></tr><tr><td></td><td></td><td>BigDecimal</td><td>订单总价格</td><td></td><td></td></tr></tbody></table><p>返回微信支付响应数据</p><table><thead><tr><th>方法名称</th><th>方法注释</th><th>传入参数</th><th>参数注释</th><th>返回结果</th><th>结果注释</th></tr></thead><tbody><tr><td>WxPayUtils.wxParam()</td><td>创建响应内容</td><td>HttpServletRequest</td><td>request请求参数</td><td>String</td><td>支付响应内容</td></tr><tr><td></td><td></td><td>WxPay</td><td>微信请求参数对象</td><td></td><td></td></tr><tr><td></td><td></td><td>String</td><td>微信签名</td><td></td><td></td></tr><tr><td></td><td></td><td>String</td><td>body</td><td></td><td></td></tr><tr><td></td><td></td><td>String</td><td>订单编号</td><td></td><td></td></tr><tr><td></td><td></td><td>BigDecimal</td><td>订单总价格</td><td></td><td></td></tr></tbody></table><h3 id="类库文件">类库文件</h3><p><a href="http://dingdm.online/dingdm-1.0-SNAPSHOT.jar" target="_blank" rel="noopener">http://dingdm.online/dingdm-1.0-SNAPSHOT.jar</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jar </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring boot相关知识点</title>
      <link href="/2021/03/30/springboot-xiang-guan-zhi-shi-dian/"/>
      <url>/2021/03/30/springboot-xiang-guan-zhi-shi-dian/</url>
      
        <content type="html"><![CDATA[<h3 id="Springboot中如何解决跨域问题？">Springboot中如何解决跨域问题？</h3><p>在脚本进行http请求的时候要满足同源协议，即url的协议，域名和端口要相同才能才能发起请求。浏览器在脚本发出跨域请求后，会拦截返回的结果，所以需要配置跨域。</p><p>当用户退出或者token过期时，拦截器和跨域的顺序配置会导致跨域问题，一个http请求，先走filter，到达servlet后才进行拦截器的处理。一般在前后端分离部署时要解决跨域问题，通过cors来实现跨域问题。</p><p>如果不是前后端分离部署的项目。可以通过实现WebMvcConfigurer然后重写addCorsMappings方法来实现跨域配置。</p><pre class=" language-language-java"><code class="language-language-java">@Configurationpublic class CorsConfig implements WebMvcConfigurer {    @Override    public void addCorsMappings(CorsRegistry registry) {        registry.addMapping("/**")                .allowedOrigins("*")                .allowCredentials(true)                .allowedMethods("GET", "POST", "PUT", "DELETE", "OPTIONS")                .maxAge(3600);    }}</code></pre><p>把cors放在filter里面，就可以在拦截器之前进行。</p><pre class=" language-language-java"><code class="language-language-java">@Configurationpublic class CorsConfig {    @Bean    public CorsFilter corsFilter() {        CorsConfiguration corsConfiguration = new CorsConfiguration();        corsConfiguration.addAllowedOrigin("*");        corsConfiguration.addAllowedHeader("*");        corsConfiguration.addAllowedMethod("*");        corsConfiguration.setAllowCredentials(true);        UrlBasedCorsConfigurationSource urlBasedCorsConfigurationSource = new UrlBasedCorsConfigurationSource();        urlBasedCorsConfigurationSource.registerCorsConfiguration("/**", corsConfiguration);        return new CorsFilter(urlBasedCorsConfigurationSource);    }}</code></pre><h3 id="SpringBoot的核心配置文件有哪几个？他们的区别是什么？">SpringBoot的核心配置文件有哪几个？他们的区别是什么？</h3><p>Spring boot的核心配置文件有两个，application和bootstrap。application主要用于spring boot的自动化配置。spring boot使用@EnableConfigurationProperties注解映射application中的参数和POJO的关系。</p><p>bootstrap配置文件的加载要优于application，且里面配置的属性不能被覆盖。使用spring Cloud config 配置中心时，这时需要在bootstrap 配置文件中添加连接到配置中心的配置属性来加载外部配置中心的配置信息。</p><h3 id="Spring-boot的异常处理">Spring boot的异常处理</h3><h4 id="Spring-Boot类BasicErrorController">Spring Boot类BasicErrorController</h4><p><img src="http://dingdm.online/20190608165028699.png" alt=""></p><p>这是一个基础全局错误controller,Spring Boot自带的，看到这个RequestMapping地址，这是一个相当于三元写法，如果你在配置文件配置了server.error.path的话，就会使用你配置的异常处理地址，如果没有就会使用你配置的error.path路径地址，如果还是没有，默认使用/error来作为发生异常的处理地址。</p><p>默认的类在你的请求返回文本或者json数据的时候，当发生错误的话，如果你在配置文件里面配置了模板引擎并且有error的页面，这个类就会返回你的error页面。返回的数据通过getErrorAttributes方法封装你的路径，状态，信息，时间戳等信息。</p><p>可以通过自定义一个bean来实现ErrorController来屏蔽默认的异常处理。如果不想全部屏蔽，可以自定义一个bean来继承BasicErrorController接口来使用部分功能，并自定义自己的错误映射地址。</p><h4 id="统一异常处理">统一异常处理</h4><pre class=" language-language-java"><code class="language-language-java">package com.riemann.springbootdemo.exception;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.web.bind.annotation.ControllerAdvice;import org.springframework.web.bind.annotation.ExceptionHandler;import org.springframework.web.bind.annotation.ResponseBody;import org.springframework.web.servlet.ModelAndView;import javax.servlet.http.HttpServletRequest;@ControllerAdvicepublic class GlobalExceptionHandle extends RuntimeException{    private static final Logger logger = LoggerFactory.getLogger(GlobalExceptionHandle.class);    @ExceptionHandler(value = Exception.class)    public ModelAndView exceptionHandle(HttpServletRequest request, Exception exception) {        String url = request.getRequestURL().toString();        logger.error("URL: " + url);        logger.error("Excption: ", exception);        ModelAndView mv = new ModelAndView();        mv.addObject("exception", exception);        mv.addObject("url", url);        mv.setViewName("error");        return mv;    }}</code></pre><p>统一处理Exception异常，只需要在类上标注ControllerAdvice这个注解，然后在类方法上标注好对应的ExceptionHandler及异常类。ControllerAdvice可以用来进行全局异常处理，全局数据绑定和全局数据预处理。</p><h3 id="Spring-Boot与Spring的区别">Spring Boot与Spring的区别</h3><h4 id="Spring">Spring</h4><p>spring框架为开发Java应用程序提供了全面的基础架构支持，它包含一些很好的功能，如依赖注入和开箱即用的模块。</p><p><strong>Spring JDBC</strong></p><p>spring中的JDBC主要为数据库资源管理和错误处理，简化开发人员对数据库的操作。其中，JDBC Template是JDBC的核心类，使用核心类提供的方法来操作数据库。</p><p><strong>Spring MVC</strong></p><p>Spring MVC将传统的模型层拆分为了业务层(Service)和数据访问层(DAO)。在 Service 下可以通过 Spring 的声明式事务操作数据访问层，而在业务层上还允许我们访问 NoSQL。其中，M即模型，数据，V代表视图，C为控制器，将不同的数据显示在不同的视图上。</p><p><strong>Spring Security</strong></p><p>Spring Security的核心功能为认证，授权和攻击防护。核心为使用Basic Authentication Filter过滤器认证用户身份。</p><p><strong>Spring AOP</strong></p><p>不想多说</p><p><strong>Spring ORM</strong></p><p>对象关系映射，ORM是通过使用描述对象和数据库之间映射的元数据，将程序中的对象自动持久化到关系数据库中。</p><p><strong>Spring Test</strong></p><p>并不重要</p><h4 id="Spring-Boot">Spring Boot</h4><p>Spring Boot基本上是Spring框架的扩展，它消除了设置Spring应用程序所需的复杂例行配置。</p><ul><li>通过starter这一个依赖，以简化构建和复杂的应用程序配置</li><li>可以直接main函数启动，嵌入式web服务器，避免了应用程序部署的复杂性</li><li>Metrics度量，Helth check健康检查和外部化配置</li><li>自动化配置Spring功能</li></ul><h4 id="两者的区别">两者的区别</h4><h5 id="maven依赖">maven依赖</h5><p>Spring创建Web应用程序所需的最小依赖项：</p><pre class=" language-language-xml"><code class="language-language-xml">org.springframeworkspring-web5.1.0.RELEASEorg.springframeworkspring-webmvc5.1.0.RELEASE</code></pre><p>与Spring不同，Spring Boot只需要一个依赖项来启动和运行Web应用程序：</p><pre class=" language-language-xml"><code class="language-language-xml">org.springframework.bootspring-boot-starter-web2.0.5.RELEASE</code></pre><p>在构建期间，所有其他依赖项将自动添加到最终归档中。spring-boot-starter-web包自动帮我们引入了web模块开发需要的相关jar包。spring-boot-starter-web会自动引入spring-webmvc，spring-boot-starter-validation，spring-boot-starter，spring-boot-starter-json，spring-boot-starter-tomcat5个基础依赖。</p><h5 id="MVC配置">MVC配置</h5><p>通过实现WebApplicationInitializer，在其中可以添加servlet，listener等，在加载Web项目的时候会加载这个接口实现类，从而起到web.xml相同的作用</p><pre class=" language-language-java"><code class="language-language-java">package org.springframework.web; import java.lang.reflect.Modifier;import java.util.Iterator;import java.util.LinkedList;import java.util.List;import java.util.Set;import javax.servlet.ServletContainerInitializer;import javax.servlet.ServletContext;import javax.servlet.ServletException;import javax.servlet.annotation.HandlesTypes;import org.springframework.core.annotation.AnnotationAwareOrderComparator; @HandlesTypes({WebApplicationInitializer.class})public class SpringServletContainerInitializer implements ServletContainerInitializer {    public SpringServletContainerInitializer() {    }     public void onStartup(Set<class<?>&gt; webAppInitializerClasses, ServletContext servletContext) throws ServletException {        List<webapplicationinitializer> initializers = new LinkedList();        Iterator var4;        if(webAppInitializerClasses != null) {            var4 = webAppInitializerClasses.iterator();             while(var4.hasNext()) {                Class<!--?--> waiClass = (Class)var4.next();                if(!waiClass.isInterface() &amp;&amp; !Modifier.isAbstract(waiClass.getModifiers()) &amp;&amp; WebApplicationInitializer.class.isAssignableFrom(waiClass)) {                    try {                        initializers.add((WebApplicationInitializer)waiClass.newInstance());                    } catch (Throwable var7) {                        throw new ServletException("Failed to instantiate WebApplicationInitializer class", var7);                    }                }            }        }         if(initializers.isEmpty()) {            servletContext.log("No Spring WebApplicationInitializer types detected on classpath");        } else {            servletContext.log(initializers.size() + " Spring WebApplicationInitializers detected on classpath");            AnnotationAwareOrderComparator.sort(initializers);            var4 = initializers.iterator();             while(var4.hasNext()) {                WebApplicationInitializer initializer = (WebApplicationInitializer)var4.next();                initializer.onStartup(servletContext);            }         }    }}</webapplicationinitializer></class<?></code></pre><p>判断webAppInitializerClasses这个Set是否为空。如果不为空的话，找到这个set中不是接口，不是抽象类，并且是WebApplicationInitializer接口实现类的类，将它们保存到list中。当这个list为空的时候，抛出异常。不为空的话就按照一定的顺序排序，并将它们按照一定的顺序实例化。调用其onStartup方法执行。</p><pre class=" language-language-java"><code class="language-language-java">public class MyWebAppInitializer implements WebApplicationInitializer {    @Override    public void onStartup(ServletContext container) {        AnnotationConfigWebApplicationContext context          = new AnnotationConfigWebApplicationContext();        context.setConfigLocation("com.test.package");        container.addListener(new ContextLoaderListener(context));        ServletRegistration.Dynamic dispatcher = container          .addServlet("dispatcher", new DispatcherServlet(context));        dispatcher.setLoadOnStartup(1);        dispatcher.addMapping("/");    }}</code></pre><p>我们还需要将@EnableWebMvc注解添加到@Configuration注解类，并定义一个视图解析器来解析从控制器返回的视图。在使用该注解后配置一个继承于WebMvcConfigurerAdapter的配置类即可配置好Spring WebMVC。</p><pre class=" language-language-java"><code class="language-language-java">@EnableWebMvc@Configurationpublic class ClientWebConfig implements WebMvcConfigurer {   @Bean   public ViewResolver viewResolver() {      InternalResourceViewResolver bean        = new InternalResourceViewResolver();      bean.setViewClass(JstlView.class);      bean.setPrefix("/WEB-INF/view/");      bean.setSuffix(".jsp");      return bean;   }}</code></pre><p>与所有这些相比，一旦我们添加了Spring boot web starter，Spring Boot只需要一些属性来使上面的事情正常工作。</p><pre class=" language-language-yml"><code class="language-language-yml">spring.mvc.view.prefix=/WEB-INF/jsp/spring.mvc.view.suffix=.jsp</code></pre><p>上面的所有Spring配置都是通过一个名为auto-configuration的进程添加Boot web starter来自动包含的。这意味着Spring Boot将自动扫描应用程序中存在的依赖项，属性和bean，并根据这些内容启用相应的配置。</p><p>SpringBoot 自动配置主要通过 <code>@EnableAutoConfiguration</code>, <code>@Conditional</code>, <code>@EnableConfigurationProperties</code> 或者 <code>@ConfigurationProperties</code> 等几个注解来进行自动配置完成的。</p><p><code>@EnableAutoConfiguration</code> 开启自动配置，主要作用就是调用 <code>Spring-Core</code> 包里的 <code>loadFactoryNames()</code>，将 <code>autoconfig</code> 包里的已经写好的自动配置加载进来。</p><p><code>@Conditional</code> 条件注解，通过判断类路径下有没有相应配置的 <code>jar</code> 包来确定是否加载和自动配置这个类。</p><p><code>@EnableConfigurationProperties</code> 的作用就是，给自动配置提供具体的配置参数，只需要写在 <code>application.properties</code> 中，就可以通过映射写入配置类的 <code>POJO</code> 属性中</p><h5 id="模板引擎">模板引擎</h5><p>在Spring中，我们需要为视图解析器添加  thymeleaf-spring5依赖项和一些配置</p><pre class=" language-language-java"><code class="language-language-java">@Configuration@EnableWebMvcpublic class MvcWebConfig implements WebMvcConfigurer {    @Autowired    private ApplicationContext applicationContext;    @Bean    public SpringResourceTemplateResolver templateResolver() {        SpringResourceTemplateResolver templateResolver = new SpringResourceTemplateResolver();        templateResolver.setApplicationContext(applicationContext);        templateResolver.setPrefix("/WEB-INF/views/");        templateResolver.setSuffix(".html");        return templateResolver;    }    @Bean    public SpringTemplateEngine templateEngine() {        SpringTemplateEngine templateEngine = new SpringTemplateEngine();        templateEngine.setTemplateResolver(templateResolver());        templateEngine.setEnableSpringELCompiler(true);        return templateEngine;    }    @Override    public void configureViewResolvers(ViewResolverRegistry registry) {        ThymeleafViewResolver resolver = new ThymeleafViewResolver();        resolver.setTemplateEngine(templateEngine());        registry.viewResolver(resolver);    }</code></pre><p>ApplicationContext是spring继BeanFactory之外的另一个核心接口或容器，允许容器通过应用程序上下文环境创建、获取、管理bean。为应用程序提供配置的中央接口。</p><p>Spring Boot 只需要spring-boot-starter-thymeleaf的依赖项 来启用Web应用程序中的Thymeleaf支持。一旦依赖关系添加成功后，我们就可以将模板添加到src / main / resources / templates文件夹中，Spring Boot将自动显示它们。具体过程也参考上方的自动配置。</p><h5 id="安全配置">安全配置</h5><p>Spring需要标准的  spring-security-web和spring-security-config  依赖项来在应用程序中设置Security。接下来，我们需要添加一个扩展WebSecurityConfigurerAdapter的类，并使用@EnableWebSecurity注解</p><pre class=" language-language-java"><code class="language-language-java">@Configuration@EnableWebSecuritypublic class CustomWebSecurityConfigurerAdapter extends WebSecurityConfigurerAdapter {    @Autowired    public void configureGlobal(AuthenticationManagerBuilder auth) throws Exception {        auth.inMemoryAuthentication()          .withUser("user1")            .password(passwordEncoder()            .encode("user1Pass"))          .authorities("ROLE_USER");    }    @Override    protected void configure(HttpSecurity http) throws Exception {        http.authorizeRequests()          .anyRequest().authenticated()          .and()          .httpBasic();    }    @Bean    public PasswordEncoder passwordEncoder() {        return new BCryptPasswordEncoder();    }}</code></pre><p>WebSecurityConfigurerAdapter 类是个适配器, 在配置的时候,需要我们自己写个配置类去继承他,然后编写自己所特殊需要的配置。</p><p>Spring Boot也需要这些依赖项才能使其工作。但是我们只需要定义spring-boot-starter-security的依赖关系，它会自动将所有相关的依赖项添加到类路径中。</p><h5 id="应用引导Application-Bootstrap">应用引导Application Bootstrap</h5><p><strong>web.xml引导方法</strong></p><ol><li>Servlet容器（服务器）读取web.xml</li><li>web.xml中定义的DispatcherServlet由容器实例化</li><li>DispatcherServlet通过读取WEB-INF / {servletName} -servlet.xml来创建WebApplicationContext</li><li>最后，DispatcherServlet注册在应用程序上下文中定义的bean</li></ol><p><strong>servlet 3+引导方法</strong></p><p><strong>在web容器启动时为提供给第三方组件机会做一些初始化的工作，例如注册servlet或者filtes等，servlet规范中通过ServletContainerInitializer实现此功能。每个框架要使用ServletContainerInitializer就必须在对应的jar包的META-INF/services 目录创建一个名为javax.servlet.ServletContainerInitializer的文件，文件内容指定具体的ServletContainerInitializer实现类，那么，当web容器启动时就会运行这个初始化器做一些组件内的初始化工作。</strong></p><ol><li>容器搜索实现ServletContainerInitializer的 类并执行</li><li>SpringServletContainerInitializer找到实现类WebApplicationInitializer的子类</li><li>WebApplicationInitializer创建会话使用XML或上下文@Configuration类</li><li>WebApplicationInitializer创建DispatcherServlet，使用先前创建的上下文。</li></ol><p><strong>Spring Boot引导</strong></p><p>详情参考Spring Boot启动过程的文章。</p><p><strong>参考文章：<a href="https://mp.weixin.qq.com/s/0qk2kaCKLdAViVzsw401sg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/0qk2kaCKLdAViVzsw401sg</a></strong></p><h3 id="Shiro知识点">Shiro知识点</h3><p>shiro和核心概念为subject，securityManager和realm。subject即为与当前应用交互的主体，主体将交互请求委托给securityManager。securityManager通过realm判断当前用户认证信息，并授权用户的身份和角色信息，判断是否具有相关权限。</p><h4 id="自定义relam">自定义relam</h4><p>AuthorizingRealm中的doGetAuthenticationInfo用于身份验证，doGetAuthorizationInfo用于授权。</p><h4 id="身份认证过程">身份认证过程</h4><p>主体subject调用subject.login(token)，将请求委托给securityManager。</p><p>Authenticator获取token信息并传入realm，从realm获取身份验证信息。</p><p>realm根据加密方式查询数据库进行验证，验证成功返回成功信息。可以单个realm验证，也可以多realm验证，根据不同策略判断是否需要多个realm同时验证成功。</p><p>doGetAuthenticationInfo获取身份验证相关信息：首先根据传入的用户名获取User信息；如果user为空，那么抛出没找到账号异常UnknownAccountExecption；如果user找到但却被锁定了抛出锁定异常LockedAccountException；最后生成AuthenticationInfo信息，交给间接父类AuthenticatingRealm使用CredentialsMatcher进行判断密码是否匹配，如果不匹配将抛出密码错误异常信息IncorrectCredentialsException；如果密码重试次数太多将抛出超出重试次数异常ExcessiveAttemptsException；在组装SimpleAuthenticationInfo信息时，需要传入：身份信息（用户名）、凭据（密文密码）、盐（username+salt），CredentialsMatcher使用盐加密传入的明文密码和此处的密文密码进行匹配。</p><h4 id="授权过程">授权过程</h4><p>身份验证成功，通过Authorization进行授权。可以在后台使用逻辑代码判断是否具有权限和角色，也可以使用注解给接口授权，也可以使用前台标签的形式进行授权。</p><p>同时可以在shiro的配置文件中放开登录接口和静态资源的访问权限。</p><p>doGetAuthorizationInfo获取授权信息：PrincipalCollection是一个身份集合，因为只用到了一个Realm，所以直接调用getPrimaryPrincipal得到之前传入的用户名即可；然后根据用户名调用UserService接口获取角色及权限信息。</p><h4 id="Session-Manager">Session Manager</h4><p>Session Manager是securityManager的父类，维护subject主体的相关信息。Session manager一般将会话委托也就是继承的方式给securityManager进行处理。</p><h3 id="JWT知识点">JWT知识点</h3><h4 id="jwt和security的对比">jwt和security的对比</h4><p>jwt使用token验证，jwt无需在服务器端存储用户数据，减轻服务端压力。security是将用户数据保存在服务器端。</p><p>jwt是可以跨语言的，不想security针对某个语言进行开发一个适用的框架。</p><p>随之而来的就是对token的控制问题。</p><h4 id="如何解决token注销问题">如何解决token注销问题</h4><p>减少token的有效期，使token尽快失效。</p><p>使用redis，前端发起请求时，携带的jwt数据信息，把信息中的唯一的id存到redis里面，验证的时候查询redis中是否有这个id，在token注销的时候删除redis里面的id即可。</p><h4 id="怎么解决token失效后的续签问题">怎么解决token失效后的续签问题</h4><p>在用户登录验证的时候根据相关标准判断当前的token是否要过期。如果token快要过期，重新生成token就可以。</p><h4 id="解决cookie被盗用问题">解决cookie被盗用问题</h4><p>如果收到XSS攻击的话，设置一下cookie的httponly为true，防止脚本攻击。</p><p>对于抓包的话使用https协议即可。</p><p>对于CSRF攻击，在请求头中加个随机码。</p><h4 id="cookie被禁用怎么办">cookie被禁用怎么办</h4><p>判断一下用户的cookie是否禁用，如果禁用提示用户打开即可。</p><h4 id="解决cookie被篡改问题">解决cookie被篡改问题</h4><p>cookie被篡改，但是jwt验证是通过签名进行验证的，签名不对，后台的jwt验证就通过不了。</p><h4 id="服务端微服务地址不小心暴露了，用户就可以绕过网关，直接访问微服务，怎么办">服务端微服务地址不小心暴露了，用户就可以绕过网关，直接访问微服务，怎么办</h4><p>一般来说微服务都是使用nginx代理的，一般暴露的都是nginx的地址。</p><p>如果担心接口暴露，那也可以在微服务之间通信也使用jwt验证即可。</p><h4 id="jwt流程分析">jwt流程分析</h4><p>在前端，jwt头部记录信息和加密方式，然后进行编码。载荷记录token的对象和时间等信息，也进行编码。以句号拼接两部分的编码内容使用密钥和算法进行加密形成签名。服务器端以相同的方式即相同的密码和算法进行签名得到一直的结果验证成功返回客户端jwt信息，客户端请求接口时携带jwt信息就可以了。</p><h3 id="redis知识点">redis知识点</h3><h4 id="redis的特点">redis的特点</h4><p>redis的数据存在于内存之中，因此redis的读写速度很快，所以常用作缓存。</p><p>支持AOF和RDB两种数据持久化方式。</p><p>支持事务，redis的所有操作都是原子性的。</p><p>支持主从复制，主机可以将数据同步到从机。</p><p>redis数据存在于内存中，所以不适合海量数据的读写。</p><p>redis对扩容的兼容性较差。</p><h4 id="为什么要使用redis">为什么要使用redis</h4><p>redis是运行在内存的，当一个项目多户发起多次请求访问数据库时，访问速度很慢，如果将数据库的数据放在redis中用作缓存，那么用户访问redis中的数据即可。当数据库的数据变更时，同步一下redis中的数据即可。加快访问速度，提供系统的性能。</p><p>当使用用户较多时，多用户同时访问数据库，数据库的压力较大，可能承受不住，而运行在内存中的redis支持高并发，因此使用redis可以减轻数据库的压力，也可以提升系统性能。</p><p>redis属于分布式缓存，多实例公用一份缓存数据，缓存具有一致性。</p><h4 id="redis为什么访问速度快">redis为什么访问速度快</h4><p>redis运行在内存之中所以访问速度快。</p><p>redis使用的是单线程，不存在线程切换带来的性能消耗。</p><p>数据结构简单，有string，list，set，zset，hash五种数据结构。io采用多路复用方式。</p><h4 id="redis的应用场景">redis的应用场景</h4><p>用作计数器，在新闻中，对于热门新闻的点击，可以使用redis的string进行记录，速度快。</p><p>缓存，对于经常访问到的热点数据，可以同步到redis中，减轻数据库的压力。</p><p>存储会话信息，使用jwt的时候，可以用来存储jwt的唯一id，在登录逻辑中进行判断，注销token时删除redis中的id就行。</p><p>对于交集并集数据，查找共同好友或者笔记共同的分类，可以使用redis的set集合实现。</p><h4 id="redis的持久化">redis的持久化</h4><p>持久化就是将数据持久化到硬盘之中，防止宕机之后的数据丢失。redis提供了AOF和RDB两种数据持久化方式。</p><p>RDB是redis的默认的持久化方式，按照时间持久化数据，时间可在配置中自己定义，效率比较高。且持久化时主进程处理命令，子进程负责io操作，保证了redis的高性能。但是因为是按照时间进行持久化，会发生数据丢失。</p><p>AOF将Redis执行的每次写命令记录到单独的日志文件中，当重启Redis会重新将持久化的日志中文件恢复数据。AOF通过 append 模式写文件，即使中途服务器宕机，可以通过 redis-check-aof 工具解决数据一致性问题。数据安全，每进行一次 命令操作就记录到 aof 文件中一次。AOF的文件较大，且效率较低。</p><p>通常应该同时使用AOF和RDB两种持久化方式，因为AOF的持久化方式数据较为完整，但是使用RDB的持久化文件可以作为数据库的备份来使用，因为他恢复较快。</p><h4 id="redis过期键的删除策略">redis过期键的删除策略</h4><p>一般来说内存较大或者对内存的占用性能影响不大的情况下可以使用惰性过期，在访问key的时候在判断当前的key是否过期，如果过期的话就删除。</p><p>如果数据较多，会严重占用内存，考虑定期过期，每隔一段时间扫描key，然后清楚过期的key即可。</p><p>一般不使用定时过期，因为会浪费cpu资源，影响redis性能。</p><h4 id="redis的内存淘汰">redis的内存淘汰</h4><p>当redis中的数据满，而数据库的数据仍然在持续增加时。</p><p>如果系统的需求是当前redis中的数据已经满足使用，则不进行淘汰，不插入新的数据到redis中。</p><p>如果像新闻需要实时更新热门新闻的话，可以将当前内存中不常使用的key进行删除。</p><p>而类似于普通的用户信息，不存在优先级问题，也可以随机删除key。</p><h4 id="redis的内存优化">redis的内存优化</h4><p>对于redis，不应按照平常面向对象的习惯使用key-value的形式存储数据，占用的空间会很大。在redis中，hash占用的空间较小，所以应将信息存储到hash中。</p><h4 id="redis事务">redis事务</h4><p>事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。redis的事务也是如此。</p><p>redis使用multi事务开始，然后命令入队，然后exec执行。事务执行时服务端收到有EXEC、DISCARD、WATCH、MULTI之外的请求，将会把请求放入队列中排。</p><p>一般事务具有原子性，隔离性，一致性和持久性。redis的事务具有一致性和隔离性，使用持久化时，具有持久性。在redis中，命令的执行是原子性的，但是事务不是，也无法进行回滚。</p><h3 id="rabbitmq知识点">rabbitmq知识点</h3><h4 id="为什么使用MQ">为什么使用MQ</h4><p>可以进行异步处理，用户的请求需要多个系统写入数据，如果延迟过高，用户体验较差。使用MQ，我把请求放在mq里，让延迟快的优先反应并返回信息给用户，让其他系统订阅mq，取消息在保存到数据库即可。</p><p>解耦，当前系统产生的数据可能被其他多个系统使用，让其他系统请求，当前系统分发的话，有可能产生不一致问题，那么使用MQ把数据放到MQ里，谁使用谁订阅并且取数据即可。</p><p>流量削峰，对于那些某时刻会有大量请求的系统，使用MQ的话，可以将请求先放在MQ中，先由MQ处理，之后在慢慢交给后台，防止数据量过大，服务器直接奔溃。</p><p>对于电商，用户下单，没有付款的话，使用死信队列，使当前的订单超过半个小时自动关闭。</p><p>使用MQ的时候除了他优点，要非常注意数据一致性问题，即把MQ当成中间件，要确保后面的数据写入要同步完成。</p><h4 id="为什么使用rabbitMQ">为什么使用rabbitMQ</h4><p>rabbitmq对高并发的处理和适配比较好，所以一般使用这个，而且使用的公司比较多，社区的更新频繁，bug少。</p><h4 id="保证消息的顺序">保证消息的顺序</h4><p>通过MQ自身的实现的话可能会影响MQ的性能，所以可以在业务层面保证消息消费的顺序，或者使无序的消息消费顺序不影响系统的使用。</p><h4 id="保证消息的重复性">保证消息的重复性</h4><p>保证接收端的幂等性即可。可以使用日志文件记录消息的唯一id，消费信息后更新日志id，再此消费时判断一下当前的日志中是否存在该消息的id即可。</p><h4 id="消息的路由方式">消息的路由方式</h4><p>通过队列的路由键将队列绑定到对应的交换器上，消息到达交换器时，根据消息创建时携带的路由和交换器中队列的路由进行匹配即可。</p><h4 id="消息基于什么传输">消息基于什么传输</h4><p>由于 TCP 连接的创建和销毁开销较大，且并发数受系统资源限制，会造成性能瓶颈。RabbitMQ 使用信道的方式来传输数据。信道是建立在真实的 TCP 连接内的虚拟连接，且每条 TCP 连接上的信道数量没有限制。</p><h4 id="确保消息被消费">确保消息被消费</h4><p>将信道设置为confirm方式，发送方发送的消息携带唯一的id，接收方消费完成之后需要返回确认给发送方，发送方才可以删除消息。这个过程是异步的，不会影响发送方继续发送消息。如果没有接收到确认方的信息，接收方断开或者取消订阅，就把消息送给下一个接收方。如果没有断开也没有返回确认信息，发送方判断接收方忙且不在发送数据。</p><h4 id="如何确保消息的可靠传输">如何确保消息的可靠传输</h4><p>对于发送方来说除了信道设置confirm方式采用唯一id等待确认方式之外，还可以使用事务，如果出错，事务回滚确保数据的安全。</p><p>队列的话可以设置一下持久化，将数据保存到磁盘，数据丢失可以进行恢复。</p><p>接收方通过业务逻辑手动回复确认即可。</p><h4 id="如何解决MQ中的消息积压问题">如何解决MQ中的消息积压问题</h4><p>新建一个 topic模式(通配符的方式)，分区是原来的 10 倍，临时建立好原先 10 倍的队列 数量。然后写一个临时的分发数据的 consumer 程序，这个程序部署上去消费积压的数据，消费之后不做耗时的处理，直接均匀轮询写入临时建立好的 10 倍数量的 队列中。接着临时征用 10 倍的机器来部署 consumer，每一批 consumer 消费一个临时 queue 的数据。这种做法相当于是临时将 queue 资源和 consumer 资源扩大 10 倍，以正常的 10 倍速度来消费数据。等快速消费完积压数据之后，得恢复原先部署的架构，重新用原先的 consumer 机器来消费消息。</p><h3 id="mysql面试题">mysql面试题</h3><h4 id="数据库的三大范式">数据库的三大范式</h4><p>第一范式保证原子性，即当前字段不可在分割，当前字段不能由多条信息组成。</p><p>第二范式是不应存在联合主键，每条记录要有唯一性。</p><p>第三范式保证数据库的单挑数据的字段中不存在依赖关系，字段之间应保证独立。</p><h4 id="MySQL的binlog有有几种录入格式？分别有什么区别？">MySQL的binlog有有几种录入格式？分别有什么区别？</h4><p>binlog为mysql的二进制日志文件，记录数据库的操作语句，方便数据库进行主从复制时保证数据的一致性和产生宕机后的数据恢复问题。</p><p>binlog使用statement方式录入，会记录修改数据的sql语句，减少日志文件的大小。使用row方式录入，会记录表中每一行的改动，产生的日志文件较大，记录较全。mixed混合录入方式对于普通的操作语句使用statement方式录入，若无法使用statement，使用row方式录入。</p><h4 id="什么是索引？">什么是索引？</h4><p>索引相当于目录，建立索引可以方便数据的查找。索引是一种文件系统，占用物理空间，一般通过B树或者B+树来实现。</p><h4 id="索引的使用场景">索引的使用场景</h4><p>一般使用最多的是主键索引，通过主键id进行查询。新建的字段一般查询时都没有索引，当数据量较大时，可以考虑使用add index为字段添加索引来提高查询效率。</p><p>使用order by对数据库某个字段进行排序时，当字段没有索引的时候，系统会将所有的数据读入到内存中，再利用内部排序进行排序最后将每个部分进行合并，很大的浪费了性能。通过对排序字段添加索引，可以根据索引的顺序进行逐条读取数据。</p><p>建立所以可以提高连接查询的效率。</p><p>select和select *的区别，如果要查询的字段已经建立了索引，那么查询时就会根据索引查询，而不是访问原数据。所以推荐使用select加字段的方式，而select * 则会全表扫描。</p><h4 id="索引有哪几种类型">索引有哪几种类型</h4><p>使用最多的就是主键索引，唯一id，数据项不能重复且不能为空。</p><p>数据项不能重复且可以为空的为唯一索引。</p><p>数据项可以重复可以为空的为普通索引。</p><p>对于搜索引擎还有一种全文索引。</p><h4 id="索引的实现原理">索引的实现原理</h4><p>对字段添加索引，数据库会对添加索引的字段进行排序生成排序表，在排序表上记录数据的地址。对字段进行查询的时候会先找到排序表，在通过排序表中的数据地址获取数据。</p><h4 id="索引设计的原则">索引设计的原则</h4><p>如果你的查询条件中有&gt;,&lt;,between等条件，对于这些条件以后的字段不应设置索引，会失效，或者将带有这些条件的字段放在最后，因为mysql是默认向右匹配到这些条件就停止的。</p><p>建立索引用于提高查询效率，因此被频繁查询的字段可以添加索引，但是频繁更新的字段不应该建立索引。</p><p>对于已经有索引的表，添加新的字段索引的时候应有限扩展索引，即在当前的基础上扩展。</p><p>如果该列作为外键使用不应建立索引。</p><p>由于建立索引要进行排序，对于字段中的数据大量重复的情形或者字段较长的也不应该进行设置索引。设置短索引。</p><h4 id="创建索引的方式">创建索引的方式</h4><p>在创建表时添加索引。</p><p>已经表的基础上通过add index或者create index的方式创建索引。</p><h4 id="使用索引查询一定能提高查询的性能吗？为什么">使用索引查询一定能提高查询的性能吗？为什么</h4><p>索引需要空间来存储，也需要定期维护， 每当有记录在表中增减或索引列被修改时，索引本身也会被修改。 这意味着每条记录的INSERT，DELETE，UPDATE将为此多付出4，5 次的磁盘I/O。 因为索引需要额外的存储空间和处理，那些不必要的索引反而会使查询反应时间变慢。使用索引查询不一定能提高查询性能。</p><p>一般来说当你根据字段查询的数据为当前表的三分之一的时候性能提升较大。或者非唯一性索引进行查询性能提升也较大。</p><h4 id="对于百万级的数据的删除">对于百万级的数据的删除</h4><p>对于有着百万数据的表中的字段索引在删除数据前，应该先删除索引，删除索引后进行数据的删除。数据删除完毕之后重新创建索引较为安全。</p><h4 id="什么是聚簇索引？何时使用聚簇索引与非聚簇索引">什么是聚簇索引？何时使用聚簇索引与非聚簇索引</h4><p>聚簇索引就是将数据和索引放到一起，找到索引即找到了数据。</p><p>非聚簇索引数据和索引不在一起，优先将索引缓存到内存，查询数据先找到索引在读取磁盘找到数据。</p><h4 id="联合索引是什么？为什么需要注意联合索引中的顺序？">联合索引是什么？为什么需要注意联合索引中的顺序？</h4><p>联合索引是将多个字段的索引组合，联合索引是严格按照索引的排序顺序进行查询的，即先以第一个索引为基础排序，再以第二个排序。所以要严格按照联合索引的顺序使用。</p><h4 id="什么是脏读？幻读？不可重复读？">什么是脏读？幻读？不可重复读？</h4><p>脏读就是读到不该读的数据，A事务进行回滚前的数据被B事务读到了。</p><p>幻读就是没读全，A事务在插入数据前已经被B事务读了，A事务插入数据完成，B事务在读发现有一部分没读到。</p><p>不可重复读就是数据被别人动了，A事务进行逻辑处理的时候，B事务更新了数据，A事务使用的数据不是原来的。</p><h4 id="什么是事务的隔离级别？MySQL的默认隔离级别是什么？">什么是事务的隔离级别？MySQL的默认隔离级别是什么？</h4><p>数据库定义的隔离级别阻止脏读幻读和不可重复读的发生。</p><p>read-uncommited读取未提交，最低的隔离级别，容易导致脏读幻读和不可重复读。</p><p>read-commited读取已提交，读取事务已经提交的数据，防止脏读。</p><p>repeatable-read可重复读，对同一个字段的读取结果是一致的，除非自身的事务更新了数据，可以防止脏读和不可重复读。</p><p>serializable：可串行化，满足事务的四个性质，最高隔离级别，可以防止脏读，幻读和不可重复读。</p><p>mysql的默认级别是可重复读，在使用innoDB引擎的时候分布式事务使用可串行化。</p><h4 id="隔离级别与锁的关系">隔离级别与锁的关系</h4><p>read-uncommited读取未提交读操作不使用共享锁。</p><p>read-commited读取已提交，读操作是使用共享锁，读操作完成之后释放锁。</p><p>repeatable-read可重复读，读操作使用共享锁，读操作完成之后不释放锁，事务完成之后在释放锁。</p><p>serializable对于键一直保持锁，直到事务结束。</p><h4 id="按照锁的粒度分数据库锁有哪些？锁机制与InnoDB锁算法">按照锁的粒度分数据库锁有哪些？锁机制与InnoDB锁算法</h4><p>数据库的锁分为行级锁，表级锁和页级锁。</p><p>其中mysql的MyISAM引擎使用表级锁。</p><p>InnoDB使用行级锁和表级锁，默认使用行级锁。</p><p>行级锁是粒度最细的锁，对行进行加锁，减少数据库操作的冲突，但是因为是对每行加锁，所以开销较大，也较为安全。</p><p>表级锁是对整张表加锁，粒度最大，发生的概率也最大，消耗较低。</p><p>页级锁兼容上面两种，做到中消耗，中冲突，每次锁定相邻的一组记录。</p><h4 id="从锁的类别上分MySQL都有哪些锁呢？">从锁的类别上分MySQL都有哪些锁呢？</h4><p>锁的类别区分mysql有共享锁和排他锁。</p><p>共享锁即读操作时使用的锁，数据可以被多个语句读，可以被加多个共享锁。</p><p>排他锁是写操作时使用的锁，只能加一个，和其他的所有锁互斥。</p><h4 id="MySQL中InnoDB引擎的行锁是怎么实现的？">MySQL中InnoDB引擎的行锁是怎么实现的？</h4><p>使用索引来实现行锁。使用for update</p><p>select * from tab_with_index where id = 1 for update;</p><p>且for update查询的字段要有索引，否则会使用表级锁。</p><h4 id="数据库的乐观锁和悲观锁是什么？">数据库的乐观锁和悲观锁是什么？</h4><p>在数据库操作并发时使用悲观锁和乐观锁两种手段确保数据安全。</p><p>悲观锁是在事务查询数据的时候就加锁，而乐观锁是在事务最后修改数据的时候在加锁。</p><p>当读操作角度的时候使用乐观锁可以提高系统性能。</p><p>而在写操作多的时候保证数据的安全使用悲观锁。</p><h4 id="为什么要使用视图？什么是视图？">为什么要使用视图？什么是视图？</h4><p>视图和表相似但是是一种虚拟表，在进行查询的时候根据从基本表即实表中查询的数据动态生成一个含有这些数据的视图。</p><p>在使用数据库时，只是用某几张表中的部分数据，可以使用视图，确保其他数据的安全性。</p><h4 id="视图有哪些特点？">视图有哪些特点？</h4><p>视图是一种虚表。</p><p>视图中的内容可以由来自不同的实表组合生成。</p><p>对于查询视图的操作不会影响的原表。</p><p>对于数据更新的操作则会更新原表，如果视图是由多个实表中的数据组合，不允许进行数据更改。</p><h4 id="视图的使用场景有哪些？">视图的使用场景有哪些？</h4><p>所使用到的数据来自多个表，且是多个表中的部分字段。</p><p>用户权限细分的时候，只给有具体权限的用户展示具体的数据。</p><p>重用sql语句时，多个业务逻辑都用到当前的sql语句查询的结果。</p><p>由于要生成视图，所以性能上会有所消耗。</p><h4 id="什么是存储过程？有哪些优缺点？">什么是存储过程？有哪些优缺点？</h4><p>存储过程是预编译的sql语句，可以进行模块化设计，使用的时候直接调用存储过程即可。</p><p>存储过程是预编译的且存在于数据库中，所以速度较快。同时重用性可以减少开发人员的工作量。可以进行权限的划分。</p><p>使用存储过程之后大量的存储过程维护较为麻烦。</p><h4 id="什么是触发器？触发器的使用场景有哪些？">什么是触发器？触发器的使用场景有哪些？</h4><p>触发器即触发某个操作时自动执行的代码。</p><p>可以进行级联更改。</p><p>由当前数据生成其他数据的相关信息。</p><h4 id="关联查询">关联查询</h4><p>内连接inner join</p><p>外连接，left join，左连接以左表为基础，右连接以右表为基础，没有的字段信息使用null。</p><h4 id="mysql中-in-和-exists-区别">mysql中 in 和 exists 区别</h4><p>in语句将外表和内表做hash连接，exists对外表进行loop循环。每次循环过程中在对内表进行查询。</p><p>在查询的表大小差不多时，in和exists的效率相同。</p><p>当查询的表大小差别大时，子查询的表为大表使用exists,小表使用in</p><p>使用not语句，not exists一定比not in效率高，因为not exists可以使用索引。</p><h4 id="varchar与char的区别">varchar与char的区别</h4><p>char的长度是固定的，为255，空白用空格填充，查询的速度较快。</p><p>varchar的长度是可变的，数据多长，varchar可以设置多长，不会浪费空间。</p><h4 id="如何定位及优化SQL语句的性能问题？创建的索引有没有被使用到-或者说怎么才可以知道这条语句运行很慢的原因？">如何定位及优化SQL语句的性能问题？创建的索引有没有被使用到?或者说怎么才可以知道这条语句运行很慢的原因？</h4><p>使用explain命令查看语句的执行计划，通过type判断当前运行的语句是否使用了索引。eq_ref是在join中使用了索引关联，ref使用了非唯一索引，index_subquery在子查询中使用非唯一索引，index为遍历索引，ALL为全表扫描。</p><p>如果possible_keys为null应该考虑sql优化，因为该字段显示查询时所查询字段的索引。以及key字段显示当前使用的索引。</p><h4 id="SQL的生命周期？">SQL的生命周期？</h4><p>应用服务器和数据库服务器建立连接，数据库服务器获取应用服务器的sql语句，生成执行计划，查询数据并读取到内存进行逻辑处理，最后将数据返回给应用服务器，断开连接，释放资源。</p><h4 id="大表数据查询，怎么优化">大表数据查询，怎么优化</h4><p>使用索引或者使用缓存技术。</p><h4 id="超大分页怎么处理？">超大分页怎么处理？</h4><p>使用缓存或者使用带索引的字段进行子查询。</p><h4 id="为什么要尽量设定一个主键？">为什么要尽量设定一个主键？</h4><p>主键是一张表中一行数据唯一性的保证。在增删改查的时候，使用主键更快且能保证数据的安全和隐蔽。</p><h4 id="主键使用自增ID还是UUID？">主键使用自增ID还是UUID？</h4><p>推荐使用自增id，因为mysql使用的算法是B+树，叶子节点上按照顺序存放主键索引，若是自增id，插入数据进行往下排列即可。如果是uuid，若新的id与已有的id大小不一致会导致数据的移动，产生内存碎片消耗性能。</p><h4 id="优化查询过程中的数据访问">优化查询过程中的数据访问</h4><p>避免查询过多的不必要的数据，可以使用limit字段。尽量避免使用select *而应该使用select具体字段，尤其是在多表关联查询的时候更应该指定列名。对于热点数据的查询，应优先考虑使用缓存。</p><h4 id="优化特定类型的查询语句">优化特定类型的查询语句</h4><p>使用count(*)会直接统计列树，不建议使用count(列名)。当对count没有确切的需求是可以用explain近似值代替count。使用limit可以记录上一次查询的最大id。</p><h4 id="优化WHERE子句">优化WHERE子句</h4><p>在where子句中应避免使用null，!=和大于小于操作符。避免使用in，not in，避免使用函数，参数和表达式求值等。都会导致全表扫描。</p><h4 id="MySQL数据库cpu飙升到500-的话他怎么处理？">MySQL数据库cpu飙升到500%的话他怎么处理？</h4><p>查看当前的进程判断是否是mysqld的进程导致的cpu增加。如果是使用show processlist查看sql语句的性能消耗，找到消耗大的sql语句查看执行计划，进行sql优化。</p><h3 id="springboot知识点">springboot知识点</h3><h4 id="Spring-Boot-的核心注解是哪个？它主要由哪几个注解组成的？">Spring Boot 的核心注解是哪个？它主要由哪几个注解组成的？</h4><p>springboot的核心注解是springbootApplication，它包含三个注解分别是springbootConfiguration，EnableAutoConfiguration和ComponentScan。其中SpringbootConfiguration用于实现配置文件，EnableAutoConfiguration用于实现自动化配置，ComponentScan实现组件扫描。</p><h4 id="什么是-JavaConfig？">什么是 JavaConfig？</h4><p>javaconfig提供配置容器的纯java方法，从而避免使用繁杂的xml配置。可以直接使用类的方式来进行容器配置。通过泛型按照类型的方式来配置更加安全，便于重构。</p><h4 id="Spring-Boot-是否可以使用-XML-配置">Spring Boot 是否可以使用 XML 配置 ?</h4><p>可以使用@importResource注解来使用xml配置</p><h3 id="mybatis知识">mybatis知识</h3><h4 id="为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？">为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？</h4><p>全自动ORM hibernate可以根据对象关系映射获取数据，而mybatis半自动映射需要自己书写sql语句。</p><h4 id="mybatis的优势">mybatis的优势</h4><p>mybatis使用线程池，使用的时候去线程池中取即可，避免了创建释放导致的资源消耗。</p><p>mybatis将java代码和sql语句分离开来，配置在mapper.xml中，对系统进行解耦。</p><p>mybatis可以将类对象直接映射到sql语句，反之根据返回类型的设置可以将数据映射到类。</p><h4 id="MyBatis的工作原理">MyBatis的工作原理</h4><p>框架启动加载mybatis的配置文件，读取项目中的对应的mapper.xml中的sql语句。构造会话工厂sqlsessionfactory，创建sqlsession会话信息。使用exec执行器创建mappedstatement对象，mapped statement读取传入的参数，并将返回的数据映射到类对象。</p><h4 id="为什么需要预编译">为什么需要预编译</h4><p>预编译的sql语句在数据库拿到之后可以直接执行，减少数据库对复杂sql语句编译的消耗。</p><p>对于预编译产生的statement对象可以重复利用从而减少开销。</p><p>使用预编译可以防止sql注入。</p><h4 id="Mybatis都有哪些Executor执行器？它们之间的区别是什么？">Mybatis都有哪些Executor执行器？它们之间的区别是什么？</h4><p>mybatis有三种执行器，simple，reuse和batch</p><p>simple每执行一次查询或者更新创建一个statement对象，使用完后关闭。</p><p>reuse创建statement对象后，使用完不关闭，放入Map中存储进行重复使用。</p><p>batch执行更新时使用批处理，将所有sql添加到批处理之后统一执行。</p><h4 id="Mybatis中如何指定使用哪一种Executor执行器？">Mybatis中如何指定使用哪一种Executor执行器？</h4><p>可以在mybatis的配置文件中设置执行器。也可以在创建sqlsessionfactory工厂时将执行器的类型作为参数指定。</p><h4 id="Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？">Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？</h4><p>在mybatis中对于association和collection是支持延迟加载的，可以在配置文件中通过lazyLoadingEnable开启延迟加载。</p><p>使用cglib创建代理对象，当进行方法调用的时候发现值为空时，根据实现保存的sql查询到当前为空的值并进行赋值，然后在进行方法调用。</p><h4 id="和-的区别">#{}和${}的区别</h4><p>#{}会对sql语句进行预处理可以防止sql注入。而${}是直接将字符串进行替换。</p><h4 id="模糊查询like语句该怎么写">模糊查询like语句该怎么写</h4><p>一般用concat(’%’,#{},’%’)的形式拼接查询。</p><p>也可以在sql中使用bind标签，指定name和value，其中value进行组合查询字段，sql语句中使用bind标签定义的name。</p><h4 id="在mapper中如何传递多个参数">在mapper中如何传递多个参数</h4><p>可以使用占位符的方式，即0，1</p><p>可以在dao层的接口中使用Param注解，指定传入参数的名称</p><p>可以封装map，将map中的key与字段进行直接映射。</p><p>使用javabean，通过parameterType传入指定的类的地址进行类和字段的映射。</p><h4 id="Mybatis如何执行批量操作">Mybatis如何执行批量操作</h4><p>使用foreach进行迭代处理。</p><h4 id="如何获取生成的主键">如何获取生成的主键</h4><p>开启useGeneratedKeys标签，使用keyProperty指定返回的主键字段名称。</p><h4 id="当实体类中的属性名和表中的字段名不一样-，怎么办">当实体类中的属性名和表中的字段名不一样 ，怎么办</h4><p>在sql语句中可以定义别名。</p><p>使用resultMap定义映射关系，在sql标签中指定定义的resultMap进行映射。</p><h4 id="什么是MyBatis的接口绑定？有哪些实现方式？">什么是MyBatis的接口绑定？有哪些实现方式？</h4><p>将接口和sql语句绑定，使用接口即可调用sql进行数据查询。</p><p>使用注解的方式来绑定，但是耦合度太高。</p><p>一般使用namespace指定dao类的方式进行接口绑定。</p><h4 id="使用MyBatis的mapper接口调用时有哪些要求？">使用MyBatis的mapper接口调用时有哪些要求？</h4><p>方法名和sqlid要相同。</p><p>传入参数和返回参数的类型要在sql中通过parameterType和resultType进行定义。</p><h4 id="Mybatis映射文件中，如果A标签通过include引用了B标签的内容，请问，B标签能否定义在A标签的后面，还是说必须定义在A标签的前面？">Mybatis映射文件中，如果A标签通过include引用了B标签的内容，请问，B标签能否定义在A标签的后面，还是说必须定义在A标签的前面？</h4><p>顺序没有关系，当a标签调用b标签时，若a标签解析时发现b不存在，则会暂停a标签解析，解析需要的标签，需要的标签解析完毕之后，在解析a标签。</p><h4 id="MyBatis实现一对一，一对多有几种方式，怎么操作的？">MyBatis实现一对一，一对多有几种方式，怎么操作的？</h4><p>通过association标签实现一对一，通过collection标签实现一对多。</p><h3 id="Spring知识点">Spring知识点</h3><h4 id="版本迭代">版本迭代</h4><p>4.x 增加了lamda表达式，同时为了适配restfui接口格式，添加了restController接口。</p><p>5.x支持函数和响应式编程</p><h4 id="spring核心">spring核心</h4><p>spring核心包括IOC，AOP和DI</p><p>其中IOC是控制反转，spring框架起到了中介的作用，程序员只需要编程自己的需求，相应的提供由spring框架来完成。实现了可插拔式接口，降低了代码的耦合度。</p><p>为了提升组件重用的概率，使用DI，容器在系统运行期间进行依赖注入。通过DI来实现spring的IOC的功能。</p><p>常见的注入模式一般为setter注入和构造方法注入和注解注入。</p><p>使用setter方式注入一般使用xml的形式，使用bean标签进行类的注入。</p><p>使用注解注入一般使用autowired，service等注解实现。</p><p>aop是切面编程，一般使用注解的方式after，before，pointcut等注解实现，使用springboot之后进行日志记录或者接口防刷等，自定义注解后，在具体的方法上使用自己的注解即可。</p><h4 id="Component-和-Bean-有什么区别？">@Component 和 @Bean 有什么区别？</h4><p>@Component注解主要运用于类上面，使用SomponentScan进行扫描并注册到spring容器之中，而@bean主要运用于方法，标志某个类的实例，需要时在使用。</p><h4 id="Spring-中-bean-的作用域有几种类型？">Spring 中 bean 的作用域有几种类型？</h4><p>单例模式整个应用程序只创建一个bean。原型模式，每次注入都会创建一个bean。会话模式，每次会话创建一个bean，但只在web系统中有效。请求模式，每次请求创建一个bean，只在web系统中有效。</p><h4 id="spring实现事务的方式">spring实现事务的方式</h4><p>使用编程式或者注解的方法。一般使用主机的方法使用事务。声明式事务，底层是建立在 Spring AOP 的基础上，在方式执行前后进行拦截，并在目标方法开始执行前创建新事务或加入一个已存在事务，最后在目标方法执行完后根据情况提交或者回滚事务。<br>声明式事务的优点：不需要编程，减少了代码的耦合，在配置文件中配置并在目标方法上添加 @Transactional 注解来实现。</p><h4 id="Spring-声明式事务无效可能的原因有哪些？">Spring 声明式事务无效可能的原因有哪些？</h4><p>mysql使用MyISAM引擎。</p><p>注解只支持public方法。</p><h4 id="Spring-中的-Bean-是线程安全的吗？">Spring 中的 Bean 是线程安全的吗？</h4><p>bean默认是单例模式，所以是非线程安全的。可以设置为原型模式，每次注入创建一个bean可以保证线程安全。</p><h4 id="Spring-中都是用了哪些设计模式？">Spring 中都是用了哪些设计模式？</h4><p>在listen中进行监听，动作触发进行通知使用了观察者模式。</p><p>通过beanFactory或者ApplicationContext创建bean使用的是工厂模式。</p><p>bean的单例或者原型使用单例原型模式。</p><p>在创建代理类时，根据代理的是不是接口选择不同的代理方式使用的是策略模式。</p><h3 id="SpringMVC知识点">SpringMVC知识点</h3><h4 id="Spring-MVC的主要组件？">Spring MVC的主要组件？</h4><p>DispatcherServlet前端控制器，主要用于接收请求和响应结果。</p><p>HandlerMapping映射器，根据对应的映射路径找到handler。</p><p>HandlerAdapter适配器，用于执行handler。</p><p>handler程序员开发，相当于方法。</p><p>ViewResolver视图解析器，用于解析视图。</p><p>View视图，即程序员编写的前端页面。</p><h4 id="请描述Spring-MVC的工作流程？描述一下-DispatcherServlet-的工作流程？">请描述Spring MVC的工作流程？描述一下 DispatcherServlet 的工作流程？</h4><p>用户发起请求至DispatcherServlet，DispatcherServlet拿到请求之后调用handlerMapping映射器请求获取handler。HandlerMapping根据url映射地址找到handler后生成处理器对象返回给DispatcherServlet。DispatcherServlet拿到对象之后调用adapter适配器，适配器调用具体的handler处理逻辑，最终返回modelandView。DispatcherServlet将ModelAndView传给ViewResolver视图解析器解析。解析完成后送给view页面。DispatcherServlet渲染页面，将数据显示到视图中，最终响应给用户。</p><h4 id="MVC是什么？MVC设计模式的好处有哪些">MVC是什么？MVC设计模式的好处有哪些</h4><p>MVC是一种设计模式，采用三层架构的方式。将系统进行解耦，提高开发效率。</p><h4 id="Spring-MVC常用的注解有哪些？">Spring MVC常用的注解有哪些？</h4><p>@RequestMapping用于映射url和类中的方法。</p><p>@RequestBody将http请求中接收到的json数据转换为系统中的类。</p><p>@ResponseBody将返回的类数据转换为json返回给前端。</p><h4 id="Controller注解的作用">@Controller注解的作用</h4><p>@Controller负责接收DispatcherServlet的请求，然后交由对应的方法处理，最终再把返回的ModelAndView交给视图。在类上标注注解并在配置文件中加载对应的controller类的bean对象即可。</p><h4 id="Spring-MVC怎么样设定重定向和转发的？">Spring MVC怎么样设定重定向和转发的？</h4><p>转发使用forward，不改变页面路径。而重定向使用redirect，改变页面url。</p><h4 id="如何解决POST请求中文乱码问题，GET的又如何处理呢？">如何解决POST请求中文乱码问题，GET的又如何处理呢？</h4><p>POST请求在web.xml文件中配置一下CharacterEncodeingFilter的属性为utf-8即可。</p><p>GET请求修改一下tomcat服务器的配置文件。</p><h3 id="javaSE">javaSE</h3><h4 id="JVM、JRE和JDK的关系">JVM、JRE和JDK的关系</h4><p>jvm是虚拟机，java程序是运行在虚拟机上的，不同的平台有不同的虚拟机，因此java是可以跨平台的。</p><p>jre是虚拟机和java程序运行的必不可少的类库和各种包。</p><p>jdk是程序员使用的开发工具，包括jre和编译工具，打包工具等。</p><h4 id="什么是字节码？采用字节码的最大好处是什么">什么是字节码？采用字节码的最大好处是什么</h4><p>字节码是java代码通过虚拟机编译后产生的只面向虚拟机的.class文件。</p><p>使用字节码，由于字节码是面向虚拟机的，因此移植的时候安装具体的虚拟机即可，不用考虑平台。使用字节码，虚拟机解释语言的效率也比较高。</p><h4 id="Java有哪些数据类型">Java有哪些数据类型</h4><p>byte 1字节，int 4字节，boolean 一字节，double 8字节，long 8字节，char 2字节，short 2字节。float 4字节。</p><p>对应的包装类，Byte，Integer，Boolean，Double，Long，Character，Short，Float</p><h4 id="switch-是否能作用在-byte-上，是否能作用在-long-上，是否能作用在-String-上">switch 是否能作用在 byte 上，是否能作用在 long 上，是否能作用在 String 上</h4><p>java7之后switch是可以支持String的，byte是一只支持的。long是不支持的。</p><h4 id="用最有效率的方法计算-2-乘以-8">用最有效率的方法计算 2 乘以 8</h4><p>a&lt;&lt;b，&lt;&lt;相当于乘，&gt;&gt;相当于除，a为底数，b为次方。</p><h4 id="Math-round-11-5-等于多少？Math-round-11-5-等于多少">Math.round(11.5) 等于多少？Math.round(-11.5)等于多少</h4><p>round函数对于正数来讲向上取整，对于负数来说也是向上取整。</p><h4 id="short-s1-1-s1-s1-1-有错吗-short-s1-1-s1-1-有错吗">short s1 = 1; s1 = s1 + 1;有错吗?short s1 = 1; s1 += 1;有错吗</h4><p>+=符号会自动进行转型，不会发生错误。</p><h4 id="访问修饰符-public-private-protected-以及不写（默认）时的区别">访问修饰符 public,private,protected,以及不写（默认）时的区别</h4><p>public是同包下和其他包下，private是本类，protect是本包，子类。default是本包。</p><h4 id="和-的区别-2">&amp;和&amp;&amp;的区别</h4><p>和| ||相同，&amp;只是前一个成功，后一个就忽略。而&amp;&amp;是双方必须都成功。</p><h4 id="final-有什么用？">final 有什么用？</h4><p>final修饰变量无法更改。修饰方法无法重写。修饰类无法继承。</p><p>final修饰变量时，若变量是引用变量，地址无法更改，而内容可以更改。</p><h4 id="final-finally-finalize区别">final finally finalize区别</h4><p>finally用于异常捕获，无论异常是否发生都会执行，且在方法return之前执行。finalize是Object的方法，所有的类都继承，如果实现了该方法，在第一次垃圾回收该对象时，先调用该方法。第二次则进行标记直接回收。</p><h4 id="static存在的主要意义">static存在的主要意义</h4><p>即便没有创建对象，也可以使用类名调用变量和方法。</p><p>使用静态代码块来优化性能，在类中而不是方法中是无法进行变量运算的，可以使用静态代码块。</p><h4 id="static的独特之处">static的独特之处</h4><p>不属于创建的实例对象，而是被类的实例对象共享。</p><p>共享对象值的变化是通用的。</p><h4 id="break-continue-return-的区别及作用">break ,continue ,return 的区别及作用</h4><p>break是跳出当前的循环体。continue是跳出当前循环，进行下一轮。return是返回，屏蔽return以后的语句。</p><h4 id="抽象类和接口的对比">抽象类和接口的对比</h4><p>抽象类和接口都不能被实例化。其中包括的方法子类必须实现。</p><p>接口没有构造函数。抽象类的方法没有方法体。</p><p>接口只能被定义为public，抽象类只能继承一个。</p><p>接口的字段默认都是static和final的。</p><h4 id="在Java中定义一个不做事且没有参数的构造方法的作用">在Java中定义一个不做事且没有参数的构造方法的作用</h4><p>当调用子类的时候，子类没有使用super来调用父类的构造方法，就会默认调用父类的无参构造器。而如果父类没有无参构造器，则编译错误。</p><h4 id="内部类">内部类</h4><p>内部类为静态内部类，成员内部类，局部内部类和匿名内部类</p><p>静态内部类是类中的静态类，静态内部类无法访问外部的非静态变量。成员内部类是类内部定义在成员位置上的非静态类，成员内部类可以访问外部的静态和非静态变量，私有和非私有变量。局部内部类是定义在方法中的内部类，可以访问外部的所有方法和所有变量。匿名内部类是没有名字的内部类，首先匿名内部类实现接口或者继承一个类，匿名内部类中不能定义静态方法和静态变量，匿名内部类用到的外部参数需要设置为final类型。</p><h4 id="匿名内部类使用参数为什么要设置为final">匿名内部类使用参数为什么要设置为final</h4><p>在类中定义的成员变量存储在栈中，当方法销毁时会销毁成员变量，而匿名内部类仍然保有对成员变量的引用，因此如果不把变量设置为final，则会被销毁，匿名内部类会出错。</p><h4 id="重写和重载">重写和重载</h4><p>父类的构造函数无法继承因此无法被重写，可以被重载。重载意味着方法名相同，其他可以不同。而重写方法名相同，参数列表相同。返回值小于父类，可见性大于父类。</p><h4 id="和-equals-的区别是什么">== 和 equals 的区别是什么</h4><p>==对于对象的判断是判断引用地址，对于基本变量的判断是判断值。equals判断的是变量的值。</p><p>对于String类型的数据使用equals进行比较，由于String的equals方法被重写过，因此比较的是String的值。在创建String时，若在常量池中存在当前的字符串，则直接引用，否则重新创建对象。</p><h4 id="hashCode-与-equals">hashCode 与 equals</h4><p>hashcode是数据存储的索引，存储数据时根据hashcode的值进行存储，若存在相同的值，则不存，若hashcode计算相同，值不相同则发生冲突在进行散列。</p><p>两个对象相等，则hashcode一定相等。若hashcode相等，则两个对象不一定相等。</p><p>hashcode是对堆上的对象产生独特值，若不重写，则两个class类永远不会相等。</p><h4 id="对象的相等与指向他们的引用相等，两者有什么不同？">对象的相等与指向他们的引用相等，两者有什么不同？</h4><p>对象的相等指值的相等。而引用相等，意味着所在的内存地址相等。</p><h4 id="值传递">值传递</h4><p>java中只存在值传递。当一个基本数据变量通过参数使用时，参数只是一份原先数据的拷贝，对于其他方法中对变量的操作不会影响到原变量。当对象引用作为参数传递时，方法中对参数的更改会更改原对象的相关数据。</p><h4 id="java-中-IO-流分为几种">java 中 IO 流分为几种?</h4><p>输入输出流，字节字符流</p><h4 id="什么是反射机制？">什么是反射机制？</h4><p>反射即在程序运行期间动态的获取当前类的属性和方法。可以使用指定位置或者forClassName指定类名的方式获取对应的属性和方法。</p><h4 id="String真的是不可变的吗？">String真的是不可变的吗？</h4><p>不可变，String是用final修饰的无法被继承，底层使用的是char型的数组。</p><h4 id="在使用-HashMap-的时候，用-String-做-key-有什么好处？">在使用 HashMap 的时候，用 String 做 key 有什么好处？</h4><p>String是不可变的，因此使用String作为key得到的hashcode被缓存后不需要再此计算。</p><h4 id="Integer-a-127-与-Integer-b-127相等吗">Integer a= 127 与 Integer b = 127相等吗</h4><p>当int型变量在-128到127之间时，会在常量池中调用已有的变量值。当超过这个范围，会创建新的对象。</p><h4 id="String和StringBuffer、StringBuilder的区别是什么？">String和StringBuffer、StringBuilder的区别是什么？</h4><p>当字符串使用较多且不存在多线程的时候建议使用StringBuilder，存在缓冲区，减少了String频繁的性能消耗。使用多线程下使用StringBuffer，StringBuffer是线程安全的。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Boot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>opencv学习笔记一</title>
      <link href="/2021/03/29/opencv-xue-xi-bi-ji-yi/"/>
      <url>/2021/03/29/opencv-xue-xi-bi-ji-yi/</url>
      
        <content type="html"><![CDATA[<h3 id="opencv学习笔记一">opencv学习笔记一</h3><h4 id="opencv模块">opencv模块</h4><p>core：实现了最核心的数据结构及其基本运算，如绘图函数，数组操作相关函数等。</p><p>highgui：实现了视频与图像的读取，显示，存储等接口</p><p>imgproc：实现了图像处理的基础方法，包括图像滤波，图像的几何变换，平滑，阈值分割，形态学处理，边缘检测，目标检测，运动分析和对象跟踪等等。</p><p>features2d：用于提取图像特征以及特征匹配，nonfree模块实现了一些专利算法，如sift特征。<br>objectect：实现了一些目标检测的功能，经典的基于haar，LBP特征的人脸检测，基于HOG的行人，汽车等目标检测，分类器使用Cascade Classification(级联分类)和Latent SVM等。<br>stitching：实现了图像拼接功能。<br>FLANN：包含快速近似最近邻搜索FLANN和聚类Clustering算法<br>ml：机器学习模块(SVM，决策树，Boosting等等)<br>photo：包含图像修复和图像去噪两部分<br>video：针对视频处理，如背景分离，前景检测，对象跟踪等。<br>calib3d：即Calibration3D，这个模块主要是相机校准和三维重建相关的内容。包含了基本的多视角几何算法，单个立体摄像头标定，物体姿态估计，立体相似性算法，3D信息的重建等等。<br>G-API：包含超高效的图像处理pipline引擎</p><h4 id="图像的基本操作">图像的基本操作</h4><h5 id="读取图像">读取图像</h5><p>cv.imread(var1,var2)<br>var1为读取图像的路径<br>var2：cv.IMREAD*COLOR：以彩色模式加载图像，任何图像的透明度都将被忽略。这是默认参数。var2为1<br>cv.IMREAD*GRAYSCALE：以灰度模式加载图像。var2为0<br>cv.IMREAD_UNCHANGED：包括alpha通道的加载图像模式。var2为-1</p><h5 id="显示图像">显示图像</h5><p>cv.imshow(var1,var2)<br>var1：显示图像的窗口名称，以字符串类型表示<br>var2：要加载的图像的代理对象<br>注意：在调用显示图像的API后，要调用cv.waitKey(var)给图像绘制留下时间，否则窗口会出现无响应情况，并且图像无法显示出来。</p><p>plt.imshow(img,<a href="http://camp=plt.cm" target="_blank" rel="noopener">camp=plt.cm</a>.) cmap即colormaps,图谱 plt.cm是matplotlib库中内置的色彩映射函数 <a href="http://plt.cm" target="_blank" rel="noopener">plt.cm</a>.[色彩](’[数据集]’)即对[数据集]应用[色彩]<br>plt.show()<br><img src="http://dingdm.online/%E6%88%AA%E5%B1%8F2021-03-29%20%E4%B8%8A%E5%8D%8810.36.35.png" alt=""><br>及其他色彩表</p><h5 id="保存图像">保存图像</h5><p>cv.imwrite(var1,var2)<br>var1：图片保存的路径<br>var2：保存图像的代理对象</p><pre class=" language-language-python"><code class="language-language-python">import cv2 as cvimport matplotlib.pyplot as pltimg = cv.imread('/Users/dinggongcheng/Downloads/me.JPG', 0)#cv.imshow('image', img)#cv.waitKey(0)#cv.destroyAllWindows()#cv.waitKey(1)plt.imshow(img, cmap=plt.cm.gray)plt.show()</code></pre><p><img src="http://dingdm.online/%E6%88%AA%E5%B1%8F2021-03-29%20%E4%B8%8A%E5%8D%8810.42.37.png" alt=""></p><h4 id="绘制几何图形">绘制几何图形</h4><h5 id="绘制直线">绘制直线</h5><p>cv.line(img,start,end,color,thickness)<br>img：要绘制直线的图像<br>start，end：直线的起点和终点<br>color：线条的颜色<br>thickness：线条宽度</p><h5 id="绘制圆形">绘制圆形</h5><p>cv.circle(img,centerpoint,r,color,thickness)<br>img：要绘制图形的图像<br>centerpoint，r：圆心和半径<br>color：线条的颜色<br>thickness：线条宽度，为-1时生成闭合图案并填充颜色</p><h5 id="绘制矩形">绘制矩形</h5><p>cv.rectangle(img,leftupper,rightdown,color,thickness)<br>img：要绘制矩形的图像<br>leftupper，rightdown：矩形的左上角和右下角坐标<br>color：线条的颜色<br>thickness：线条宽度</p><h5 id="向图像中添加文字">向图像中添加文字</h5><p>cv.putText(img,text,station,font,fontsize,color,thickness,cv.LINE_AA)<br>img：图像<br>text：要写入的文本数据<br>station：文本的放置位置<br>font：字体<br>fontsize：字体大小</p><pre class=" language-language-python"><code class="language-language-python"># author:dinggc# date:2021/3/29 上午10:54import numpy as npimport cv2 as cvimport matplotlib.pyplot as plt# 创建一个空白的图像img = np.zeros((512, 512, 3), np.uint8)# 绘制图形cv.line(img, (0, 0), (511, 511), (255, 0, 0), 5)cv.rectangle(img, (384, 0), (510, 128), (0, 255, 0), 3)cv.circle(img, (447, 63), 63, (0, 0, 255), -1)font = cv.FONT_HERSHEY_SIMPLEXcv.putText(img, 'OpenCV', (10, 500), font, 4, (255, 255, 255), 2, cv.LINE_AA)# 图像展示plt.imshow(img[:, :, ::-1])plt.title('匹配结果'), plt.xticks([]), plt.yticks([])plt.show()</code></pre><p><img src="http://dingdm.online/%E6%88%AA%E5%B1%8F2021-03-29%20%E4%B8%8A%E5%8D%8811.02.51.png" alt=""></p><h4 id="获取并修改图像中的像素点">获取并修改图像中的像素点</h4><p>可以通过行和列的坐标值获取该像素点的像素值。对于BGR图像，它返回一个蓝，绿，红值的数组。对于灰度图像，仅返回相应的强度值。使用相同的方法对像素值进行修改。</p><pre class=" language-language-python"><code class="language-language-python">img = np.zeros((256, 256, 3), np.uint8)# 获取某个像素点的值px = img[100, 100]print(px)# 仅获取蓝色通道的强度值blue = img[100, 100, 0]print(blue)# 修改某个位置的像素值img[100, 100] = [255, 255, 255]plt.imshow(img[:, :, ::-1])plt.show()</code></pre><h4 id="获取图像的属性">获取图像的属性</h4><p>图像属性包括行数，列数和通道数，图像数据类型，像素数等。</p><table><thead><tr><th>属性</th><th>API</th></tr></thead><tbody><tr><td>形状</td><td>img.shape</td></tr><tr><td>图像大小</td><td>img.size</td></tr><tr><td>数据类型</td><td>img.dtype</td></tr></tbody></table><h4 id="图像通道的拆分与合并">图像通道的拆分与合并</h4><p>有时需要在B，G，R通道图像上单独工作。在这种情况下，需要将BGR图像分割为单个通道。或者在其他情况下，可能需要将这些单独的通道合并到BGR图像。</p><pre class=" language-language-python"><code class="language-language-python"># 通道拆分b,g,r = cv.split(img)# 通道合并img = cv.merge((b,g,r))</code></pre><h4 id="色彩空间的改变">色彩空间的改变</h4><p>cv.cvtColor(input_image, flag)<br>input_images：进行颜色空间转换的图像<br>flag：转换类型<br>cv.COLOR_BGR2GRAY：BGR-GRAY<br>cv.COLOR_BGR2HSV：BGR-HSV</p><h4 id="算数操作">算数操作</h4><h5 id="图像的加法">图像的加法</h5><p>可以使用OpenCV的cv.add()函数把两幅图像相加，或者可以简单的通过numpy操作添加两个图像，如res = img1 + img2.两个图像应该具有相同的大小和类型，或者第二个图像可以是标量值。</p><p>注意：OpenCV加法和Numpy加法之间存在差异。OpenCv的加法是饱和操作，而Numpy添加是模运算。</p><pre class=" language-language-python"><code class="language-language-python">&gt;&gt;&gt; x = np.uint8([250])&gt;&gt;&gt; y = np.uint8([10])&gt;&gt;&gt; print(cv.add(x,y)) # 250+10 = 260 =&gt; 255[[255]]&gt;&gt;&gt; print(x+y)  # 250+10 = 260 % 256 = 4[4]</code></pre><p>这种差别在你对两幅图像进行加法时会更加明显。OpenCV的结果会更好一点。所以尽量使用OpenCV中的函数。</p><pre class=" language-language-python"><code class="language-language-python">import numpy as npimport cv2 as cvimport matplotlib.pyplot as plt# 读取图像img1 = cv.imread('/Users/dinggongcheng/Downloads/me.JPG')img2 = cv.imread('/Users/dinggongcheng/Downloads/me.JPG')# 加法操作img3 = cv.add(img1, img2)img4 = img1 + img2# 图像显示plt.imshow(img3[:, :, ::-1])plt.imshow(img4[:, :, ::-1])plt.show()</code></pre><p><img src="http://dingdm.online/%E6%88%AA%E5%B1%8F2021-03-29%20%E4%B8%8B%E5%8D%881.23.37.png" alt="cv相加"></p><p><img src="http://dingdm.online/%E6%88%AA%E5%B1%8F2021-03-29%20%E4%B8%8B%E5%8D%881.24.06.png" alt="直接相加"></p><h5 id="图像的混合">图像的混合</h5><p>通过加法实现，但是不同的是两幅图像的权重不同，这就会给人一种混合或者透明的感觉。图像混合的计算公式如下：<br>g(x) = (1-a)f0(x) + af1(x)<br>通过修改a的值(0-&gt;1)，可以实现非常炫酷的混合。<br>现在把两幅图混合在一起。第一幅图的权重是0.7，第二幅图的权重是0.3。函数cv2.addWeighted()可以按下面的公式对图片进行混合操作。<br>dst = a*img1 + b*img2 + c</p><pre class=" language-language-python"><code class="language-language-python"># 读取图像img1 = cv.imread('/Users/dinggongcheng/Downloads/me.JPG')img2 = cv.imread('/Users/dinggongcheng/Downloads/me.JPG')# 图像混合img3 = cv.addWeighted(img1, 0.8, img2, 0.6, 0)# 图像显示plt.figure(figsize=(8, 8))plt.imshow(img3[:, :, ::-1])plt.show()</code></pre><h4 id="几何变换">几何变换</h4><h5 id="图像缩放">图像缩放</h5><p>缩放是对图像的大小进行调整<br>cv.resize(src,dsize,fx=0,fy=0,interpolation=cv.INTER_LINEAR)<br>src：输入图像<br>dsize：绝对尺寸，直接指定调整后图像的大小<br>fx，fy：相对尺寸，将dsize设置为None，然后将fx和fy设置为比例因子即可<br>interpolation：插值方法</p><table><thead><tr><th>插值</th><th>含义</th></tr></thead><tbody><tr><td>cv.INTER_LINEAR</td><td>双线性插值法</td></tr><tr><td>cv.INTER_NEAREST</td><td>最近邻插值</td></tr><tr><td>cv.INTER_AREA</td><td>像素区域重采样</td></tr><tr><td>cv.INTER_CUBIC</td><td>双三次插值</td></tr></tbody></table><pre class=" language-language-python"><code class="language-language-python">import cv2 as cvimport matplotlib.pyplot as pltimg = cv.imread("/Users/dinggongcheng/Downloads/me.JPG")# 绝对尺寸缩放rows, cols = img.shape[:2]res = cv.resize(img, (2*cols, 2*rows), interpolation=cv.INTER_CUBIC)# 相对尺寸缩放res1 = cv.resize(img, None, fx=0.5, fy=0.5)# 图像显示fig, axes = plt.subplots(nrows=1, ncols=3, figsize=(10, 8), dpi=100)axes[0].imshow(res[:, :, ::-1])axes[0].set_title("dsize big")axes[1].imshow(img[:, :, ::-1])axes[1].set_title("from")axes[2].imshow(res1[:, :, ::-1])axes[2].set_title("fx small")plt.show()</code></pre><p><img src="http://dingdm.online/%E6%88%AA%E5%B1%8F2021-03-29%20%E4%B8%8B%E5%8D%881.53.24.png" alt=""></p><h5 id="图像平移">图像平移</h5><p>图像平移将图像按照指定方向和距离，移动到相应的位置。<br>cv.warpAffine(img,M,dsize)<br>img：输入图像<br>M：2*3移动矩阵，对于(x,y)处的像素点，要把它移动到(x+tx,y+ty)处时，M矩阵应如下设置：<br>M = 1 0 tx<br>0 1 ty<br>注意：将M设置为np.float32类型的Numpy数组<br>dsize：输出图像的大小<br>注意：输出图像的大小，它应该是(宽度，高度)的形式。请记住，width=列数，height=行数。</p><pre class=" language-language-python"><code class="language-language-python">import numpy as npimport cv2 as cvimport matplotlib.pyplot as pltimg = cv.imread("/Users/dinggongcheng/Downloads/me.JPG")# 图像平移rows, cols = img.shape[:2]M = np.float32([[1, 0, 100], [0, 1, 50]]) #平移矩阵dst = cv.warpAffine(img, M, (cols, rows))# 图像显示fig, axes = plt.subplots(nrows=1, ncols=2, figsize=(10, 8), dpi=100)axes[0].imshow(dst[:, :, ::-1])axes[0].set_title("move")axes[1].imshow(img[:, :, ::-1])axes[1].set_title("from")plt.show()</code></pre><p><img src="http://dingdm.online/%E6%88%AA%E5%B1%8F2021-03-29%20%E4%B8%8B%E5%8D%882.07.55.png" alt=""></p><h5 id="图像旋转">图像旋转</h5><p>图像旋转是指图像按照某个位置转动一定角度的过程，旋转中图像仍保持原始尺寸。图像旋转后图像的水平对称轴，垂直对称轴及中心坐标原点都可能发生变换。因此需要对图像旋转中的坐标进行相应转换。<br>在OpenCV中图像旋转首先根据旋转角度和旋转中心获取旋转矩阵，然后根据旋转矩阵进行变换，即可实现任意角度和任意中心的旋转效果。<br>cv.getRotationMatrix2D(center, angle,scale)<br>center：旋转中心<br>angle：旋转角度<br>scale：缩放比例<br>返回：<br>M：旋转矩阵<br>调用cv.warpAffine完成图像的旋转</p><pre class=" language-language-python"><code class="language-language-python">import numpy as npimport cv2 as cvimport matplotlib.pyplot as pltimg = cv.imread("/Users/dinggongcheng/Downloads/me.JPG")# 图像旋转rows, cols = img.shape[:2]# 生成旋转矩阵M = cv.getRotationMatrix2D((cols/2, rows/2), 90, 1)# 进行旋转变换dst = cv.warpAffine(img, M, (cols, rows))# 图像显示fig, axes = plt.subplots(nrows=1, ncols=2, figsize=(10, 8), dpi=100)axes[0].imshow(dst[:, :, ::-1])axes[0].set_title("rotate")axes[1].imshow(img[:, :, ::-1])axes[1].set_title("from")plt.show()</code></pre><p><img src="http://dingdm.online/%E6%88%AA%E5%B1%8F2021-03-29%20%E4%B8%8B%E5%8D%882.25.20.png" alt=""></p><h5 id="仿射变换">仿射变换</h5><p>图像的仿射变换涉及到图像的形状位置角度的变化，是深度学习预处理中常用到的功能，仿射变换主要是对图像的缩放，旋转，翻转和平移等操作的组合。<br>需要注意的是，对于图像而言，宽度方向是x，高度方向是y，坐标的顺序和图像像素对应下标一致。所以原点的位置不是左下角而是右上角，y的方向也不是向上，而是向下。<br>在仿射变换中，原图中所有的平行线在结果图像中同样平行。为了创建这个矩阵我们需要从原图像中找到三个点以及他们在输出图像中的位置。然后cv.getAffineTransform会创建一个2*3的矩阵，最后这个矩阵会被传给函数cv.warpAffine</p><pre class=" language-language-python"><code class="language-language-python">import numpy as npimport cv2 as cvimport matplotlib.pyplot as pltimg = cv.imread("/Users/dinggongcheng/Downloads/me.JPG")# 仿射变换rows, cols = img.shape[:2]# 创建变换矩阵pts1 = np.float32([[50, 50], [200, 50], [50, 200]])pts2 = np.float32([[100, 100], [200, 50], [100, 250]])M = cv.getAffineTransform(pts1, pts2)# 完成仿射变换dst = cv.warpAffine(img, M, (cols, rows))# 图像显示fig, axes = plt.subplots(nrows=1, ncols=2, figsize=(10, 8), dpi=100)axes[0].imshow(dst[:, :, ::-1])axes[0].set_title("affine")axes[1].imshow(img[:, :, ::-1])axes[1].set_title("from")plt.show()</code></pre><p><img src="http://dingdm.online/%E6%88%AA%E5%B1%8F2021-03-29%20%E4%B8%8B%E5%8D%882.38.35.png" alt=""></p><h5 id="透射变换">透射变换</h5><p>透射变换是视角变换的结果，是指利用透视中心，像点，目标点三点共线的条件，按透视旋转定律使承影面绕迹线旋转某一角度，破坏原有的投影光线束，仍能保持承影面上投影几何图形不变的变换。<br>在OpenCV中，我们要找到四个点，其中任意三个不共线，然后获取变换矩阵T，在进行透射变换。通过函数cv.getPerspectiveTransform找到其变换矩阵，将cv.warpPerspective应用于此3*3变换矩阵。</p><pre class=" language-language-python"><code class="language-language-python">import numpy as npimport cv2 as cvimport matplotlib.pyplot as pltimg = cv.imread("/Users/dinggongcheng/Downloads/me.JPG")# 透射变换rows, cols = img.shape[:2]# 创建变换矩阵pts1 = np.float32([[56, 65], [368, 52], [28, 387], [389,390]])pts2 = np.float32([[100, 145], [300, 100], [80, 290], [310, 300]])T = cv.getPerspectiveTransform(pts1,pts2)# 进行变换dst = cv.warpPerspective(img, T, (cols, rows))# 图像显示fig, axes = plt.subplots(nrows=1, ncols=2, figsize=(10, 8), dpi=100)axes[0].imshow(dst[:, :, ::-1])axes[0].set_title("perspective")axes[1].imshow(img[:, :, ::-1])axes[1].set_title("from")plt.show()</code></pre><p><img src="http://dingdm.online/%E6%88%AA%E5%B1%8F2021-03-29%20%E4%B8%8B%E5%8D%882.53.23.png" alt=""></p><h5 id="图像金字塔">图像金字塔</h5><p>图像金字塔是图像多尺度表达的一种，最主要用于图像的分割，是一种以多分辨率来解释图像的有效但概念简单的结构。<br>图像金字塔用于机器视觉和图像压缩，一幅图像的金字塔是一系列以金字塔形状排列的分辨率逐步降低且来源于同一张原始图的图像集合。其通过梯次向下采样获得，直到达到某个终止条件才停止采样。<br>金字塔的底部是待处理图像的高分辨率表示，而顶部是低分辨率的近似，层级越高，图像越小，分辨率越低。<br>cv.pyrUp(img) 对图像进行上采样<br>cv.pyrDown(img) 对图像进行下采样</p><pre class=" language-language-python"><code class="language-language-python">import numpy as npimport cv2 as cvimport matplotlib.pyplot as pltimg = cv.imread("/Users/dinggongcheng/Downloads/me.JPG")# 进行图像采样up_img = cv.pyrUp(img)down_img = cv.pyrDown(img)# 图像显示fig, axes = plt.subplots(nrows=1, ncols=2, figsize=(10, 8), dpi=100)axes[0].imshow(up_img[:, :, ::-1])axes[0].set_title("Up")axes[1].imshow(down_img[:, :, ::-1])axes[1].set_title("Down")plt.show()</code></pre><p><img src="http://dingdm.online/%E6%88%AA%E5%B1%8F2021-03-29%20%E4%B8%8B%E5%8D%883.04.56.png" alt=""></p><h4 id="形态学操作">形态学操作</h4><h5 id="连通性">连通性</h5><p>连通性是描述区域和边界的重要概念，两个像素联通的两个必要条件是：<br>1.两个像素的位置是否相邻<br>2.两个像素的灰度值是否满足特定的相似性准则</p><h5 id="腐蚀和膨胀">腐蚀和膨胀</h5><p>腐蚀和膨胀是最基本的形态学操作，腐蚀和膨胀都是针对白色部分(高亮部分)而言的。<br>膨胀就是使图像中高亮部分扩张，效果图拥有比原图更大的高亮区域；腐蚀是原图中的高亮区域被蚕食，效果图拥有比原图更小的高亮区域。膨胀是求局部最大值的操作，腐蚀是求局部最小值的操作。</p><p>腐蚀的具体操作是用一个结构元素扫描图像中的每一个元素，用结构元素中的每一个像素与其覆盖的像素做与操作，如果都为1，则该像素为1，否则为0.<br>腐蚀的作用是消除物体边界点，使目标缩小，可以消除小于结构元素的噪声点。<br>cv.erode(img,kernel,iterations)<br>img：要处理的图像<br>kernel：核结构<br>iterations：腐蚀的次数，默认是1</p><p>膨胀的具体操作是用一个结构元素扫描图像中的每一个像素，用结构元素中的每一个像素与其覆盖的像素做与操作，如果都为0，则该像素为0，否则为1.<br>膨胀的作用是将与物体接触的所有背景点合并到物体中，使目标增大，可添补目标中的孔洞。<br>cv.dilate(img,kernel,iterations)img：要处理的图像<br>kernel：核结构<br>iterations：腐蚀的次数，默认是1</p><pre class=" language-language-python"><code class="language-language-python">import numpy as npimport cv2 as cvimport matplotlib.pyplot as plt# 读取图像img = cv.imread("/Users/dinggongcheng/Downloads/me.JPG")# 创建核结构kernel = np.ones((5, 5), np.uint8)# 图像腐蚀和膨胀erosion = cv.erode(img, kernel)dilate = cv.dilate(img, kernel)# 图像显示fig, axes = plt.subplots(nrows=1, ncols=3, figsize=(10, 8), dpi=100)axes[0].imshow(img[:, :, ::-1])axes[0].set_title("from")axes[1].imshow(erosion[:, :, ::-1])axes[1].set_title("erosion")axes[1].imshow(dilate[:, :, ::-1])axes[1].set_title("dilate")plt.show()</code></pre><p><img src="http://dingdm.online/%E6%88%AA%E5%B1%8F2021-03-29%20%E4%B8%8B%E5%8D%883.34.21.png" alt=""></p><h5 id="开闭运算">开闭运算</h5><p>开运算和闭运算是将腐蚀和膨胀按照一定的次序进行处理。但这两者并不是可逆的，即先开后闭并不难得到原来的图像。<br>开运算是先腐蚀后膨胀，其作用是分离物体，消除小区域。消除噪点，去除小的干扰块，而不影响原来的图像。<br>闭运算与开运算相反，是先膨胀后腐蚀，作用是消除/闭合物体里面的孔洞。可以填充闭合区域。</p><p>cv.morphologyEx(img,op,kernel)<br>img：要处理的图像<br>op：处理方式：若进行开运算，则设为cv.MORPH_OPEN，若进行闭运算，则设为cv.MORPH_CLOSE<br>kernel：核结构</p><pre class=" language-language-python"><code class="language-language-python">import numpy as npimport cv2 as cvimport matplotlib.pyplot as plt# 读取图像img = cv.imread("/Users/dinggongcheng/Downloads/me.JPG")# 创建核结构kernel = np.ones((10, 10), np.uint8)# 图像的开闭运算cvOpen = cv.morphologyEx(img, cv.MORPH_OPEN, kernel)cvClose = cv.morphologyEx(img, cv.MORPH_CLOSE, kernel)# 图像显示fig, axes = plt.subplots(nrows=1, ncols=3, figsize=(10, 8), dpi=100)axes[0].imshow(img[:, :, ::-1])axes[0].set_title("from")axes[1].imshow(cvOpen[:, :, ::-1])axes[1].set_title("cvOpen")axes[1].imshow(cvClose[:, :, ::-1])axes[1].set_title("cvClose")plt.show()</code></pre><h5 id="礼帽和黑帽">礼帽和黑帽</h5><p>礼帽运算<br>原图像与开运算的结果图之差，如下式计算：<br>dst = tophat(src,element) = src - open(src,element)<br>因为开运算带来的结果是放大了裂缝或者局部低亮度的区域，因此，从原图中减去开运算后的图，得到的效果突出了比原图轮廓周围的区域更明亮的区域，且这一操作和选择的核的大小相关。<br>礼帽运算用来分离比邻近点亮一些的斑块。当一幅图像具有大幅的背景的时候，而微小物品比较有规律的情况下，可以使用礼帽运算进行背景提取。</p><p>黑帽运算<br>为闭运算的结果图与原图像之差，数学表达式为<br>dst = blackout(src,element) = close(src,element) - src<br>黑帽运算后的效果图突出了比原图轮廓周围的区域更暗的区域，且这一操作和选择的核的大小相关。黑帽运算用来分离比邻近点暗一些的斑块。</p><p>cv.morphologyEx(img,op,kernel)<br>img：要处理的图像<br>op：处理方式：若进行开运算，则设为cv.MORPH_OPEN，若进行闭运算，则设为cv.MORPH_CLOSE。若进行礼帽运算，则设为cv.MORPH_TOPHAT，若进行黑帽运算，则设为cv.MORPH_BLACKHAT。<br>kernel：核结构</p><h4 id="图像平滑">图像平滑</h4><h5 id="图像噪声">图像噪声</h5><p>椒盐噪声<br>椒盐噪声也称为脉冲噪声，是图像中经常见到的一种噪声，它是一种随机出现的白点或者黑点，可能是亮的区域有黑色像素或是在暗的区域有白色像素。</p><p>高斯噪声<br>噪声密度函数服从高斯分布的一类噪声。</p><h5 id="图像平滑-2">图像平滑</h5><h6 id="均值滤波">均值滤波</h6><p>cv.blur(src,ksize,anchor,borderType)<br>src：输入图像<br>ksize：卷积核的大小<br>anchor：默认值(-1,-1)，表示核中心<br>borderType：边界类型</p><pre class=" language-language-python"><code class="language-language-python">import numpy as npimport cv2 as cvimport matplotlib.pyplot as plt# 图像读取img = cv.imread("/Users/dinggongcheng/Downloads/me.png")# 均值滤波blur = cv.blur(img, (5, 5))# 图像显示plt.figure(figsize=(10, 8), dpi=100)plt.subplot(121), plt.imshow(img[:, :, ::-1]), plt.title('from')plt.xticks([]), plt.yticks([])plt.subplot(122), plt.imshow(blur[:, :, ::-1]), plt.title('blur')plt.xticks([]), plt.yticks([])plt.show()</code></pre><p><img src="http://dingdm.online/%E6%88%AA%E5%B1%8F2021-03-29%20%E4%B8%8B%E5%8D%884.16.32.png" alt=""></p><h6 id="高斯滤波">高斯滤波</h6><p>cv.GaussianBlur(src,ksize,sigmaX,sigmaY,borderType)<br>src：输入图像<br>ksize：高斯卷积核大小，注意：卷积核的宽度和高度都应为奇数，且可以不同<br>sigmaX：水平方向的标准差<br>sigmaY：垂直方向的标准差，默认值为0，表示与sigmaX相同<br>borderType：填充边界类型</p><pre class=" language-language-python"><code class="language-language-python">import numpy as npimport cv2 as cvimport matplotlib.pyplot as plt# 图像读取img = cv.imread("/Users/dinggongcheng/Downloads/me.png")# 高斯滤波gauss = cv.GaussianBlur(img, (3, 3), 1)# 图像显示plt.figure(figsize=(10, 8), dpi=100)plt.subplot(121), plt.imshow(img[:, :, ::-1]), plt.title('from')plt.xticks([]), plt.yticks([])plt.subplot(122), plt.imshow(gauss[:, :, ::-1]), plt.title('gauss')plt.xticks([]), plt.yticks([])plt.show()</code></pre><p><img src="http://dingdm.online/%E6%88%AA%E5%B1%8F2021-03-29%20%E4%B8%8B%E5%8D%884.26.06.png" alt=""></p><h6 id="中值滤波">中值滤波</h6><p>中值滤波是一种典型的非线性滤波技术，基本思想适用像素点领域灰度值的中值来代替该像素点的灰度值。中值滤波对椒盐噪声来说尤其有用，因为它不依赖于领域内那些与典型值差别很大的值。<br>cv.medianBlur(src,ksize)<br>src：输入图像<br>ksize：卷积核的大小</p><pre class=" language-language-python"><code class="language-language-python">import numpy as npimport cv2 as cvimport matplotlib.pyplot as plt# 图像读取img = cv.imread("/Users/dinggongcheng/Downloads/me.png")# 中值滤波media = cv.medianBlur(img, 5)# 图像显示plt.figure(figsize=(10, 8), dpi=100)plt.subplot(121), plt.imshow(img[:, :, ::-1]), plt.title('from')plt.xticks([]), plt.yticks([])plt.subplot(122), plt.imshow(media[:, :, ::-1]), plt.title('media')plt.xticks([]), plt.yticks([])plt.show()</code></pre><p><img src="http://dingdm.online/%E6%88%AA%E5%B1%8F2021-03-29%20%E4%B8%8B%E5%8D%884.30.18.png" alt=""></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenCV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python学习笔记(一)</title>
      <link href="/2021/03/27/python-xue-xi-bi-ji/"/>
      <url>/2021/03/27/python-xue-xi-bi-ji/</url>
      
        <content type="html"><![CDATA[<h2 id="python学习笔记-一">python学习笔记(一)</h2><h3 id="python函数">python函数</h3><p>print输出函数<br>id(var) 获取对象的唯一id type(var) 获取对象的类型 var 存储的值</p><p>open函数 var3 = open(var1 var2) var1参数值代表输出文件路径 var2代表文件创建的形式 'a+'代表无则创建，有则追加。var3代表返回对象<br>print(var1 var2) var1代表输出内容 var2代表使用的返回参数，对于输入到文件来说，file=var3进行输入<br><strong>使用open进行输入到文件，需要关闭返回var3的对象(关闭流)</strong></p><p>chr(0b二进制) 输出对应的汉字编码对应的汉字<br>ord(字符串) 输出对应汉字的二进制编码 都需要借助print输出</p><p>var2 = input(var1) var1作为脚本提问，var2作为用户输入</p><p>bool() 获取对象的bool值。默认为False的数据结构默认值，False，0，0.0，None，’’，""，[]，list()，()，tuple()，{}，dict()，set()</p><p>var = range(stop) 默认从0开始，步长为1。给出结束<br>var = range(start,stop) 默认步长为1，给出开始与结束。<br>var = range(start,stop,step) 给出开始，结束与步长。左闭右开。<br>list® 列表输出 使用in或not in判断整数在列表中是否存在，返回bool</p><h3 id="转义字符">转义字符</h3><p>\n 换行 \t 制表符 制表符以首字母开始以四个占位为标准进行<br>\r 回车 \b 回退 撤销前一格<br>不希望转义，字符串前加r或R即可<br>三引号可以换行</p><h3 id="字符编码">字符编码</h3><p>50 2 70 F 100 d</p><h3 id="类型转换">类型转换</h3><p>直接使用数据类型，str(),int(),float()</p><h3 id="运算符">运算符</h3><p>//整除运算，取整数部分，正负整除运算，向下取整数<br>**幂运算，次方运算<br>正负取余运算时，公式为余数=被除数-除数✖️商<br>解包赋值，a,b,c = 20,30,40<br>is进行对象判断<br>python中直接使用英文and,or或not<br>字符串判断存在可以直接使用in或not in</p><h3 id="分支结构">分支结构</h3><p>if语法:<br>if 条件表达式:<br>业务逻辑<br>else:<br>业务逻辑</p><p>if 条件表达式:<br>if 条件表达式:<br>业务逻辑<br>else:<br>业务逻辑<br>else:<br>业务逻辑</p><p>(var1) if var1&gt;=var2 else (var2)  类似三元表达式，True前，False后</p><p>pass占位符，代替模糊的业务逻辑</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring boot接口防刷</title>
      <link href="/2021/02/17/springboot-jie-kou-fang-shua/"/>
      <url>/2021/02/17/springboot-jie-kou-fang-shua/</url>
      
        <content type="html"><![CDATA[<h3 id="Springboot接口防刷">Springboot接口防刷</h3><p>自定义注解</p><pre class=" language-language-java"><code class="language-language-java">import java.lang.annotation.Retention;import java.lang.annotation.Target; import static java.lang.annotation.ElementType.METHOD;import static java.lang.annotation.RetentionPolicy.RUNTIME; @Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)public @interface AccessLimit {     int seconds();    int maxCount();    boolean needLogin() default true;}</code></pre><p>拦截器</p><p>用户的 ID和请求的路径作为key,首先从redis中根据该key去取得用户的访问次数，如果为null,则根据该key重新设置key,value,value的值是１，能取到key对应的value，则判断vlaue是否小于５，是则处理请求，否则返回error。</p><pre class=" language-language-java"><code class="language-language-java">import com.alibaba.fastjson.JSON;import com.example.demo.action.AccessLimit;import com.example.demo.redis.RedisService;import com.example.demo.result.CodeMsg;import com.example.demo.result.Result;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Component;import org.springframework.web.method.HandlerMethod;import org.springframework.web.servlet.handler.HandlerInterceptorAdapter; import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.OutputStream; @Componentpublic class AntiBrushInterceptor extends HandlerInterceptorAdapter {     @Autowired    private RedisService redisService;     @Override    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {         if(handler instanceof HandlerMethod){             HandlerMethod hm = (HandlerMethod) handler;             AccessLimit accessLimit = hm.getMethodAnnotation(AccessLimit.class);            if(accessLimit == null){                return true;            }            int seconds = accessLimit.seconds();            int maxCount = accessLimit.maxCount();            boolean login = accessLimit.needLogin();            String key = request.getRequestURI();            if(login){                //业务逻辑            }             AccessKey ak = AccessKey.withExpire(seconds);            Integer count = redisService.get(ak,key,Integer.class);            if(count == null){                redisService.set(ak,key,1);            }else if(count &lt; maxCount){                redisService.incr(ak,key);            }else{                render(response,CodeMsg.ACCESS_LIMIT_REACHED);                 return false;            }        }         return true;     }    private void render(HttpServletResponse response, CodeMsg cm)throws Exception {        response.setContentType("application/json;charset=UTF-8");        OutputStream out = response.getOutputStream();        String str  = JSON.toJSONString(Result.error(cm));        out.write(str.getBytes("UTF-8"));        out.flush();        out.close();    }}</code></pre><p>拦截器注册和注解使用</p><pre class=" language-language-java"><code class="language-language-java">import com.example.demo.ExceptionHander.AntiBrushInterceptor;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.context.annotation.Configuration;import org.springframework.web.servlet.config.annotation.InterceptorRegistry;import org.springframework.web.servlet.config.annotation.WebMvcConfigurerAdapter;@Configurationpublic class WebConfig extends WebMvcConfigurerAdapter {     @Autowired    private AntiBrushInterceptor interceptor;      @Override    public void addInterceptors(InterceptorRegistry registry) {        registry.addInterceptor(interceptor);    }}</code></pre><pre class=" language-language-java"><code class="language-language-java">@PostMapping("getNewsModule")@AccessLimit(seconds=5, maxCount=10, needLogin=true)public Result<list<newsmoduledto>&gt; getNewsModule(@ApiIgnore @RequestParam Map<string, object=""> params){        PageData<newsmoduledto> page = newsModuleService.page(params);        return new Result<list<newsmoduledto>&gt;().ok(page.getList());    }</list<newsmoduledto></newsmoduledto></string,></list<newsmoduledto></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 日常随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Boot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用docker创建项目镜像</title>
      <link href="/2021/02/05/shi-yong-docker-chuang-jian-xiang-mu-jing-xiang/"/>
      <url>/2021/02/05/shi-yong-docker-chuang-jian-xiang-mu-jing-xiang/</url>
      
        <content type="html"><![CDATA[<h3 id="使用docker创建项目镜像">使用docker创建项目镜像</h3><p>本文创建的镜像为hexo静态博客的镜像，防止自己的服务器到期之后进行迁移的麻烦。</p><h4 id="确定创建镜像所需的环境">确定创建镜像所需的环境</h4><ul><li>node.js</li><li>git</li><li>nginx</li></ul><h4 id="编写自己的镜像的Dockerfile文件">编写自己的镜像的Dockerfile文件</h4><p>docker指令详解</p><table><thead><tr><th>指令名称</th><th>用法</th><th>作用</th></tr></thead><tbody><tr><td>FROM</td><td>FROM image</td><td>FROM指定构建镜像的基础源镜像，如果本地没有指定的镜像，则会自动从 Docker 的公共库 pull 镜像下来；FROM必须是 Dockerfile 中非注释行的第一个指令，即一个 Dockerfile 从FROM语句开始；FROM可以在一个 Dockerfile 中出现多次，如果有需求在一个 Dockerfile 中创建多个镜像；如果FROM语句没有指定镜像标签，则默认使用latest标签。</td></tr><tr><td>MAINTAINER</td><td>MAINTAINER name</td><td>指定创建镜像的用户</td></tr><tr><td>RUN</td><td>RUN “executable”, “param1”, “param2”</td><td>每条RUN指令将在当前镜像基础上执行指定命令，并提交为新的镜像，后续的RUN都在之前RUN提交后的镜像为基础，镜像是分层的，可以通过一个镜像的任何一个历史提交点来创建，类似源码的版本控制；</td></tr><tr><td></td><td>RUN [ “echo”, “$HOME” ]</td><td></td></tr><tr><td></td><td>RUN [ “sh”, “-c”, “echo”, “$HOME” ]</td><td>RUN产生的缓存在下一次构建的时候是不会失效的，会被重用，可以使用–no-cache选项，即docker build –no-cache，如此便不会缓存。</td></tr><tr><td>CMD</td><td>CMD “executable”,“param1”,“param2”</td><td>CMD指定在 Dockerfile 中只能使用一次，如果有多个，则只有最后一个会生效。</td></tr><tr><td></td><td>CMD “param1”,“param2”</td><td>CMD的目的是为了在启动容器时提供一个默认的命令执行选项。如果用户启动容器时指定了运行的命令，则会覆盖掉CMD指定的命令。</td></tr><tr><td></td><td>CMD command param1 param2 (shell form)</td><td>CMD会在启动容器的时候执行，build 时不执行，而RUN只是在构建镜像的时候执行，后续镜像构建完成之后，启动容器就与RUN无关了</td></tr><tr><td>EXPOSE</td><td>EXPOSE port [port…]</td><td>告诉 Docker 服务端容器对外映射的本地端口，需要在 docker run 的时候使用-p或者-P选项生效。</td></tr><tr><td>ENV</td><td>ENV key value       <em># 只能设置一个变量</em></td><td></td></tr><tr><td></td><td>ENV key=value …   <em># 允许一次设置多个变量</em></td><td>指定一个环境变量，会被后续RUN指令使用，并在容器运行时保留。</td></tr><tr><td>ADD</td><td>ADD src… dest</td><td>ADD复制本地主机文件、目录或者远程文件 URLS 从 并且添加到容器指定路径中 。</td></tr><tr><td>COPY</td><td>COPY src… dest</td><td>COPY复制新文件或者目录从 并且添加到容器指定路径中 。用法同ADD，唯一的不同是不能指定远程文件 URLS。</td></tr><tr><td>ENTRYPOINT</td><td>ENTRYPOINT “executable”, “param1”, “param2”</td><td>每个 Dockerfile 中只能有一个ENTRYPOINT，当指定多个时，只有最后一个生效。</td></tr><tr><td></td><td>ENTRYPOINT command param1 param2 (shell form)</td><td>配置容器启动后执行的命令，并且不可被 docker run 提供的参数覆盖，而CMD是可以被覆盖的。如果需要覆盖，则可以使用<code>docker run --entrypoint</code>选项。</td></tr><tr><td>VOLUME</td><td>VOLUME ["/data"]</td><td>将本地主机目录挂载到目标容器中，或者将其他容器挂载的挂载点 挂载到目标容器中</td></tr><tr><td>USER</td><td>USER daemon</td><td>指定运行容器时的用户名或 UID，后续的RUN、CMD、ENTRYPOINT也会使用指定用户。</td></tr><tr><td>WORKDIR</td><td>WORKDIR /path/to/workdir</td><td>为后续的RUN、CMD、ENTRYPOINT指令配置工作目录。可以使用多个WORKDIR指令，后续命令如果参数是相对路径，则会基于之前命令指定的路径。</td></tr><tr><td>ONBUILD</td><td>ONBUILD [INSTRUCTION]</td><td>使用该dockerfile生成的镜像A，并不执行ONBUILD中命令，如再来个dockerfile 基础镜像为镜像A时，生成的镜像B时就会执行ONBUILD中的命令</td></tr></tbody></table><p><strong>拉取ubuntu环境镜像</strong></p><pre class=" language-language-dockerfile"><code class="language-language-dockerfile">docker pull ubuntu:18.04</code></pre><p><img src="http://dingdm.online/%E6%8B%89%E5%8F%96ubuntu.png" alt=""></p><p>如果拉取镜像慢的话，可以配置一下镜像加速。</p><p>使用<code>docker version</code>查看自己的docker版本，大于1.10可以进行加速配置，小于的更新一下即可。</p><pre><code>mkdir -p /etc/dockertee /etc/docker/daemon.json &lt;&lt;-'EOF'{  "registry-mirrors": ["https://xxxxx.mirror.aliyuncs.com"]  #这里也可以用网易的镜像加速器："http://hub-mirror.c.163.com"}EOFsystemctl daemon-reloadsystemctl restart docker</code></pre><p><strong>配置nginx环境</strong></p><p>安装步骤在后面的Dockerfile中，安装完nginx后，这里以ubuntu18.04为例，nginx的目录为/ect/nginx。我们修改配置文件只需要修改sites-available下的default即可。我这里在之前学习的时候都是不一样的路径，所以我这里以ubuntu为例。准备好一份default配置文件COPY即可。</p><pre><code>server {        listen 80 default_server;        listen [::]:80 default_server;        listen 443 ssl;        ssl off;        ssl_certificate cert/4287626_www.dingdm.club.pem;        ssl_certificate_key cert/4287626_www.dingdm.club.key;        ssl_session_timeout 5m;        #ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aN$        ssl_ciphers ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES128-SHA256:ECDHE-RSA-AES128-SHA256:ECDHE-ECDSA-AES128-SHA:ECDHE-RSA-AES256-SHA384:ECDHE-RSA-AES128-SHA:ECDHE-ECDSA-AES256-SHA384:ECDHE-ECDSA-AES256-SHA:ECDHE-RSA-AES256-SHA:DHE-RSA-AES128-SHA256:DHE-RSA-AES128-SHA:DHE-RSA-AES256-SHA256:DHE-RSA-AES256-SHA:ECDHE-ECDSA-DES-CBC3-SHA:ECDHE-RSA-DES-CBC3-SHA:EDH-RSA-DES-CBC3-SHA:AES128-GCM-SHA256:AES256-GCM-SHA384:AES128-SHA256:AES256-SHA256:AES128-SHA:AES256-SHA:DES-CBC3-SHA:!DSS;        ssl_protocols TLSv1 TLSv1.1 TLSv1.2;        ssl_prefer_server_ciphers on;        root /home/www/hexo;        server_name dingdm.club;}</code></pre><p>server_name为你的域名，root为你的静态网站所在的路径，可以自己创建，<strong>注意这里的路径不是你的hexo博客的路径，如果你在服务器上创建博客的话</strong>。</p><p>ssl的配置为开启https的配置，这里先不赘述，不需要的话可以将ssl相关的配置注释掉即可</p><p><strong>在你使用docker镜像服务器上配一下自己的git环境和仓库。(非docker容器)</strong></p><p>更新频繁因此不将git整合到容器内。</p><pre><code>apt-get update apt-get install gitgit config --global user.name "你的用户名"git config --global user.email "你的注册邮箱"</code></pre><p>添加git用户，使用root账户也可以。</p><pre><code>adduser git</code></pre><p>修改文件内容赋予权限</p><pre><code>chmod 740 /etc/sudoersnano /etc/sudoers</code></pre><p>找到root用户那，在下方添加一条</p><pre><code>git ALL=(ALL) ALL</code></pre><p>将文件权限恢复</p><pre><code>chmod 400 /etc/sudoers</code></pre><p>切换到git用户，并创建ssh文件夹</p><pre><code>su gitcd ~mkdir .sshcd .ssh</code></pre><p>生成密钥公钥并配置</p><pre><code>ssh-keygencp id_rsa.pub authorized_keyschmod 600 ~/.ssh/authorized_keyschmod 700 ~/.ssh</code></pre><p>配置完成之后可以使用<code>ssh -v git@ip</code>连接测试</p><p>新建仓库并设置钩子脚本</p><pre><code>cd ~git init --bare blog.gitnano ~/blog.git/hooks/post-receive</code></pre><p>输入以下内容</p><pre><code>git --work-tree=/home/www/hexo --git-dir=/home/git/blog.git checkout -f</code></pre><p>/home/www/hexo为你刚刚在nginx的配置文件里的root路径，/home/git/blog.git为你的仓库地址</p><p><strong>制作Dockerfile文件</strong></p><p>使用自己刚刚拉取的ubuntu镜像并安装nginx和配置环境</p><pre class=" language-language-dockerfile"><code class="language-language-dockerfile">FROM c090eaba6b94RUN apt-get update &amp;&amp; apt-get install -y nginxCOPY default /etc/nginx/sites-available/COPY www/ /home/wwwCMD ["/usr/sbin/nginx","-g","daemon off;"]</code></pre><p><strong>制作镜像</strong></p><pre><code>docker build -t dingdm:1.0.0 .</code></pre><p><img src="http://dingdm.online/%E8%BF%90%E8%A1%8C%E9%95%9C%E5%83%8F.png" alt=""></p><p><img src="http://dingdm.online/%E8%BF%90%E8%A1%8C%E6%88%90%E5%8A%9F.png" alt=""></p><p><strong>镜像为nginx加静态博客页面。服务器到期后在考虑本地部署，使用ADD加载git仓库里新部署的文件信息并发布新版镜像。</strong></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dockerfile </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>KMP字符串匹配</title>
      <link href="/2020/09/07/kmp-zi-fu-chuan-pi-pei/"/>
      <url>/2020/09/07/kmp-zi-fu-chuan-pi-pei/</url>
      
        <content type="html"><![CDATA[<h3 id="KMP字符串匹配">KMP字符串匹配</h3><pre class=" language-language-java"><code class="language-language-java">package com.zjr.wholesale.config;import java.util.ArrayList;import java.util.List;public class KMP {    /*public static String [] str = new String[]{"b","a","c","b","a","d",            "a","b","a","d","a","b","a","b","a","c","a","m","b","a","b","a","c","a","d","d","a","b","a","b","a","c","a","s","d"};    public static String [] ptr = new String[]{"a","b","a","b","a","c","a"};*/    public static String [] str = new String[]{"a","b","c","a","a","b",            "a","b","a","b","a","a"};    public static String [] ptr = new String[]{"a","b","a","b"};    public static void main(String []args) {        List<integer> array = getPtrArray(ptr);        ifEquals(0,0,array);    }    //递归判断字符串比较    public static void ifEquals(int i,int j,List<integer> array){        if(i &lt; str.length){            if(j &lt; ptr.length){                if(str[i].equals(ptr[j])){                    i++;                    j++;                    ifEquals(i,j,array);                }else{                    if(j == 0){                        i++;                    }else{                        int length = getArrayValue(j,array);                        if(length != 0){                            i = i - length;                        }                        j = 0;                    }                    ifEquals(i,j,array);                }            }else{                System.out.println("Ptr 匹配成功，下标开始位置为:" + (i - ptr.length));                j = 0;                ifEquals(i,j,array);            }        }else{            System.out.println("字符串匹配结束");        }    }    //获取前缀后缀数组中的长度    public static int getArrayValue(int j,List<integer> array){        return array.get(j-1);    }    //获取比较字符串的前缀后缀数组    public static List<integer> getPtrArray(String []str){        int j = 1;        List<integer> array = new ArrayList<integer>();        while(j &lt;= str.length){            List<string> nStr = new ArrayList<string>();            for(int i=0;i<j;i++){ nstr.add(str[i]);="" }="" int="" number="getNStrNumber(nStr);" array.add(number);="" j++;="" return="" array;="" 获取当前列表字符串的前缀后缀个数="" public="" static="" getnstrnumber(list<string=""> nStr){        int length = 0;        if(nStr.size() == 1){            length = 0;        }else{            int i = nStr.size();            boolean flag = true;            while(i &gt; 0 &amp;&amp; flag){                i--;                StringBuilder str = new StringBuilder();                StringBuilder ptr = new StringBuilder();                for(int index = 0;index &lt; i;index++){                    str.append(nStr.get(index));                }                for(int lIndex=(nStr.size() - i);lIndex &lt; nStr.size();lIndex++){                    ptr.append(nStr.get(lIndex));                }                if(str.toString().equals(ptr.toString())){                    flag = false;                    length = str.length();                }            }        }        return length;    }}</j;i++){></string></string></integer></integer></integer></integer></integer></integer></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KMP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>steam及其他免费游戏白嫖(更新)</title>
      <link href="/2020/08/08/steam-ji-qi-ta-mian-fei-you-xi-bai-piao-geng-xin/"/>
      <url>/2020/08/08/steam-ji-qi-ta-mian-fei-you-xi-bai-piao-geng-xin/</url>
      
        <content type="html"><![CDATA[<h3 id="steam及其他免费游戏白嫖-更新">steam及其他免费游戏白嫖(更新)</h3><h4 id="2020-11-05">2020-11-05</h4><p>无主之地3 61元<br><a href="https://www.greenmangaming.com/zh/" target="_blank" rel="noopener">https://www.greenmangaming.com/zh/</a></p><h4 id="2020-09-02">2020-09-02</h4><p>远哭3领取<br><a href="https://register.ubisoft.com/far-cry-3/zh-CN" target="_blank" rel="noopener">https://register.ubisoft.com/far-cry-3/zh-CN</a><br>全境封锁领取<br><a href="https://register.ubisoft.com/the-division/en-US" target="_blank" rel="noopener">https://register.ubisoft.com/the-division/en-US</a><br>全境封锁需挂下梯子，推荐efan</p><h4 id="2020-08-16">2020-08-16</h4><p>NBK 2K20<br><a href="https://www.greenmangaming.com/zh/games/nba-2k20-pc/" target="_blank" rel="noopener">https://www.greenmangaming.com/zh/games/nba-2k20-pc/</a><br>鬼泣5和生化危机2 3优惠<br><a href="https://chinaplay.store/china-keys/" target="_blank" rel="noopener">https://chinaplay.store/china-keys/</a></p><h4 id="2020-08-13">2020-08-13</h4><p>全面战争特洛伊<br>本体领取地址：<a href="https://www.epicgames.com/store/zh-CN/product/a-total-war-saga-troy" target="_blank" rel="noopener">https://www.epicgames.com/store/zh-CN/product/a-total-war-saga-troy</a><br>本体领取时间：8月13日21:00-8月14日21:00<br>DLC领取地址<br>注册地址：<a href="https://access.totalwar.com/auth/email_register/" target="_blank" rel="noopener">https://access.totalwar.com/auth/email_register/</a><br>（如果注册地址打不开去这里https://access.totalwar.com/点击注册）<br>关联账号：<a href="https://access.totalwar.com/auth/control_panel/" target="_blank" rel="noopener">https://access.totalwar.com/auth/control_panel/</a></p><h4 id="2020-08-08">2020-08-08</h4><h5 id="steam">steam</h5><p><a href="https://www.humblebundle.com/store/f1-2018-free-game?hmb_campaign=freegame_2020_homepage_f12018&amp;hmb_medium=banner" target="_blank" rel="noopener">F1 2018</a></p><p>**《F1 2018》**是Codemasters开发制作的一款以世界一级方程式赛车为背景制作的一款赛车竞速类游戏。</p><p><a href="https://store.steampowered.com/app/397540/3/" target="_blank" rel="noopener">无主之地3</a></p><p>无主之地3免费周末试玩</p><h5 id="EPIC">EPIC</h5><p><a href="https://www.epicgames.com/store/zh-CN/free-games" target="_blank" rel="noopener">免费游戏</a></p><p>遗迹灰烬重生还不错</p><h5 id="GMG">GMG</h5><p><a href="https://www.epicgames.com/store/zh-CN/free-games" target="_blank" rel="noopener">GMG夏促</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 游戏 </category>
          
          <category> 白嫖 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> steam </tag>
            
            <tag> epic </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>win10系统的桌面美化</title>
      <link href="/2020/08/05/win10-xi-tong-de-zhuo-mian-mei-hua/"/>
      <url>/2020/08/05/win10-xi-tong-de-zhuo-mian-mei-hua/</url>
      
        <content type="html"><![CDATA[<h3 id="win10系统的桌面美化">win10系统的桌面美化</h3><p>首先放个人桌面和开始菜单的预览图。</p><p><img src="http://dingdm.online/QQ%E6%88%AA%E5%9B%BE20200805114944.png" alt="1596599399928"></p><p><img src="http://dingdm.online/QQ%E6%88%AA%E5%9B%BE20200805115313.png" alt=""></p><p>桌面美化的部分网络实时数据，应用图标美化，任务栏透明图标居中，开始菜单以及鼠标美化。</p><h4 id="美化软件以及相关文件">美化软件以及相关文件</h4><p><a href="http://dingdm.online/TrafficMonitor.rar" target="_blank" rel="noopener">实时数据软件</a></p><p><a href="http://dingdm.online/TrafficMonitor.rar" target="_blank" rel="noopener">任务栏软件</a></p><p><a href="http://dingdm.online/RocketDock-v1.3.5.exe" target="_blank" rel="noopener">应用设置软件</a></p><p><a href="http://dingdm.online/%E7%BE%8E%E5%8C%96.rar" target="_blank" rel="noopener">图标及开始程序按钮美化包</a></p><p><a href="http://dingdm.online/Ori%E9%BC%A0%E6%A0%87%E5%85%89%E6%A0%872.0.rar" target="_blank" rel="noopener">奥日鼠标资源</a></p><h4 id="实时数据美化">实时数据美化</h4><p>下载提供的实时数据软件后进行解压。打开TrafficMonitor.exe软件。这时就会出现相关内容。</p><p><img src="http://dingdm.online/QQ%E6%88%AA%E5%9B%BE20200805120508.png" alt=""></p><h5 id="选项设置">选项设置</h5><p>在实时数据上<strong>右键</strong></p><p><img src="http://dingdm.online/QQ%E6%88%AA%E5%9B%BE20200805120752.png" alt=""></p><p>将显示通知区域图标关掉，打开显示CPU和内存利用率的选项。</p><h5 id="样式更改">样式更改</h5><p>刚开始的位置并不在任务栏上，因此需要对配置进行修改。这里在实时数据上<strong>右键打开选项</strong>，按照以下配置进行修改即可。</p><p><img src="http://dingdm.online/QQ%E6%88%AA%E5%9B%BE20200805145216.png" alt=""></p><p><img src="http://dingdm.online/QQ%E6%88%AA%E5%9B%BE20200805145222.png" alt=""></p><p><img src="http://dingdm.online/QQ%E6%88%AA%E5%9B%BE20200805145229.png" alt=""></p><h4 id="任务栏设置">任务栏设置</h4><p>安装StartIsBack   2.9.exe</p><h5 id="属性设置">属性设置</h5><p>安装完成后右键开始菜单选择<strong>属性</strong>项</p><p><img src="http://dingdm.online/QQ%E6%88%AA%E5%9B%BE20200805150108.png" alt=""></p><h5 id="图标美化">图标美化</h5><p><img src="http://dingdm.online/QQ%E6%88%AA%E5%9B%BE20200805150201.png" alt=""></p><p>下载上面提供的美化图标，点击<strong>加号按钮</strong>添加即可。我这里已经添加过了，所有已经有了新的开始菜单的美化图标。</p><h5 id="任务栏透明">任务栏透明</h5><p><img src="http://dingdm.online/QQ%E6%88%AA%E5%9B%BE20200805150321.png" alt=""></p><p>点击<strong>自定义任务栏特效</strong>，选择任务栏图标居中和动态透明度即可。</p><h4 id="应用图标设置">应用图标设置</h4><p>下载上面提供的应用软件RocketDock-v1.3.5进行安装，安装完成后会出现类似mac的效果，自带默认的图标。</p><p><img src="http://dingdm.online/QQ%E6%88%AA%E5%9B%BE20200805150715.png" alt=""></p><p>因为我这里将我的电脑上的应用添加进来了，所以是完成后的效果。安装完成后将自带的图标移除，然后将自己的软件图标拉入到对应的位置即可。</p><h5 id="配置设置">配置设置</h5><p>在rockeddock上右键程序设置进行配置修改</p><p><img src="http://dingdm.online/QQ%E6%88%AA%E5%9B%BE20200805150823.png" alt=""></p><p>点击程序设置后按照我提供的配置进行修改即可。</p><p><img src="http://dingdm.online/QQ%E6%88%AA%E5%9B%BE20200805150837.png" alt=""></p><p><img src="http://dingdm.online/QQ%E6%88%AA%E5%9B%BE20200805150842.png" alt=""></p><p><img src="http://dingdm.online/QQ%E6%88%AA%E5%9B%BE20200805150848.png" alt=""></p><p>修改完成之后就是我现在的效果。</p><h5 id="图标设置">图标设置</h5><p>如果你想要更改图标的样式的话。在图标上右键点击图标设置。</p><p><img src="http://dingdm.online/QQ%E6%88%AA%E5%9B%BE20200805151023.png" alt=""></p><p><img src="http://dingdm.online/QQ%E6%88%AA%E5%9B%BE20200805151030.png" alt=""></p><p>下载上面提供的美化图标进行替换即可。</p><h5 id="图标分隔">图标分隔</h5><p>如果图标之间想要留出空隙的话，选择**添加项目中的分隔符****即可。</p><p><img src="http://dingdm.online/QQ%E6%88%AA%E5%9B%BE20200805151143.png" alt=""></p><p>至此应用图标的美化完成。</p><h4 id="鼠标设置">鼠标设置</h4><p><img src="http://dingdm.online/QQ%E6%88%AA%E5%9B%BE20200805151400.png" alt=""></p><p>我这里使用的是奥日的图标，如果你想使用的话下载上面的资源即可。</p><h5 id="网站下载">网站下载</h5><p>如果不想使用的话，鉴于国外网站需要翻墙，我这里提供鼠标样式下载的国内网站，自己选择下载即可。</p><p><a href="https://zhutix.com/tag/cursors/" target="_blank" rel="noopener">https://zhutix.com/tag/cursors/</a></p><h5 id="鼠标替换">鼠标替换</h5><p>打开电脑的设置界面，选择设备</p><p><img src="http://dingdm.online/QQ%E6%88%AA%E5%9B%BE20200805152038.png" alt=""></p><p><img src="http://dingdm.online/QQ%E6%88%AA%E5%9B%BE20200805152053.png" alt=""></p><p>切换到鼠标，点击右面的其他鼠标选项</p><p><img src="http://dingdm.online/QQ%E6%88%AA%E5%9B%BE20200805152109.png" alt=""></p><p>选择指针模块，浏览自己下载的鼠标资源进行替换即可。</p><p><img src="http://dingdm.online/QQ%E6%88%AA%E5%9B%BE20200805152118.png" alt=""></p><h3 id="开始菜单切片设置">开始菜单切片设置</h3><p>在win10系统自带的商店下载tile genie软件，下载成功后选择图片切割即可。</p><p>图片切片并不难，主要是需要耗费时间拼。</p><h3 id="win10壁纸设置">win10壁纸设置</h3><h4 id="wallpaper-engine">wallpaper engine</h4><p>这里有条件的小伙伴推荐去steam购买一个壁纸软件wallpaper engine，18块钱你买不了吃亏，你买不了上当。最重要的除了它是一款壁纸软件之外，它还是一块非常牛逼的射击游戏。</p><p>我这里推荐几个壁纸。或者你也可以去哔哩哔哩自行搜索相关的视频。</p><p>The Last of Us</p><p><img src="http://dingdm.online/eafa3cfba8c7a0f380fb792d3e310ffb.jpg" alt=""></p><p>Time lapse + 3D Digital Clock</p><p><img src="http://dingdm.online/d4aab6a9232e65e55778219d64bbd9b4.jpg" alt=""></p><p>Lamp</p><p><img src="http://dingdm.online/97bb304efc12b1e4525274e89bb980bf.jpg" alt=""></p><p>Alone</p><p><img src="http://dingdm.online/fee7c1563c02682d02d17ec00ab878e0.jpg" alt=""></p><p>PCB City</p><p><img src="http://dingdm.online/668df914429c2e529556b6e350b9e6b0.jpg" alt=""></p><h4 id="免费壁纸">免费壁纸</h4><p>如果不想购买的话我这里也推荐几个静态的免费的壁纸。</p><p><img src="http://dingdm.online/v2-02e8a470854063843938274a14cbe238_r.jpg" alt=""></p><p><img src="http://dingdm.online/v2-81b1f2f30d62487bb6f47ab08155cc69_r.jpg" alt=""></p><p><img src="http://dingdm.online/v2-8262525f9d0681e6b996bc758229f90c_r.jpg" alt=""></p><p><img src="http://dingdm.online/v2-c2c137fa7017fc27b454651dafb36b0f_r.jpg" alt=""></p><p><img src="http://dingdm.online/v2-dabcb2e02b94f7c8dfefae1ac7e4f591_r.jpg" alt=""></p><p><img src="http://dingdm.online/v2-db782cbaced5180b9037064ff9905afe_r.jpg" alt=""></p><p><img src="http://dingdm.online/v2-e35ed2b90501aea545ee73e2decebf6a_r.jpg" alt=""></p><p><img src="http://dingdm.online/v2-e3fd094f1f8555c4abcbf98ab9119d70_r.jpg" alt=""></p><p><img src="http://dingdm.online/v2-ff96a816315c9e7c28e48899c9f8df7e_r.jpg" alt=""></p><h4 id="壁纸网站">壁纸网站</h4><p><a href="https://hddesktopwallpapers.in/" target="_blank" rel="noopener">https://hddesktopwallpapers.in/</a></p><p><a href="http://simpledesktops.com/" target="_blank" rel="noopener">http://simpledesktops.com/</a></p><p><a href="http://www.obzhi.com/" target="_blank" rel="noopener">http://www.obzhi.com/</a></p><p><a href="https://ss.netnr.com/wallpaper" target="_blank" rel="noopener">https://ss.netnr.com/wallpaper</a></p><p><a href="http://spotlight.shijuewuyu.com/" target="_blank" rel="noopener">http://spotlight.shijuewuyu.com/</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 美化 </category>
          
          <category> 壁纸 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> win10 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>答辩知识架构及企业OA项目开发汇总</title>
      <link href="/2020/08/02/da-bian-zhi-shi-jia-gou-ji-qi-ye-oa-xiang-mu-kai-fa-hui-zong/"/>
      <url>/2020/08/02/da-bian-zhi-shi-jia-gou-ji-qi-ye-oa-xiang-mu-kai-fa-hui-zong/</url>
      
        <content type="html"><![CDATA[<h3 id="1-Vue框架">1.Vue框架</h3><p><strong>MVVM架构，model，view，viewmodel，model和view之间无法直接交互，通过viewmodel进行交互，创建新的模板，在模板中使用js函数创建监听器，使用vm_patch渲染页面完成数据模板的绑定，当数据更新时自动同步数据。view和model自动同步，开发人员只需要关注业务逻辑，而非操作dom对象。<br>前台使用VUE进行开发，Vue.js是一个构建数据驱动的web界面的渐进式框架。Vue的目标是通过尽可能简单API实现响应的数据绑定和组合的视图组件。核心是一个响应的数据绑定系统。即vue是单页面应用，页面局部刷新，不用每次跳转页面都去请求所有数据和dom对象，这样大大加快了访问速度和提升用户体验。而且他的第三方ui库可以节省很多不必要的开发时间。<br>选用Vue的原因中很重要的一点即为图中的MVVM架构，在MVVM中视图和模型是无法直接进行交互的，而他们中间存在着一个中转站，就是ViewModel。当用户对视图进行相关操作时，和视图相连的ViewModel中的一部分就会通知模型层内容的变化，同理，当模型变化时，ViewModel也可以通知试图层进行改变，这就是Vue中的双向数据绑定。类似于通知者通过关键字来通知订阅者的模式。<br>1.双向数据绑定实现浏览器页面的自动刷新。<br>2.轻量级js库，API简洁易用。<br>3.element-ui库</strong></p><h3 id="2-springboot框架">2.springboot框架</h3><p><strong>后台使用spring boot框架，spring boot 并不是用来替代 Spring 的解决方案，而是和 Spring 框架紧密结合用于提升 Spring 开发者体验的工具。同时它集成了大量常用的第三方库配置，Spring Boot应用中这些第三方库几乎可以是零配置的开箱即用（out-of-the-box），大部分的 Spring Boot 应用都只需要非常少量的配置代码（基于 Java 的配置），开发者能够更加专注于业务逻辑。<br>AOP为spring框架中切面编程的实现，AOP可以降低代码之间的耦合度，方便dang当前系统的扩展和代码复用，在OA系统中，我使用AOP进行日志的相关管理和操作。AOP的自定义标签从AopNamespaceHandler这个类开始解析，进入到AspectJAutoProxyBeanDefinitionParser解析器后，调用BeanDefinitionParser的parser方法将请求转交给registerAspectJAnnotationAutoProxyCreatorIfNecessary去实现。在注册或升级即registerAspectJAnnotationAutoProxyCreatorIfNecessary方法处理完成以后根据proxy-target-class的属性来确定使用什么方式的代理，最后调用registerComponentIfNecessary通知监听器。我在使用中正是运用了此流程，使用自定义的AOP注解，将注解注释在需要记录操作的接口方法上，通过通知类型来获取接口数据，进而和数据库交互存储对应的日志信息。<br>springboot是对spring框架的封装。<br>1.简化配置，无需配置xml<br>2.内置tomcat，可是使用maven打包成jar包之后直接在服务器上运行。<br>3.完美兼容当前成熟的开发组件。</strong></p><h3 id="3-前后端分离">3.前后端分离</h3><p><strong>前台通过ajax向后台restful风格的接口发起请求，获取json格式的数据进行解析展示。<br>1.前后端业务逻辑解耦。<br>2.分担后端服务器承受压力。<br>3.分开部署，解耦操作，更新方便。</strong></p><h3 id="4-JWT">4.JWT</h3><p><strong>由于后台管理系统采用了前后端分离开发的方式，那么就必然存在前端与后端的接口交互，于是就涉及到了安全问题，后端该如何确认收到的请求是合法的客户端发出的。普通的session中存储用户信息的方法在前后端交互中不可避免的会存在资源开销较大的问题，因此，在智慧谷OA系统的开发中，我使用了JWT来进行认证。JWT认证在用户登录时生成token，并且在下次接口请求时携带相同的token，不仅解决了资源开销的问题，而且JWT的信息使用HS256和RS256算法签名，保证了其在传输过程中的安全性。<br>JWT一共由三段内容组成，JWT在认证过程中，使用对称算法时，服务器端就获取到接收的JWT的前两段信息作为数据，用相同的算法和密钥进行签名，得到签名后将服务器端的签名和JWT中的第三段内容进行比较，如果相同认证即为成功。使用非对称加密算法时，由一对密钥构成，私钥由服务器端存储，公钥客户端存储，客户端进行验证的时候，用公钥解密收到的签名,得到JWT三段内容中的前两段，再用这两段内容和JWT进行比较，相同则验证成功。<br>由于JWT不能保证数据在传输中不被窃取，因此除了使用非对称加密算法之外，还需要在JWT的内容中设置合理的过期时间来确保数据的安全性。<br>session方式将用户信息存储到session中，session存储到内存中，当用户数据增多时，增大服务器的开销。<br>token方式将用户数据发送到服务器，服务器使用SHA256或其他算法计算token，客户端接收存储，在请求时将token存储于请求头中。</strong></p><h3 id="5-Activiti">5.Activiti</h3><p><img src="http://dingdm.online/9f2d207d579d4c7ea7114ab042429f0d.png" alt=""><br><strong>Activiti由图中模块构成，Activiti Engine为Activiti的核心，负责数据的处理，Activiti Modeler为模型设计器，Activities Rest支持Restful风格的服务，允许以JSON的格式进行交互，支持跨语言和跨平台。<br>Activiti组件使用Mybatis和数据库进行交互，完全契合当前的智慧谷OA系统，且Activiti具有简单易懂的接口和全面的流程设计器，适合任何人的使用与开发。而Activiti原生支持spring这一特性大大减少了在开发过程中的难度和工作量。<br>引入官方依赖，使用Activiti的可视化流程编辑器整合。<br>编写对应的流程方法和监听器。</strong></p><h3 id="前端代码">前端代码</h3><pre class=" language-language-html"><code class="language-language-html">**配置**<!-- 开发环境 -->  &lt;% if (process.env.VUE_APP_NODE_ENV === 'dev') { %&gt;    <script>window.SITE_CONFIG['apiURL'] = 'http://127.0.0.1:8081/wisdom';</script>  &lt;% } %&gt;  <!-- 集成测试环境 -->  &lt;% if (process.env.VUE_APP_NODE_ENV === 'prod:sit') { %&gt;    <script>window.SITE_CONFIG['apiURL'] = 'http://47.100.126.191:8081/wisdom';</script>  &lt;% } %&gt;  <!-- 验收测试环境 -->  &lt;% if (process.env.VUE_APP_NODE_ENV === 'prod:uat') { %&gt;    <script>window.SITE_CONFIG['apiURL'] = 'http://47.100.126.191:8081/wisdom';</script>  &lt;% } %&gt;  <!-- 生产环境 -->  &lt;% if (process.env.VUE_APP_NODE_ENV === 'prod') { %&gt;    <script>window.SITE_CONFIG['apiURL'] = 'http://47.100.126.191:8081/wisdom';</script>  &lt;% } %&gt;</code></pre><p><strong>数据接口</strong></p><pre class=" language-language-javascript"><code class="language-language-javascript">export default {  data () {    /* eslint-disable */    return {      // 设置属性      mixinViewModuleOptions: {        activatedIsNeed: true,    // 此页面是否在激活（进入）时，调用查询数据列表接口？        getDataListURL: '',       // 数据列表接口，API地址        getDataListIsPage: false, // 数据列表接口，是否需要分页？        deleteURL: '',            // 删除接口，API地址        deleteIsBatch: false,     // 删除接口，是否需要批量？        deleteIsBatchKey: 'id',   // 删除接口，批量状态下由那个key进行标记操作？比如：pid，uid...        exportURL: ''             // 导出接口，API地址      },      // 默认属性      dataForm: {},               // 查询条件      dataList: [],               // 数据列表      order: 'desc',                  // 排序，asc／desc      orderField: 'create_date',             // 排序，字段      page: 1,                    // 当前页码      limit: 10,                  // 每页数      total: 0,                   // 总条数      dataListLoading: false,     // 数据列表，loading状态      dataListSelections: [],     // 数据列表，多选项      addOrUpdateVisible: false   // 新增／更新，弹窗visible状态    }    /* eslint-enable */  },  activated () {    if (this.mixinViewModuleOptions.activatedIsNeed) {      this.getDataList()    }  },  methods: {    // 获取数据列表    getDataList () {      this.dataListLoading = true      this.$http.get(        this.mixinViewModuleOptions.getDataListURL,        {          params: {            order: this.order,            orderField: this.orderField,            page: this.mixinViewModuleOptions.getDataListIsPage ? this.page : null,            limit: this.mixinViewModuleOptions.getDataListIsPage ? this.limit : null,            ...this.dataForm          }        }      ).then(({ data: res }) =&gt; {        this.dataListLoading = false        if (res.code !== 0) {          this.dataList = []          this.total = 0          return this.$message.error(res.msg)        }        this.dataList = this.mixinViewModuleOptions.getDataListIsPage ? res.data.list : res.data        this.total = this.mixinViewModuleOptions.getDataListIsPage ? res.data.total : 0      }).catch(() =&gt; {        this.dataListLoading = false      })    },    // 多选    dataListSelectionChangeHandle (val) {      this.dataListSelections = val    },    // 排序    dataListSortChangeHandle (data) {      if (!data.order || !data.prop) {        this.order = ''        this.orderField = ''        return false      }      this.order = data.order.replace(/ending$/, '')      this.orderField = data.prop.replace(/([A-Z])/g, '_$1').toLowerCase()      this.getDataList()    },    // 分页, 每页条数    pageSizeChangeHandle (val) {      this.page = 1      this.limit = val      this.getDataList()    },    // 分页, 当前页    pageCurrentChangeHandle (val) {      this.page = val      this.getDataList()    },    // 新增 / 修改    addOrUpdateHandle (id) {      this.addOrUpdateVisible = true      this.$nextTick(() =&gt; {        this.$refs.addOrUpdate.dataForm.id = id        this.$refs.addOrUpdate.init()      })    },    // 删除    deleteHandle (id) {      if (this.mixinViewModuleOptions.deleteIsBatch &amp;&amp; !id &amp;&amp; this.dataListSelections.length &lt;= 0) {        return this.$message({          message: this.$t('prompt.deleteBatch'),          type: 'warning',          duration: 500        })      }      this.$confirm(this.$t('prompt.info', { 'handle': this.$t('delete') }), this.$t('prompt.title'), {        confirmButtonText: this.$t('confirm'),        cancelButtonText: this.$t('cancel'),        type: 'warning'      }).then(() =&gt; {        this.$http.delete(          `${this.mixinViewModuleOptions.deleteURL}${this.mixinViewModuleOptions.deleteIsBatch ? '' : '/' + id}`,          this.mixinViewModuleOptions.deleteIsBatch ? {            'data': id ? [id] : this.dataListSelections.map(item =&gt; item[this.mixinViewModuleOptions.deleteIsBatchKey])          } : {}        ).then(({ data: res }) =&gt; {          if (res.code !== 0) {            return this.$message.error(res.msg)          }          this.$message({            message: this.$t('prompt.success'),            type: 'success',            duration: 500,            onClose: () =&gt; {              this.getDataList()            }          })        }).catch(() =&gt; {})      }).catch(() =&gt; {})    },    // 导出    exportHandle () {      var params = qs.stringify({        'token': Cookies.get('token'),        ...this.dataForm      })      window.location.href = `${window.SITE_CONFIG['apiURL']}${this.mixinViewModuleOptions.exportURL}?${params}`    }  }</code></pre><p><strong>缓存</strong></p><pre class=" language-language-javascript"><code class="language-language-javascript">export default new Vuex.Store({  namespaced: true,  state: {    // 导航条, 布局风格, defalut(白色) / colorful(鲜艳)    navbarLayoutType: 'colorful',    // 侧边栏, 布局皮肤, default(白色) / dark(黑色)    sidebarLayoutSkin: 'dark',    // 侧边栏, 折叠状态    sidebarFold: false,    // 侧边栏, 菜单    sidebarMenuList: [],    sidebarMenuActiveName: '',    // 内容, 是否需要刷新    contentIsNeedRefresh: false,    ip: 'http://47.100.126.191:8081',    // 内容, 标签页(默认添加首页)    contentTabs: [      {        ...window.SITE_CONFIG['contentTabDefault'],        'name': 'home',        'title': 'home'      }    ],    contentTabsActiveName: 'home'  },  modules: {    user  },  mutations: {    // 重置vuex本地储存状态    resetStore (state) {      Object.keys(state).forEach((key) =&gt; {        state[key] = cloneDeep(window.SITE_CONFIG['storeState'][key])      })    }  }})</code></pre><p><strong>国际化</strong></p><pre class=" language-language-javascript"><code class="language-language-javascript"><script>import Cookies from 'js-cookie'import { messages } from '@/i18n'export default {  watch: {    '$i18n.locale': 'i18nHandle'  },  created () {    this.i18nHandle(this.$i18n.locale)  },  methods: {    i18nHandle (val, oldVal) {      Cookies.set('language', val)      document.querySelector('html').setAttribute('lang', val)      document.title = messages[val].brand.lg      // 非登录页面，切换语言刷新页面      if (this.$route.name !== 'login' && oldVal) {        window.location.reload()      }    }  }}</script></code></pre><h3 id="后台相关代码">后台相关代码</h3><p><strong>请求头token验证</strong></p><pre class=" language-language-java"><code class="language-language-java">public class Oauth2Filter extends AuthenticatingFilter {    @Override    protected AuthenticationToken createToken(ServletRequest request, ServletResponse response) throws Exception {        //获取请求token        String token = getRequestToken((HttpServletRequest) request);        if(StringUtils.isBlank(token)){            return null;        }        return new Oauth2Token(token);    }    @Override    protected boolean isAccessAllowed(ServletRequest request, ServletResponse response, Object mappedValue) {        if(((HttpServletRequest) request).getMethod().equals(RequestMethod.OPTIONS.name())){            return true;        }        return false;    }    @Override    protected boolean onAccessDenied(ServletRequest request, ServletResponse response) throws Exception {        //获取请求token，如果token不存在，直接返回401        String token = getRequestToken((HttpServletRequest) request);        if(StringUtils.isBlank(token)){            HttpServletResponse httpResponse = (HttpServletResponse) response;            httpResponse.setContentType("application/json;charset=utf-8");            httpResponse.setHeader("Access-Control-Allow-Credentials", "true");            httpResponse.setHeader("Access-Control-Allow-Origin", HttpContextUtils.getOrigin());            String json = new Gson().toJson(new Result().error(ErrorCode.UNAUTHORIZED));            httpResponse.getWriter().print(json);            return false;        }        return executeLogin(request, response);    }    @Override    protected boolean onLoginFailure(AuthenticationToken token, AuthenticationException e, ServletRequest request, ServletResponse response) {        HttpServletResponse httpResponse = (HttpServletResponse) response;        httpResponse.setContentType("application/json;charset=utf-8");        httpResponse.setHeader("Access-Control-Allow-Credentials", "true");        httpResponse.setHeader("Access-Control-Allow-Origin", HttpContextUtils.getOrigin());        try {            //处理登录失败的异常            Throwable throwable = e.getCause() == null ? e : e.getCause();            Result r = new Result().error(HttpStatus.SC_UNAUTHORIZED, throwable.getMessage());            String json = new Gson().toJson(r);            httpResponse.getWriter().print(json);        } catch (IOException e1) {        }        return false;    }    /**     * 获取请求的token     */    private String getRequestToken(HttpServletRequest httpRequest){        //从header中获取token        String token = httpRequest.getHeader(Constant.TOKEN_HEADER);        //如果header中不存在token，则从参数中获取token        if(StringUtils.isBlank(token)){            token = httpRequest.getParameter(Constant.TOKEN_HEADER);        }        return token;    }}</code></pre><p><strong>验证授权</strong></p><pre class=" language-language-java"><code class="language-language-java">@Componentpublic class Oauth2Realm extends AuthorizingRealm {    @Autowired    private ShiroService shiroService;    @Override    public boolean supports(AuthenticationToken token) {        return token instanceof Oauth2Token;    }    /**     * 授权(验证权限时调用)     */    @Override    protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) {        UserDetail user = (UserDetail)principals.getPrimaryPrincipal();        //用户权限列表        Set<string> permsSet = shiroService.getUserPermissions(user);        SimpleAuthorizationInfo info = new SimpleAuthorizationInfo();        info.setStringPermissions(permsSet);        return info;    }    /**     * 认证(登录时调用)     */    @Override    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException {        String accessToken = (String) token.getPrincipal();        //根据accessToken，查询用户信息        SysUserTokenEntity tokenEntity = shiroService.getByToken(accessToken);        //token失效        if(tokenEntity == null || tokenEntity.getExpireDate().getTime() &lt; System.currentTimeMillis()){            throw new IncorrectCredentialsException(MessageUtils.getMessage(ErrorCode.TOKEN_INVALID));        }        //查询用户信息        SysUserEntity userEntity = shiroService.getUser(tokenEntity.getUserId());        //转换成UserDetail对象        UserDetail userDetail = ConvertUtils.sourceToTarget(userEntity, UserDetail.class);        //获取用户对应的部门数据权限        List<long> deptIdList = shiroService.getDataScopeList(userDetail.getId());        userDetail.setDeptIdList(deptIdList);        //账号锁定        if(userDetail.getStatus() == 0){            throw new LockedAccountException(MessageUtils.getMessage(ErrorCode.ACCOUNT_LOCK));        }        SimpleAuthenticationInfo info = new SimpleAuthenticationInfo(userDetail, accessToken, getName());        return info;    }}</long></string></code></pre><p><strong>token生成</strong></p><pre class=" language-language-java"><code class="language-language-java">public class TokenGenerator {    public static String generateValue() {        return generateValue(UUID.randomUUID().toString());    }    private static final char[] HEX_CODE = "0123456789abcdef".toCharArray();    public static String toHexString(byte[] data) {        if(data == null) {            return null;        }        StringBuilder r = new StringBuilder(data.length*2);        for ( byte b : data) {            r.append(HEX_CODE[(b &gt;&gt; 4) &amp; 0xF]);            r.append(HEX_CODE[(b &amp; 0xF)]);        }        return r.toString();    }    public static String generateValue(String param) {        try {            MessageDigest algorithm = MessageDigest.getInstance("MD5");            algorithm.reset();            algorithm.update(param.getBytes());            byte[] messageDigest = algorithm.digest();            return toHexString(messageDigest);        } catch (Exception e) {            throw new RenException("token invalid", e);        }    }}</code></pre><p><strong>监听器</strong></p><pre class=" language-language-java"><code class="language-language-java">public class LeaderListenImpl implements TaskListener{    @Override    public void notify(DelegateTask delegateTask) {        ServletRequestAttributes requestAttributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();        HttpServletRequest request = requestAttributes.getRequest();        WebApplicationContext webApplicationContext = WebApplicationContextUtils.getWebApplicationContext(request.getServletContext());        SysUserService userService = webApplicationContext.getBean(SysUserService.class);        List<string> strings = new ArrayList<string>();        List<sysuserdto> list = userService.getUserByRole(RoleEnum.LEADER.value());        for (SysUserDTO user : list) {            strings.add(user.getUsername());        }        delegateTask.addCandidateUsers(strings);        ApprovalTbService approvalTbService = webApplicationContext.getBean(ApprovalTbService.class);        ApprovalTbDTO approvalTbDTO = (ApprovalTbDTO) delegateTask.getVariable(ActivitiEnum.APPROVAL.value());        approvalTbService.updateType(RoleEnum.LEADERNAME.value(),approvalTbDTO.getId());        if(list.size() &gt; 0){            Long dealId = (Long) delegateTask.getVariable(ActivitiEnum.DEALID.value());            UtilService utilService = webApplicationContext.getBean(UtilService.class);            utilService.updateDeal(dealId,list);        }    }}</sysuserdto></string></string></code></pre><p><strong>定时任务</strong></p><pre class=" language-language-java"><code class="language-language-java">@Component("downTask")public class DownTask implements ITask{private Logger logger = LoggerFactory.getLogger(getClass());@Autowiredprivate ActivityService activityService;@Overridepublic void run(String params){List<activitydto> allActivity = activityService.getAllActivity(ActivityEnum.DOWN.value());if(allActivity.size() &gt; 0){for(ActivityDTO activityDTO : allActivity){activityService.changeState(activityDTO.getId());logger.debug(activityDTO.getId() + "资源已释放！");}}}}</activitydto></code></pre><h3 id="企业项目淮安智慧谷OA相关文件">企业项目淮安智慧谷OA相关文件</h3><h4 id="文档文件">文档文件</h4><p><a href="http://dingdm.online/%E6%99%BA%E6%85%A7%E8%B0%B7OA-%E5%8E%9F%E5%A7%8B%E9%9C%80%E6%B1%8220200110.doc" target="_blank" rel="noopener">智慧谷OA-原始需求20200110.doc</a></p><p><a href="http://dingdm.online/%E6%99%BA%E6%85%A7%E8%B0%B7OA-%E5%88%9D%E6%AD%A5%E9%9C%80%E6%B1%8220200112.docx" target="_blank" rel="noopener">智慧谷OA-初步需求20200112.docx</a></p><p><a href="http://dingdm.online/%E7%B3%BB%E7%BB%9F%E5%AE%8C%E5%96%84%E9%9C%80%E6%B1%82.docx" target="_blank" rel="noopener">系统完善需求.doc</a></p><p><a href="http://dingdm.online/%E7%B3%BB%E7%BB%9F%E5%AE%8C%E5%96%84%E9%9C%80%E6%B1%822.docx" target="_blank" rel="noopener">系统完善需求2.doc</a></p><p><a href="http://dingdm.online/%E5%89%A9%E4%BD%99%E5%A4%84%E7%90%86%E9%A1%B9.docx" target="_blank" rel="noopener">剩余处理项.doc</a></p><p><a href="http://dingdm.online/%E5%89%A9%E4%BD%99%E5%A4%84%E7%90%86%E9%A1%B93.docx" target="_blank" rel="noopener">剩余处理项3.doc</a></p><p><a href="http://dingdm.online/%E5%89%A9%E4%BD%99%E5%A4%84%E7%90%86%E9%A1%B94.1.docx" target="_blank" rel="noopener">剩余处理项4.1.doc</a></p><p><a href="http://dingdm.online/%E5%89%A9%E4%BD%99%E5%A4%84%E7%90%86%E9%A1%B95-%E6%9C%80%E6%96%B0.docx" target="_blank" rel="noopener">剩余处理项4.5-最新.doc</a></p><p><a href="http://dingdm.online/%E5%89%A9%E4%BD%99%E5%A4%84%E7%90%86%E9%A1%B94.2--%E5%A4%84%E7%90%86%E7%BB%93%E6%9E%9C.docx" target="_blank" rel="noopener">剩余处理项4.2.doc</a></p><p><a href="http://dingdm.online/11.27%E5%AE%8C%E5%96%84%E6%95%B4%E7%90%86.docx" target="_blank" rel="noopener">11.27完善整理.doc</a></p><p><a href="http://dingdm.online/11.27%E5%AE%8C%E5%96%84%E6%95%B4%E7%90%86%20-%20%E5%8F%8D%E9%A6%88.docx" target="_blank" rel="noopener">11.27完善整理 - 反馈.doc</a></p><p><a href="http://dingdm.online/1.21.docx" target="_blank" rel="noopener">1.9 后台测试反馈.doc</a></p><p><a href="http://dingdm.online/1.21.docx" target="_blank" rel="noopener">1.21.doc</a></p><p><a href="http://dingdm.online/%E9%A1%B9%E7%9B%AE%E4%BF%A1%E6%81%AF.xlsx" target="_blank" rel="noopener">资产管理模块需求-二期-暂时不做.docx</a></p><h4 id="表单文件">表单文件</h4><p><a href="http://dingdm.online/%E6%9D%A5%E8%AE%BF%E8%A1%A8%E5%8D%95.docx" target="_blank" rel="noopener">来访表单.doc</a></p><p><a href="http://dingdm.online/%E6%B4%BB%E5%8A%A8%E7%94%B3%E8%AF%B7%E8%A1%A8%E5%8D%95.docx" target="_blank" rel="noopener">活动申请表单.doc</a></p><h4 id="xlsx导入模板">xlsx导入模板</h4><p><a href="http://dingdm.online/%E9%A1%B9%E7%9B%AE%E4%BF%A1%E6%81%AF.xlsx" target="_blank" rel="noopener">项目信息.xlsx</a></p><p><a href="http://dingdm.online/%E4%BA%BA%E6%89%8D%E4%BF%A1%E6%81%AF.xlsx" target="_blank" rel="noopener">人才信息.xlsx</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 项目开发 </category>
          
          <category> 答辩 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
            <tag> JWT </tag>
            
            <tag> Avtiviti </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>红黑树</title>
      <link href="/2020/08/01/hong-hei-shu/"/>
      <url>/2020/08/01/hong-hei-shu/</url>
      
        <content type="html"><![CDATA[<h3 id="为什么要使用红黑树">为什么要使用红黑树</h3><p><strong>当冲突的链表长度超过8个时，链表结构就会转为红黑树结构，这样做的好处是避免在极端条件的情况下冲突链表过长而导致查询效率非常慢</strong><br><strong>红黑树是一种近似平衡的二叉查找树，其主要的优点就是平衡，即左右子树高度几乎一致，以此来防止树退化为链表，通过这种方式来保障查找的时间复杂度为log(n)</strong></p><h3 id="红黑树">红黑树</h3><p><img src="http://dingdm.online/QQ%E6%88%AA%E5%9B%BE20200626184132.png" alt="红黑树" title="红黑树"></p><table><thead><tr><th>红黑树要求</th></tr></thead><tbody><tr><td>1.每个节点或者是黑色，或者是红色</td></tr><tr><td>2.根节点是黑色</td></tr><tr><td>3.每个叶子结点（这里的叶子结点不是传统的叶子结点，是指为空的叶子结点）是黑色</td></tr><tr><td>4.如果一个结点是红色的，则它的子结点必须是黑色的</td></tr><tr><td>5.从一个结点到该结点的子孙结点的所有路径上包含相同数目的黑结点</td></tr><tr><td>6.新加入到红黑树的节点为红色节点</td></tr></tbody></table><p><strong>在树的结构发生改变时，往往会破坏红色节点的孩子和父亲都不能是红色的和从任意节点到其子树中每个叶子结点的路径有相同数量的黑色节点这两个条件，需要通过调整使得查找树重新满足红黑树的条件</strong></p><h3 id="调整方式">调整方式</h3><h4 id="颜色调整">颜色调整</h4><p><strong>转换节点的颜色</strong></p><h4 id="结构调整">结构调整</h4><h5 id="左旋">左旋</h5><p><img src="http://dingdm.online/QQ%E6%88%AA%E5%9B%BE20200626185320.png" alt="左旋" title="左旋"></p><table><thead><tr><th>序号</th><th>步骤</th></tr></thead><tbody><tr><td>1</td><td>Y的左孩子设为X的右孩子，即β的父亲为X</td></tr><tr><td>2</td><td>将X的父亲设为Y的父亲</td></tr><tr><td>2.1</td><td>若X的父亲为空，则Y为根节点</td></tr><tr><td>2.2</td><td>X为他父亲的左节点，则Y为X父亲的左节点；X为他父亲的右节点，则Y为X父亲的右节点</td></tr><tr><td>3</td><td>X设为Y的左节点，即X的父亲为Y</td></tr></tbody></table><pre class=" language-language-java"><code class="language-language-java">static final class TreeNode<k,v> extends LinkedHashMap.Entry<k,v> {    //指向父节点的指针 TreeNode<k,v> parent;    //指向左孩子的指针 TreeNode<k,v> left;    //指向右孩子的指针 TreeNode<k,v> right;    //前驱指针，跟next属性相反的指向 TreeNode<k,v> prev;    //是否为红色节点 boolean red;    //左旋方法如下    static <k, v=""> TreeNode<k, v=""> rotateLeft(TreeNode<k, v=""> root,                                            TreeNode<k, v=""> x) {        TreeNode<k, v=""> y, parent, β;//x表示要调整的节点，y表示x的右节点，parent表示x的parent节点，β表示x的右孩子的左孩子节点        //判断y，如果y为空则旋转没有意义        if (y != null &amp;&amp; (β = y.left) != null) {            //设置的β父亲为x，β为x的右节点            if ((β = y.left) != null)                x.right = β;            //判断x的父亲，为空，y为根节点，根节点的话就设置为黑色            if ((parent = x.parent ) == null)                (root = y).red = false;                //判断x节点是左儿子还是右儿子            else if (parent.left == x)                parent.left = y;            else                parent.right = y;            y.left = x;            x.parent = y;        }        return root;    }}</k,></k,></k,></k,></k,></k,v></k,v></k,v></k,v></k,v></k,v></code></pre><h5 id="右旋">右旋</h5><p><img src="http://dingdm.online/QQ%E6%88%AA%E5%9B%BE20200626191905.png" alt="右旋" title="右旋"><br><strong>右旋和左旋的原理相同</strong></p><h5 id="插入新节点调整">插入新节点调整</h5><p><img src="http://dingdm.online/QQ%E6%88%AA%E5%9B%BE20200626192839.png" alt="插入" title="插入"><br><strong>插入新节点为红色是为了不违背特性5</strong><br><strong>当前节点(即，被插入节点)的父节点是红色，且当前节点的祖父节点的另一个子节点（叔叔节点）也是红色</strong><br><strong>(1) 将“父节点”设为黑色。<br>(2) 将“叔叔节点”设为黑色。<br>(3) 将“祖父节点”设为“红色”。<br>(4) 将“祖父节点”设为“当前节点”(红色节点)；即，之后继续对“当前节点”进行操作</strong><br><img src="http://dingdm.online/QQ%E6%88%AA%E5%9B%BE20200626193021.png" alt="调整" title="调整"><br><strong>“当前节点”和“父节点”都是红色，违背“特性(4)”。将“父节点”设置“黑色”以解决这个问题。<br>但是，将“父节点”由“红色”变成“黑色”之后，违背了“特性(5)”：因为，包含“父节点”的分支的黑色节点的总数增加了1。 解决这个问题的办法是：将“祖父节点”由“黑色”变成红色，同时，将“叔叔节点”由“红色”变成“黑色”。关于这里，说明几点：第一，为什么“祖父节点”之前是黑色？这个应该很容易想明白，因为在变换操作之前，该树是红黑树，“父节点”是红色，那么“祖父节点”一定是黑色。 第二，为什么将“祖父节点”由“黑色”变成红色，同时，将“叔叔节点”由“红色”变成“黑色”；能解决“包含‘父节点’的分支的黑色节点的总数增加了1”的问题。这个道理也很简单。“包含‘父节点’的分支的黑色节点的总数增加了1” 同时也意味着 “包含‘祖父节点’的分支的黑色节点的总数增加了1”，既然这样，我们通过将“祖父节点”由“黑色”变成“红色”以解决“包含‘祖父节点’的分支的黑色节点的总数增加了1”的问题； 但是，这样处理之后又会引起另一个问题“包含‘叔叔’节点的分支的黑色节点的总数减少了1”，现在我们已知“叔叔节点”是“红色”，将“叔叔节点”设为“黑色”就能解决这个问题。 所以，将“祖父节点”由“黑色”变成红色，同时，将“叔叔节点”由“红色”变成“黑色”；就解决了该问题。<br>按照上面的步骤处理之后：当前节点、父节点、叔叔节点之间都不会违背红黑树特性，但祖父节点却不一定。若此时，祖父节点是根节点，直接将祖父节点设为“黑色”，那就完全解决这个问题了；若祖父节点不是根节点，那我们需要将“祖父节点”设为“新的当前节点”，接着对“新的当前节点”进行分析。</strong><br><img src="http://dingdm.online/QQ%E6%88%AA%E5%9B%BE20200626193519.png" alt=""><br><img src="http://dingdm.online/QQ%E6%88%AA%E5%9B%BE20200626193543.png" alt=""></p><h5 id="红黑树的查询">红黑树的查询</h5><p><img src="http://dingdm.online/QQ%E6%88%AA%E5%9B%BE20200626193712.png" alt="红黑树查询" title="红黑树查询"></p><h5 id="红黑树的删除">红黑树的删除</h5><h6 id="被删除的D节点为红色。这种情况，则与D相关的颜色以及结构关系必然只有如下一种情况">被删除的D节点为红色。这种情况，则与D相关的颜色以及结构关系必然只有如下一种情况</h6><p><img src="http://dingdm.online/317300-20160505091642982-1989959722.png" alt="D节点为红色" title="D节点为红色"><br><strong>因为D为红色，所以P为黑色，同时DR不可能为红色(否则违反性质4)。同时由于性质5，则DR必为Nil，否则就D树来说，经过DR与不经过DR的路径的黑节点数必不相同。现在要删除D节点，只需要直接将D节点删除，并将DR作为P的左子节点</strong></p><h6 id="被删除的D节点为黑色">被删除的D节点为黑色</h6><p><img src="http://dingdm.online/317300-20160505091836732-1760252339.png" alt="D为黑色" title="D为黑色"><br><strong>由于删除的D为黑色，删除后P的左子树的黑节点数必少1，此时刚好DR为黑色，并且删除后DR可以占据D的位置，然后再将DR的颜色改为黑色，刚好可以填补P左子树所减少的黑节点数。</strong></p><h6 id="被删除的D为黑色，且DR为Nil">被删除的D为黑色，且DR为Nil</h6><p><img src="http://dingdm.online/317300-20160505091941513-167154460.png" alt=""><br><img src="http://dingdm.online/317300-20160505092013701-2109174939.png" alt=""><br><strong>转换后，虽然对于P树的左子树的黑节点数仍然会比右子树的黑节点数少1，但此时DR的兄弟(以前的S节点)现在已经变为SL，即已经由红色变为黑色，并且非常重要的此时的DR的兄弟节点SL的子结点(即：DR的两个侄子节点)，要不就是红色节点要不就必为Nil节点，而这种情况正是D为黑色、S也黑色的情况</strong></p><p><strong>所有图片来源于网络。</strong></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HashMap </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo插件及优化</title>
      <link href="/2020/07/31/hexo-cha-jian-tui-jian/"/>
      <url>/2020/07/31/hexo-cha-jian-tui-jian/</url>
      
        <content type="html"><![CDATA[<h3 id="hexo常用插件及优化">hexo常用插件及优化</h3><p>这里使用的主题为matery，闪烁之狐，matery主题的<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank" rel="noopener">github</a>仓库，作者提供的文档里已经给出了像代码高亮，拼音转换等插件，所以本文介绍的是除了作者提供的之外的其他简约插件。</p><h4 id="matery使用需知">matery使用需知</h4><h5 id="背景粒子和彩带设置">背景粒子和彩带设置</h5><p>matery的主题提供了这几项功能，但是默认是没有开启的，因此使用该主题需要手动开启，在themes/hexo-theme-matery目录下的_config.yml配置文件中修改以下几项。</p><pre class=" language-language-yml"><code class="language-language-yml">#背景canvas-nestcanvas_nest:  enable: true  color: 0,0,255 # 线条颜色, 默认: '0,0,0' ；三个数字分别为(R,G,B)，注意用,分$  pointColor: 0,0,255 # 交点颜色, 默认: '0,0,0' ；三个数字分别为(R,G,B)，注意$  opacity: 0.7 # 线条透明度（0~1）, 默认: 0.5  zIndex: -1 # 背景的 z-index 属性，css 属性用于控制所在层的位置, 默认: -1.  count: 99 # 线条的总数量, 默认: 99  # 背景静止彩带.ribbon:  enable: true  size: 150 # 彩带大小, 默认: 90.  alpha: 0.6 # 彩带透明度 (0 ~ 1), 默认: 0.6.  zIndex: -1 # 背景的z-index属性，css属性用于控制所在层的位置, 默认: -1.  clickChange: false  # 设置是否每次点击都更换彩带.# 背景动态彩带.ribbon_dynamic:  enable: true</code></pre><p>enable选项设置为true即可。</p><p>因为我这里的hexo博客是放在我的阿里云服务器上的，因此如果要修改内容我推荐smartty软件进行远程并修改文件相对方便。</p><h5 id="导航栏以及底部的配色修改">导航栏以及底部的配色修改</h5><p>matery的自带的导航栏鲜艳的配色有点问题，所以这里可以自己修改一下。</p><p>在主题下source下的css目录下，修改matery.css。分别修改第268和280行。</p><pre class=" language-language-css"><code class="language-language-css">.bg-color {    background-image: linear-gradient(to right, #4cbf30 0%, #0f9d58 100%);}.progress-bar {    height: 4px;    position: fixed;    bottom: 0;    z-index: 300;    background: linear-gradient(to right, #4cbf30 0%, #0f9d58 100%);    opacity: 0.8;}</code></pre><p>我这里修改为#4cbf30 0%, #0f9d58 100%</p><p><img src="http://dingdm.online/%E6%B8%90%E5%8F%98.png" alt=""></p><p>你也可以修改为自己看着好看的颜色，我这里放上几个配色的网站，可以由自己选择。</p><p><a href="https://coolors.co/" target="_blank" rel="noopener">https://coolors.co/</a></p><p><a href="http://www.materialpalette.com/" target="_blank" rel="noopener">http://www.materialpalette.com/</a></p><h5 id="轮播图和笔记展示图">轮播图和笔记展示图</h5><p>如果你在写笔记的时候不想自己上传封面的话而使用默认的图片的话，这里可以对封面的图片进行重新上传，选择好看的即可。</p><p>分别替换掉主题下source下medias中的banner和featureimages这两个文件夹下的图片即可。</p><p>同时如果想要增加featureimages下的图片，还需同步更改主题下_config.yml配置文件里的featureImages模块</p><pre class=" language-language-yml"><code class="language-language-yml"># The post featured images that needs to be displayed when there is no image.# 无文章特色图片时需要显示的文章特色图片.featureImages:- /medias/featureimages/0.jpg- /medias/featureimages/1.jpg- /medias/featureimages/2.jpg- /medias/featureimages/3.jpg- /medias/featureimages/4.jpg- /medias/featureimages/5.jpg- /medias/featureimages/6.jpg- /medias/featureimages/7.jpg- /medias/featureimages/8.jpg- /medias/featureimages/9.jpg- /medias/featureimages/10.jpg- /medias/featureimages/11.jpg- /medias/featureimages/12.jpg- /medias/featureimages/13.jpg- /medias/featureimages/14.jpg- /medias/featureimages/15.jpg- /medias/featureimages/16.jpg- /medias/featureimages/17.jpg- /medias/featureimages/18.jpg- /medias/featureimages/19.jpg- /medias/featureimages/20.jpg- /medias/featureimages/21.jpg- /medias/featureimages/22.jpg- /medias/featureimages/23.jpg</code></pre><p>同样，这里提供几个图片网站。替换图片时，图片的分辨率无需修改。</p><p><a href="https://wallhaven.cc/(%E8%B6%85%E6%A3%92)" target="_blank" rel="noopener">https://wallhaven.cc/(超棒)</a></p><p><a href="https://konachan.net/post" target="_blank" rel="noopener">https://konachan.net/post</a></p><h3 id="看板娘插件">看板娘插件</h3><p>注：如果你使用了matery的卜算子来统计数据的话，官方的helper-live的看板娘插件会使卜算子失效，同时官方提供的插件功能也较少，我这里推荐使用<a href="https://github.com/stevenjoezhang/live2d-widget" target="_blank" rel="noopener">该插件</a>。</p><p>如果是新手可以直接使用作者提供的js即可。</p><p><a href="https://cdn.jsdelivr.net/gh/stevenjoezhang/live2d-widget@latest/autoload.js" target="_blank" rel="noopener">https://cdn.jsdelivr.net/gh/stevenjoezhang/live2d-widget@latest/autoload.js</a></p><p>如果使用这个插件，会覆盖原matery主题的吸底模式的音乐播放插件。这里提供两种方式解决。</p><h4 id="fork新的仓库">fork新的仓库</h4><p>通过fork作者新的仓库，修改对应的css和js文件，这里在作者的github仓库下有对应的介绍，因此不再赘述。</p><p><img src="http://dingdm.online/fork.png" alt=""></p><p>修改适合自己的css和js文件后，发布新的版本，使用github的cdn加速获取js即可。</p><p>src=“<a href="https://cdn.jsdelivr.net/gh/username/live2d-widget@latest/autoload.js" target="_blank" rel="noopener">https://cdn.jsdelivr.net/gh/username/live2d-widget@latest/autoload.js</a>”</p><p>将这里的用户名替换自己的即可。若直接访问js文件访问失败403的话，因为缓存的原因可能不能显示，但是在自己的博客使用没有问题。</p><h4 id="修改吸底模式的音乐插件。">修改吸底模式的音乐插件。</h4><p>因为修改看板娘的文件之后还要修改回到顶端插件，如果你设置了在线聊天也要修改。如果你这里不想麻烦的话，直接将音乐插件的吸底模式取消即可。</p><p>在主题下的_config.yml配置文件中，修改music模块。将吸底模式关闭即可。</p><pre class=" language-language-yml"><code class="language-language-yml"># Whether to display the musics.# 是否在首页显示音乐.music:  enable: true  title: #非吸底模式有效    enable: true    show: 听听音乐  autoHide: true    # hide automaticaly  server: netease   #requiremusic platform: netease, tencent, kugou, xiami, baidu  type: playlist    #require song, playlist, album, search, artist  id: 503838841     #requiresong id / playlist id / album id / search keyword  fixed: false       # 开启吸底模式  autoplay: false   # 是否自动播放  theme: '#42b983'  loop: 'all'       # 音频循环播放, 可选值: 'all', 'one', 'none'  order: 'random'   # 音频循环顺序, 可选值: 'list', 'random'  preload: 'auto'   # 预加载，可选值: 'none', 'metadata', 'auto'  volume: 0.7       # 默认音量，请注意播放器会记忆用户设置，用户手动设置音量后默认音量即失效  listFolded: true  # 列表默认折叠  hideLrc: true     # 隐藏歌词</code></pre><h3 id="小地球插件">小地球插件</h3><p>小地球插件的地址<br><a href="https://www.revolvermaps.com/?target=setupgl">https://www.revolvermaps.com/?target=setupgl</a></p><p><img src="http://dingdm.online/%E5%B0%8F%E5%9C%B0%E7%90%83.png" alt=""></p><p>复制上面的srcipt标签放在自己的博客中合适的位置即可。</p><h3 id="天气插件">天气插件</h3><p>生成js地址</p><p><a href="https://cj.weather.com.cn/plugin/index" target="_blank" rel="noopener">https://cj.weather.com.cn/plugin/index</a></p><p>根据自己的需求选择对应的插件即可，我这里选择的是简约插件，UI比较漂亮</p><p><img src="http://dingdm.online/%E6%A0%B9%E6%8D%AE%E8%87%AA%E5%B7%B1%E9%80%89%E6%8B%A9%E5%AF%B9%E5%BA%94%E6%A8%A1%E5%9D%97.png" alt=""></p><p>选择对应的选项，在下方生成对应的js文件即可。</p><p><img src="http://dingdm.online/%E7%94%9F%E6%88%90js.png" alt=""></p><p>复制你的js文件放到你的主题下的相应的文件里即可，这里不对主题的文件进行介绍了，有一些vue基础就可以看懂了。</p><h3 id="阿里云部署博客">阿里云部署博客</h3><p>如果使用github来部署的话访问较慢，所以我这里推荐阿里云服务器部署，学生机10块钱一个月很便宜。如果是上班族的话，找个亲戚或朋友家的大学生不是计算机专业的认证一下就好。</p><h4 id="安装node-以ubuntu16-04为例">安装node(以ubuntu16.04为例)</h4><p>更新一下服务器的源</p><pre><code>apt-get updateapt-get install -y python-software-properties software-properties-commonadd-apt-repository ppa:chris-lea/node.jsapt-get update</code></pre><p>node安装</p><pre><code>apt-get install nodejsapt install nodejs-legacyapt install npm</code></pre><p>将npm的源设置为淘宝源，下载加速。</p><pre><code>npm config set registry https://registry.npm.taobao.orgnpm config list</code></pre><p>安装版本管理器</p><pre><code>npm install n -g</code></pre><h4 id="安装git">安装git</h4><pre><code>apt-get install git</code></pre><p>配置用户名和邮箱</p><pre><code>git config --global user.name "你的用户名"git config --global user.email "你的注册邮箱"</code></pre><h4 id="安装nginx">安装nginx</h4><pre><code>apt-get install nginx</code></pre><p>安装完nginx后，这里以ubuntu16.04为例，nginx的目录为/ect/nginx。我们修改配置文件只需要修改sites-available下的default即可。我这里在之前学习的时候都是不一样的路径，所以我这里以ubuntu为例。</p><pre><code>server {        listen 80 default_server;        listen [::]:80 default_server;        listen 443 ssl;        ssl off;        ssl_certificate cert/4287626_www.dingdm.club.pem;        ssl_certificate_key cert/4287626_www.dingdm.club.key;        ssl_session_timeout 5m;        #ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aN$        ssl_ciphers ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES128-SHA256:ECDHE-RSA-AES128-SHA256:ECDHE-ECDSA-AES128-SHA:ECDHE-RSA-AES256-SHA384:ECDHE-RSA-AES128-SHA:ECDHE-ECDSA-AES256-SHA384:ECDHE-ECDSA-AES256-SHA:ECDHE-RSA-AES256-SHA:DHE-RSA-AES128-SHA256:DHE-RSA-AES128-SHA:DHE-RSA-AES256-SHA256:DHE-RSA-AES256-SHA:ECDHE-ECDSA-DES-CBC3-SHA:ECDHE-RSA-DES-CBC3-SHA:EDH-RSA-DES-CBC3-SHA:AES128-GCM-SHA256:AES256-GCM-SHA384:AES128-SHA256:AES256-SHA256:AES128-SHA:AES256-SHA:DES-CBC3-SHA:!DSS;        ssl_protocols TLSv1 TLSv1.1 TLSv1.2;        ssl_prefer_server_ciphers on;        root /home/www/hexo;        server_name dingdm.club;}</code></pre><p>server_name为你的域名，root为你的静态网站所在的路径，可以自己创建，<strong>注意这里的路径不是你的hexo博客的路径，如果你在服务器上创建博客的话</strong>。</p><p>ssl的配置为开启https的配置，这里先不赘述，不需要的话可以将ssl相关的配置注释掉即可。</p><h4 id="初始化git仓库">初始化git仓库</h4><p>添加git用户，使用root账户也可以。</p><pre><code>adduser git</code></pre><p>修改文件内容赋予权限</p><pre><code>chmod 740 /etc/sudoersnano /etc/sudoers</code></pre><p>找到root用户那，在下方添加一条</p><pre><code>git ALL=(ALL) ALL</code></pre><p>将文件权限恢复</p><pre><code>chmod 400 /etc/sudoers</code></pre><p>切换到git用户，并创建ssh文件夹</p><pre><code>su gitcd ~mkdir .sshcd .ssh</code></pre><p>生成密钥公钥并配置</p><pre><code>ssh-keygencp id_rsa.pub authorized_keyschmod 600 ~/.ssh/authorized_keyschmod 700 ~/.ssh</code></pre><p>配置完成之后可以使用<code>ssh -v git@ip</code>连接测试</p><p>新建仓库并设置钩子脚本</p><pre><code>cd ~git init --bare blog.gitnano ~/blog.git/hooks/post-receive</code></pre><p>输入以下内容</p><pre><code>git --work-tree=/home/www/hexo --git-dir=/home/git/blog.git checkout -f</code></pre><p>/home/www/hexo为你刚刚在nginx的配置文件里的root路径，/home/git/blog.git为你的仓库地址</p><h4 id="hexo部署">hexo部署</h4><p>在你的hexo博客下的_config.yml配置文件中修改deploy模块</p><pre class=" language-language-yml"><code class="language-language-yml">deploy:  type: git  repo: git@公网IP:/home/git/blog.git    </code></pre><p>修改完成之后运行<code>hexo clean &amp;&amp; hexo deploy</code>部署你的hexo博客即可。</p><p>部署完成之后，使用/etc/init.d/nginx configtest检查一下nginx的配置是否有问题，如果没问题，运行<code>/etc/init.d/nginx restart</code>重启nginx服务即可。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
          <category> 美化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nginx </tag>
            
            <tag> git </tag>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一次steam个人资料动态设置</title>
      <link href="/2020/07/30/yi-ci-steam-ge-ren-zi-liao-dong-tai-she-zhi/"/>
      <url>/2020/07/30/yi-ci-steam-ge-ren-zi-liao-dong-tai-she-zhi/</url>
      
        <content type="html"><![CDATA[<h3 id="首先放上预览图">首先放上预览图</h3><p><a href="https://steamcommunity.com/profiles/76561198366411843" target="_blank" rel="noopener">https://steamcommunity.com/profiles/76561198366411843</a></p><h3 id="资料背景设置">资料背景设置</h3><p><strong>需要steam等级到达十级，拥有自己的艺术展柜。</strong><br><strong>首先需要在steam的社区-市场购买自己想要的个人资料背景，当然目前处于夏季促销，可以通过点数购买比较好看的背景。如果没有游戏的话，可以先买游戏，买完背景之后在退款就好了。</strong><br><strong>这里登陆不上市场需要挂加速器，UU加速器的免费steam加速就可以。</strong><br><strong>我这里选择的是Meteor Shower</strong><br><img src="https://steamcdn-a.akamaihd.net/steamcommunity/public/images/items/645690/06e52a6057125c91e4d88fd00e1f486bdee9a654.jpg" alt=""></p><h4 id="资料背景切割">资料背景切割</h4><p><a href="http://sapic.github.io/" target="_blank" rel="noopener">http://sapic.github.io/</a><br><strong>在当前页面上进行steam的登录，他会自动检索你的库存中的背景资料，自己选择即可。</strong><br><img src="http://dingdm.online/QQ%E6%88%AA%E5%9B%BE20200628231317.png" alt="下载" title="下载"><br><strong>自行下载对应的文件然后解压就可以看到对应的三个文件。</strong></p><h4 id="PS进行动态设置">PS进行动态设置</h4><p><strong>首先打开静态背景图片，然后调出时间轴，创建帧动画。</strong><br><img src="http://dingdm.online/QQ%E6%88%AA%E5%9B%BE20200628231525.png" alt="静态图片" title="静态图片"><br><strong>导入你自己的动态图片，然后选择所有帧之后，在选择拷贝所有帧。</strong><br><img src="http://dingdm.online/QQ%E6%88%AA%E5%9B%BE20200628231735.png" alt="选择所有帧" title="选择所有帧"><br><img src="http://dingdm.online/QQ%E6%88%AA%E5%9B%BE20200628231748.png" alt="拷贝所有帧" title="拷贝所有帧"><br><strong>选择静态背景，粘贴所有的帧，并置于图层之上</strong><br><img src="http://dingdm.online/QQ%E6%88%AA%E5%9B%BE20200628231911.png" alt="粘贴所有帧" title="粘贴所有帧"><br><img src="http://144.202.57.217:8080/uploadImages/63ac0df5b0ee466e83c0945faa381be8.png" alt="图层之上" title="图层之上"><br><strong>调整动画位置，设置动画循环，导出即可。</strong><br><img src="http://dingdm.online/QQ%E6%88%AA%E5%9B%BE20200628232116.png" alt="循环" title="循环"><br><img src="http://dingdm.online/QQ%E6%88%AA%E5%9B%BE20200628232133.png" alt="导出" title="导出"><br><strong>预览没有问题，导出即可。注意gif的大小不应超过8M</strong><br><img src="http://dingdm.online/QQ%E6%88%AA%E5%9B%BE20200628232148.png" alt="保存" title="保存"></p><h4 id="背景资料上传">背景资料上传</h4><p><a href="https://steamcommunity.com/login/home/?goto=%2Fsharedfiles%2Fedititem%2F767%2F3%2F" target="_blank" rel="noopener">https://steamcommunity.com/login/home/?goto=%2Fsharedfiles%2Fedititem%2F767%2F3%2F</a><br><strong>打开网页版的steam进行背景上传。</strong><br><strong>艺术作品的名字为空，防止上传完成之后出现名字。直接复制即可。</strong><br><code>⁡⁡⁡ ⁡⁠</code><br><strong>上传自己的除了头像外的其他两张图片，侧边和自己的gif。图片需要一张一张传</strong><br><strong>注意</strong><br><strong>上传完图片和添加完名字后，打开网页的console控制台。chrome右键检查即可。输入以下代码。</strong></p><pre class=" language-language-javascript"><code class="language-language-javascript">var num= document.getElementsByName("image_width")[0].value;document.getElementsByName("image_height")[0].value = num-(num-1);document.getElementsByName("image_width")[0].value= num*100;</code></pre><p><strong>这里代码的运行结果不为0即可，为0的话重复运行。</strong><br><img src="http://dingdm.online/QQ%E6%88%AA%E5%9B%BE20200628232812.png" alt="代码" title="代码"></p><h4 id="展柜设置">展柜设置</h4><p><strong>选择刚刚上传的图片保存即可。</strong><br><img src="http://dingdm.online/QQ%E6%88%AA%E5%9B%BE20200628232908.png" alt="艺术展柜" title="艺术展柜"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 游戏 </category>
          
          <category> 美化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> steam </tag>
            
            <tag> ps </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记一次服务器部署内容</title>
      <link href="/2020/07/28/ji-yi-ci-fu-wu-qi-bu-shu-nei-rong/"/>
      <url>/2020/07/28/ji-yi-ci-fu-wu-qi-bu-shu-nei-rong/</url>
      
        <content type="html"><![CDATA[<hr><p><strong>由于目前国内的域名需要备案，因此购买国外的域名，同时由于国外的域名解析到国内的服务器也需要备案，因此服务器也使用国外的，当然，需要一个备案的国内域名用于七牛CDN使用。</strong></p><h1>1.服务器域名选择</h1><p><strong>之前一直用的搬瓦工的服务器，但是现在搬瓦工的服务器配置高了，价格很贵，不是很划算，于是就用了vultr的服务器，五美元一个月，价格还可以，除了建站之外，当作梯子也是划算的。<br>vultr的平台需要先充值，最低额度十美元，支持支付宝付款还是可以的。</strong></p><h2 id="1-1-服务器购买">1.1 服务器购买</h2><p><img src="http://dingdm.online/%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%80%89%E6%8B%A9.png" alt=""><br><strong>服务器类型选择Cloud Compute就可以，用来个人需求绰绰有余。</strong><br><img src="http://dingdm.online/fuwuqixuanze" alt=""><br><strong>国家及城市根据自己需求选择就可以。<br>服务器操作系统我推荐Ubuntu16.04</strong><br><img src="http://dingdm.online/QQ%E6%88%AA%E5%9B%BE20200624211528.png" alt=""><br><strong>其他默认就好，购买完成就会看到自己的服务器</strong></p><h3 id="1-1-1">1.1.1</h3><p><strong>这里推荐两个软件，smarrty用于远程连接，Filezilla用于向服务器传输文件。<br>安装包我放在资源里面，可以在下载中自行下载。</strong></p><h2 id="1-2-域名购买">1.2 域名购买</h2><p><strong>域名购买我推荐nameSilo，不必要购买特别贵的，自己可以使用的就好<br>购买时挂梯子应该打开会快一点</strong><br><strong>官方网址<br><a href="https://www.namesilo.com/" target="_blank" rel="noopener">https://www.namesilo.com/</a><br>搜索自己想要的域名，然后进行购买</strong><br><img src="http://dingdm.online/QQ%E6%88%AA%E5%9B%BE20200624220852.png" alt=""><br><strong>选择第一个就可以了</strong><br><img src="http://dingdm.online/QQ%E6%88%AA%E5%9B%BE20200624220934.png" alt=""><br><strong>选择对应的配置和优惠码，优惠码百度一下，很多的，基本都是减一美元</strong><br><img src="http://dingdm.online/QQ%E6%88%AA%E5%9B%BE20200624221137.png" alt=""></p><h3 id="1-2-1-域名解析">1.2.1 域名解析</h3><p><strong>域名购买完成之后，点击manage my domains进入自己的域名管理页面</strong><br><img src="http://dingdm.online/QQ%E6%88%AA%E5%9B%BE20200624221243.png" alt=""><br><strong>下面显示的就是你刚刚购买的域名，然后点击蓝色的小球，dns设置</strong><br><img src="http://dingdm.online/QQ%E6%88%AA%E5%9B%BE20200624221256.png" alt=""><br><strong>进入到域名解析页面你会看到五条记录，将第三条和第四条删掉，然后编辑第一条和第二条。<br>第一条编辑的时候在ipv4栏输入你的服务器ip地址<br>第二条编辑的时候在1的基础上还要在hostname输入www</strong><br><img src="http://dingdm.online/QQ%E6%88%AA%E5%9B%BE20200624221324.png" alt=""></p><p><img src="http://dingdm.online/QQ%E6%88%AA%E5%9B%BE20200624221337.png" alt=""></p><h1>2.服务器配置及部署</h1><h2 id="2-1-服务器配置">2.1 服务器配置</h2><h3 id="2-1-1-java环境安装">2.1.1 java环境安装</h3><p><strong>由于我的项目是基于java开发的，所以安装Java环境。</strong><br><strong>首先卸载之前安装或参与的项，如果没有请忽略</strong><br><code>apt-get remove openjdk</code><br><strong>可以通过Oracle官网下载对应的jdk和在线安装两种方式进行安装</strong><br><strong>可以通过<code>apt install openjdk-8-jdk</code>的方式在线安装<br>也可以通过https://www.oracle.com/java/technologies/javase/javase-jdk8-downloads.html<br>官网下载对应的版本的jdk进行解压安装</strong></p><h4 id="2-1-1-1-配置环境变量">2.1.1.1 配置环境变量</h4><p><code>vim  ~/.bashrc</code><strong>也可以使用nano或vi 如果未安装vim</strong><br><strong>文件末尾添加以下内容</strong></p><pre class=" language-language-shell"><code class="language-language-shell">export JAVA_HOME=/usr/local/jdk1.8.0_211export JRE_HOME=${JAVA_HOME}/jreexport CLASSPATH=.:${JAVA_HOME}/lib:${JRE_HOME}/libexport PATH=.:${JAVA_HOME}/bin:$PATH</code></pre><p><strong>记得更换为自己文件所在的路径</strong><br><strong>保存变量并更新应用</strong><br><code>source ~/.bashrc</code><br><strong>使用</strong><code>java -version</code><strong>查看自己的java版本即可</strong></p><h3 id="2-1-2-docker安装">2.1.2 docker安装</h3><p><strong>由于项目使用到的redis，rabbitmq，mongodb都是基于docker容器的，因此先进行配置。</strong><br><strong>卸载存在的docker的旧版本</strong><br><code>apt-get remove docker docker-engine docker-ce docker.io</code><br><strong>更新apt包</strong><br><code>apt-get update</code><br><strong>安装以下包通过https使用存储库</strong><br><code>apt-get install -y apt-transport-https ca-certificates curl software-properties-common</code><br><strong>添加docker的GPG密钥</strong><br><code>curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -</code><br><strong>设置stable存储库</strong><br><code>add-apt-repository "deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable"</code><br><strong>更新apt包</strong><br><code>apt-get update</code><br><strong>安装docker</strong><br><code>apt-get install -y docker-ce</code><br><strong>验证服务是否启动</strong><br><code>systemctl status docker</code><br><strong>docker未启动，则手动启动docker</strong><br><code>systemctl start docker</code><br><strong>docker安装完成</strong></p><h4 id="2-1-2-1-docker安装mongodb">2.1.2.1 docker安装mongodb</h4><p><strong>下载镜像</strong><br><code>docker pull registry.docker-cn.com/library/mongo</code><br><strong>创建数据文件夹</strong><br><code>mkdir /data/mongodb0</code><br><strong>启动容器</strong><br><code>docker run --name mongodb-server0 -v /data/mongodb0:/data/db -p 27017:27017 -d 镜像ID --auth</code><br><strong>-v后面的参数表示把数据文件挂载到宿主机的路径<br>-p把mongo端口映射到宿主机的指定端口<br>–auth表示连接mongodb需要授权</strong></p><h4 id="2-1-2-2-docker安装redis">2.1.2.2 docker安装redis</h4><p><strong>拉取镜像</strong><br><code>docker pull redis</code><br><strong>启动镜像</strong><br><code>docker run -p 6379:6379 -d redis:latest redis-server</code><br><strong>-p 6379:6379 : 将容器的6379端口映射到主机的6379端口<br>-v $PWD/data:/data : 将主机中当前目录下的data挂载到容器的/data<br>redis-server --appendonly yes : 在容器执行redis-server启动命令，并打开redis持久化配置</strong><br><strong>docker的相关命令在其他笔记中已经说明过</strong><br><strong>redis的操作软件在附件中也已经上传，可以自行下载</strong></p><h4 id="2-1-2-3-docker安装rabbitMq">2.1.2.3 docker安装rabbitMq</h4><p><strong>拉取镜像</strong><br><code>docker pull rabbitmq:management</code><br><strong>运行镜像</strong><br><code>docker run -d -p 5672:5672 -p 15672:15672 --name rabbitmq rabbitmq:management</code><br><strong>访问管理页面<br>http://[宿主机IP]:15672</strong></p><h3 id="2-1-3-nginx安装">2.1.3 nginx安装</h3><p><strong>因为我使用了两个域名，一个为8080端口，一个为8060端口，因此需要使用nginx来进行端口的转发。</strong><br>安装nginx<br><code>apt-get install nginx</code><br><strong>安装好以后，nginx默认安装位置在etc目录下，这里我在使用的时候出现了nginx文件限制的问题，因此在这里统一进行说明。<br>在nginx下的nginx.conf配置文件中的http段对文件大小进行设置。</strong><br><code>client_max_body_size 100m;</code><br><strong>在sites-available下进行对应的端口转发配置</strong></p><pre class=" language-language-shell"><code class="language-language-shell">server {listen 80 default_server;listen [::]:80 default_server;root /var/www/html;index index.html index.htm index.nginx-debian.html;server_name dinggc.info;location / {      proxy_set_header   X-Real-IP        $remote_addr;      proxy_set_header   X-Forwarded-For  $proxy_add_x_forwarded_for;      proxy_set_header   Host             $http_host;      proxy_set_header   Upgrade          $http_upgrade;      proxy_set_header   X-NginX-Proxy    true;      proxy_set_header   Connection "upgrade";      proxy_http_version 1.1;      proxy_pass         http://localhost:8080;   }}</code></pre><pre class=" language-language-shell"><code class="language-language-shell">server {listen 80;   # 修改为你的域名   server_name dinggc.online;   location / {      proxy_set_header   X-Real-IP        $remote_addr;      proxy_set_header   X-Forwarded-For  $proxy_add_x_forwarded_for;      proxy_set_header   Host             $http_host;      proxy_set_header   Upgrade          $http_upgrade;      proxy_set_header   X-NginX-Proxy    true;      proxy_set_header   Connection "upgrade";      proxy_http_version 1.1;      proxy_pass         http://localhost:8060;   }}</code></pre><p><strong>使用</strong><code>/etc/init.d/nginx configtest</code><strong>进行配置测试如果成功则使用</strong><code>/etc/init.d/nginx reload</code><strong>重启nginx即可</strong><br><strong>至此，相关的服务器配置安装完成。</strong></p><h1>3 项目部署</h1><p><strong>使用filezilla软件将相关文件上传到服务器之后在线运行即可。<br>若使用nohup后台运行的话，注意不要直接关掉smartty，而应该使用exit命令退出命令行。</strong></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nginx </tag>
            
            <tag> ubuntu </tag>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springboot的启动流程</title>
      <link href="/2020/07/28/springboot-de-qi-dong-liu-cheng/"/>
      <url>/2020/07/28/springboot-de-qi-dong-liu-cheng/</url>
      
        <content type="html"><![CDATA[<h3 id="spring-boot的启动流程图">spring boot的启动流程图</h3><p><img src="http://dingdm.online/qidongliucheng.png" alt="启动流程图" title="启动流程图"><br><strong>springboot的流程启动主要为三个部分</strong></p><ul><li>SpringApplication的初始化，配置基础的环境变量，构造器，监听器等。</li><li>流程启动，主要为启动流程的监听，加载配置环境，创建上下文</li><li>自动化配置</li></ul><p><strong>springboot的主启动类入口</strong></p><pre class=" language-language-java"><code class="language-language-java">@SpringBootApplication(exclude = SecurityAutoConfiguration.class)@MapperScan(value = "cn.dingdm.website.mapper")@EnableCachingpublic class WebsiteApplication {    public static void main(String[] args) {        SpringApplication.run(WebsiteApplication.class, args);    }}</code></pre><p><strong>SpringBootApplication注解详解</strong></p><pre class=" language-language-java"><code class="language-language-java">@Target({ElementType.TYPE}) //注解的适用范围，其中TYPE用于描述类、接口（包括包注解类型）或enum声明@Retention(RetentionPolicy.RUNTIME) // 注解的生命周期，保留到class文件中（三个生命周期）@Documented // 表明这个注解应该被javadoc记录@Inherited // 子类可以继承该注解@SpringBootConfiguration // 继承了Configuration，表示当前是注解类@EnableAutoConfiguration // 开启springboot的注解功能，springboot的四大神器之一，其借助@import的帮助@ComponentScan( // 扫描路径设置    excludeFilters = {@Filter(    type = FilterType.CUSTOM,    classes = {TypeExcludeFilter.class}), @Filter(    type = FilterType.CUSTOM,    classes = {AutoConfigurationExcludeFilter.class})})public @interface SpringBootApplication {</code></pre><p><strong>ElementType枚举类</strong></p><pre class=" language-language-java"><code class="language-language-java">public enum ElementType {    TYPE,    FIELD,    METHOD,    PARAMETER,    CONSTRUCTOR,    LOCAL_VARIABLE,    ANNOTATION_TYPE,    PACKAGE,    TYPE_PARAMETER,    TYPE_USE}</code></pre><p><strong>生命周期枚举类</strong></p><pre class=" language-language-java"><code class="language-language-java">public enum RetentionPolicy {    SOURCE,    CLASS,    RUNTIME}</code></pre><p><strong>1、RetentionPolicy.SOURCE：注解只保留在源文件，当Java文件编译成class文件的时候，注解被遗弃；<br>2、RetentionPolicy.CLASS：注解被保留到class文件，但jvm加载class文件时候被遗弃，这是默认的生命周期；<br>3、RetentionPolicy.RUNTIME：注解不仅被保存到class文件中，jvm加载class文件之后，仍然存在；</strong><br><strong>首先要明确生命周期长度&nbsp;SOURCE &lt; CLASS &lt; RUNTIME ，所以前者能作用的地方后者一定也能作用。一般如果需要在运行时去动态获取注解信息，那只能用&nbsp;RUNTIME 注解；如果要在编译时进行一些预处理操作，比如生成一些辅助代码（如&nbsp;ButterKnife），就用&nbsp;CLASS注解；如果只是做一些检查性的操作，比如&nbsp;@Override 和&nbsp;@SuppressWarnings，则可选用&nbsp;SOURCE 注解。</strong></p><table><thead><tr><th>注解</th><th>父类</th><th>作用</th></tr></thead><tbody><tr><td>SpringBootConfiguration</td><td>Configuration</td><td>标注当前类是Java config配置类，会被扫描并加载到ioc容器</td></tr><tr><td>ComponentScan</td><td></td><td>扫描默认包或指定包下面符合条件的组件并加载</td></tr><tr><td>EnableAutoConfiguration</td><td></td><td>从classpath中搜寻所有的META-INF/spring.factories配置文件，并将其中org.springframework.boot.autoconfig.EnableAutoConfiguration对应的配置项通过反射实例化为对应的标注了@Configuration的java config形式的ioc容器配置类，汇总并加载到ioc容器</td></tr><tr><td></td><td>@AutoConfigurationPackages</td><td>注册当前主程序类的同级以及子级的包中的符合条件的Bean的定义</td></tr><tr><td></td><td>@Import(AutoConfigurationImportSelector.class)</td><td>扫描各个组件jar META-INIF目录下的spring.dactories文件，将下面的包名.类名中的工厂类全部加载到IOC容器中；将所有符合条件的bean的定义加载到ioc容器中</td></tr></tbody></table><h3 id="springboot启动">springboot启动</h3><p><strong>执行主函数main方法</strong><br><img src="http://dingdm.online/main.png" alt="main函数" title="main函数"><br><strong>创建SpringApplication对象对象，并运行SpringApplication对象的run方法</strong><br><img src="http://dingdm.online/chuangjianduixiang.png" alt="创建对象" title="创建对象"><br><strong>加载接口</strong><br><img src="http://dingdm.online/jiazaijiekou.png" alt="加载接口" title="加载接口"></p><pre class=" language-language-java"><code class="language-language-java">        this.primarySources = new LinkedHashSet(Arrays.asList(primarySources));        this.webApplicationType = this.deduceWebApplicationType();       // 扫描当前路径下META-INF/spring.factories文件的，加载ApplicationContextInitializer接口实例    this.setInitializers(this.getSpringFactoriesInstances(ApplicationContextInitializer.class));// 扫描当前路径下META-INF/spring.factories文件的，加载ApplicationListener接口实例        this.setListeners(this.getSpringFactoriesInstances(ApplicationListener.class));        this.mainApplicationClass = this.deduceMainApplicationClass();</code></pre><p><strong>ApplicationContextInitializer 这个类当springboot上下文Context初始化完成后会调用<br>ApplicationListener 当springboot启动时事件change后都会触发</strong><br><strong>这两个接口均可自己进行定义</strong><br><strong>实现接口后自己配置自己的实现类</strong></p><pre class=" language-language-java"><code class="language-language-java">org.springframework.context.ApplicationContextInitializer=\org.admin.starter.test.listener.StarterApplicationContextInitializerorg.springframework.context.ApplicationListener=\org.admin.starter.test.listener.StarterApplicationListener</code></pre><p><strong>实现run方法</strong><br><img src="http://dingdm.online/run.png" alt="run方法" title="run方法"></p><pre class=" language-language-java"><code class="language-language-java">public ConfigurableApplicationContext run(String... args) {        // 计时器StopWatch stopWatch = new StopWatch();stopWatch.start();ConfigurableApplicationContext context = null;Collection<springbootexceptionreporter> exceptionReporters = new ArrayList&lt;&gt;();        // 设置环境变量        configureHeadlessProperty();        // 获取事件监听器SpringApplicationRunListener类型，并且执行starting()方法SpringApplicationRunListeners listeners = getRunListeners(args);listeners.starting();try {            // 参数args封装成DefaultApplicationArgumentsApplicationArguments applicationArguments = new DefaultApplicationArguments(args);            // 把环境跟spring上下文绑定好，并且执行environmentPrepared()方法ConfigurableEnvironment environment = prepareEnvironment(listeners,applicationArguments);            // 判断一些环境的值，设置一些环境的值configureIgnoreBeanInfo(environment);            // 打印bannerBanner printedBanner = printBanner(environment);            // 根据项目类型创建上下文context = createApplicationContext();            // 获取异常报告事件监听exceptionReporters = getSpringFactoriesInstances(SpringBootExceptionReporter.class,new Class[] { ConfigurableApplicationContext.class }, context);            // 准备上下文，执行完成后调用contextPrepared()方法,contextLoaded()方法prepareContext(context, environment, listeners, applicationArguments,printedBanner);            // spring启动的代码，这里就回去里面就回去扫描并且初始化单实列bean了            // 这个refreshContext()加载了bean，启动了内置web容器refreshContext(context);afterRefresh(context, applicationArguments);stopWatch.stop();if (this.logStartupInfo) {new StartupInfoLogger(this.mainApplicationClass).logStarted(getApplicationLog(), stopWatch);}           // 执行ApplicationRunListeners中的started()方法listeners.started(context);            <!--执行Runner（ApplicationRunner和CommandLineRunner）-->callRunners(context, applicationArguments);}catch (Throwable ex) {handleRunFailure(context, listeners, exceptionReporters, ex);throw new IllegalStateException(ex);}listeners.running(context);return context;}</springbootexceptionreporter></code></pre><p><strong>根据项目类型创建上下文，并且注入几个核心组件类。</strong><br><img src="http://dingdm.online/chuangjianshangxiawen.png" alt="创建上下文" title="创建上下文"><br><strong>refreshContext(context)方法启动spring的代码加载了bean，还启动了内置web容器</strong><br><img src="http://dingdm.online/jiazaibean.png" alt="加载bean" title="加载bean"></p><pre class=" language-language-java"><code class="language-language-java">public void refresh() throws BeansException, IllegalStateException {        synchronized(this.startupShutdownMonitor) {            this.prepareRefresh();            ConfigurableListableBeanFactory beanFactory = this.obtainFreshBeanFactory();            this.prepareBeanFactory(beanFactory);            try {                this.postProcessBeanFactory(beanFactory);                this.invokeBeanFactoryPostProcessors(beanFactory);                this.registerBeanPostProcessors(beanFactory);                this.initMessageSource();                this.initApplicationEventMulticaster();                this.onRefresh();                this.registerListeners();                this.finishBeanFactoryInitialization(beanFactory);                this.finishRefresh();            } catch (BeansException var9) {                if (this.logger.isWarnEnabled()) {                    this.logger.warn("Exception encountered during context initialization - cancelling refresh attempt: " + var9);                }                this.destroyBeans();                this.cancelRefresh(var9);                throw var9;            } finally {                this.resetCommonCaches();            }        }    }</code></pre><p><strong>onRefresh钩子方法</strong><br><img src="http://dingdm.online/gouzi.png" alt=""><br>钩子方法，它会钩到它子类重写onRefresh()方法。所以去看子类里面的onRefresh()<br><img src="http://dingdm.online/zileishixian.png" alt="子类实现" title="子类实现"><br><strong>内置容器</strong><br><img src="http://dingdm.online/neizhirongqi.png" alt="内置容器" title="内置容器"><br><img src="http://dingdm.online/neizhirongqi2.png" alt="内置容器" title="内置容器"><br><strong>容器选择</strong><br><img src="http://dingdm.online/rongqixuanze.png" alt="容器选择" title="容器选择"><br><strong>tomcat容器</strong><img src="http://dingdm.online/tomcat.png" alt="tomcat" title="tomcat"></p><h3 id="springboot的自动化配置">springboot的自动化配置</h3><p><img src="http://dingdm.online/zidonghua.png" alt="自动化配置" title="自动化配置"><br><strong>该配置模块的主要使用到了SpringFactoriesLoader，即Spring工厂加载器，该对象提供了loadFactoryNames方法，入参为factoryClass和classLoader，即需要传入上图中的工厂类名称和对应的类加载器，方法会根据指定的classLoader，加载该类加器搜索路径下的指定文件，即spring.factories文件，传入的工厂类为接口，而文件中对应的类则是接口的实现类，或最终作为实现类，所以文件中一般为如下图这种一对多的类名集合，获取到这些实现类的类名后，loadFactoryNames方法返回类名集合，方法调用方得到这些集合后，再通过反射获取这些类的类对象、构造方法，最终生成实例。</strong><br><img src="http://dingdm.online/jiekoupeizhi.png" alt="接口配置" title="接口配置"><br><strong>EnableAutoConfiguration最终实现了ImportSelector(选择器)和BeanClassLoaderAware(bean类加载器中间件)，重点关注一下AutoConfigurationImportSelector的selectImports方法</strong><br><img src="http://dingdm.online/leixinxiliebiao.png" alt="类信息列表" title="类信息列表"><br><strong>该方法在springboot启动流程——bean实例化前被执行，返回要实例化的类信息列表。我们知道，如果获取到类信息，spring自然可以通过类加载器将类加载到jvm中，现在我们已经通过spring-boot的starter依赖方式依赖了我们需要的组件，那么这些组建的类信息在select方法中也是可以被获取到的</strong><br><strong>方法中的getCandidateConfigurations方法，通过方法注释了解到，其返回一个自动配置类的类名列表，方法调用了loadFactoryNames方法</strong></p><pre class=" language-language-java"><code class="language-language-java">    protected List<string> getCandidateConfigurations(AnnotationMetadata metadata, AnnotationAttributes attributes) {        List<string> configurations = SpringFactoriesLoader.loadFactoryNames(this.getSpringFactoriesLoaderFactoryClass(), this.getBeanClassLoader());        Assert.notEmpty(configurations, "No auto configuration classes found in META-INF/spring.factories. If you are using a custom packaging, make sure that file is correct.");        return configurations;    }</string></string></code></pre><p><strong>自动配置器会根据传入的factoryClass.getName()到项目系统路径下所有的spring.factories文件中找到相应的key，从而加载里面的类</strong><br><img src="http://dingdm.online/jiazailei.png" alt="加载类" title="加载类"></p><pre class=" language-language-java"><code class="language-language-java">private static Map<string, list<string="">&gt; loadSpringFactories(@Nullable ClassLoader classLoader) {        MultiValueMap<string, string=""> result = (MultiValueMap)cache.get(classLoader);        if (result != null) {            return result;        } else {            try {                Enumeration<url> urls = classLoader != null ? classLoader.getResources("META-INF/spring.factories") : ClassLoader.getSystemResources("META-INF/spring.factories");                LinkedMultiValueMap result = new LinkedMultiValueMap();                while(urls.hasMoreElements()) {                    URL url = (URL)urls.nextElement();                    UrlResource resource = new UrlResource(url);                    Properties properties = PropertiesLoaderUtils.loadProperties(resource);                    Iterator var6 = properties.entrySet().iterator();                    while(var6.hasNext()) {                        Entry<!--?, ?--> entry = (Entry)var6.next();                        List<string> factoryClassNames = Arrays.asList(StringUtils.commaDelimitedListToStringArray((String)entry.getValue()));                        result.addAll((String)entry.getKey(), factoryClassNames);                    }                }                cache.put(classLoader, result);                return result;            } catch (IOException var9) {                throw new IllegalArgumentException("Unable to load factories from location [META-INF/spring.factories]", var9);            }        }    }</string></url></string,></string,></code></pre><p><strong>自动配置</strong><br><img src="http://dingdm.online/zidongpeizhi2.png" alt="自动配置" title="自动配置"></p><pre class=" language-language-java"><code class="language-language-java">@Configuration@ConditionalOnClass({EnableAspectJAutoProxy.class, Aspect.class, Advice.class, AnnotatedElement.class})@ConditionalOnProperty(    prefix = "spring.aop",    name = {"auto"},    havingValue = "true",    matchIfMissing = true)public class AopAutoConfiguration {    public AopAutoConfiguration() {    }    @Configuration    @EnableAspectJAutoProxy(        proxyTargetClass = true    )    @ConditionalOnProperty(        prefix = "spring.aop",        name = {"proxy-target-class"},        havingValue = "true",        matchIfMissing = true    )    public static class CglibAutoProxyConfiguration {        public CglibAutoProxyConfiguration() {        }    }    @Configuration    @EnableAspectJAutoProxy(        proxyTargetClass = false    )    @ConditionalOnProperty(        prefix = "spring.aop",        name = {"proxy-target-class"},        havingValue = "false",        matchIfMissing = false    )    public static class JdkDynamicAutoProxyConfiguration {        public JdkDynamicAutoProxyConfiguration() {        }    }}</code></pre><p><strong>@Configuration，是一个通过注解标注的springBean</strong><br><strong>@ConditionalOnClass({EnableAspectJAutoProxy.class, Aspect.class, Advice.class, AnnotatedElement.class})这个注解的意思是：EnableAspectJAutoProxy.class, Aspect.class，Advice.class，AnnotatedElement.class这几个类时才解析AopAutoConfiguration配置类，否则不解析这一个配置类</strong><br><strong>因为maven依赖的传递性，我们只要依赖starter就可以依赖到所有需要自动配置的类，实现开箱即用的功能。也体现出Springboot简化了Spring框架带来的大量XML配置以及复杂的依赖管理，让开发人员可以更加关注业务逻辑的开发。</strong></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot </tag>
            
            <tag> tomcat </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络</title>
      <link href="/2020/05/08/ji-suan-ji-wang-luo/"/>
      <url>/2020/05/08/ji-suan-ji-wang-luo/</url>
      
        <content type="html"><![CDATA[<h3 id="应用进程跨越网络的通信">应用进程跨越网络的通信</h3><p><strong>解决的问题</strong>：一些特定的应用需要互联网但是不能使用标准化的互联网应用协议<br>系统调用：<br>流程：应用进程启动系统调用，控制进程传递给了系统调用接口，接口将控制权交给操作系统。即应用进程的控制权和操作系统的权限转换的接口。<br>应用进程只要使用标准的系统调用函数就可得到操作系统的服务。所以系统调用接口又称为应用编程接口。<br>其中TCP/IP协议软件驻留在操作系统中。<br>在编写java代码时有一些公用的API：<br>通过传入简单的字符串，java通过API来进行切割字符串</p><pre class=" language-language-java"><code class="language-language-java">/**  * String 类得split方法解析。  * 实际是调用Pattern类得split方法  */  public class AboutSplit {      public String[] split(String regex, int limit) {          return Pattern.compile(regex).split("本String字符串", limit);      }      /**      * 关于limit：limit决定数组的长度      * 当limit为0时数组长度不受限制,并且将剔除尾部空串      * 当limit为负时数组长度不受限制      * 当limit长度大于0，数组长度将&lt;=limit，而且数组的最后一个元素将包含匹配符后面的所有字符      */      public String[] split(CharSequence input, int limit) {          int index = 0;          boolean matchLimited = limit &gt; 0;          ArrayList<string> matchList = new ArrayList<string>();          Matcher m = Pattern.matcher(input); //此pattern为Pattern.compile(regex)返回的Pattern对象            // Add segments before each match found          while(m.find()) {              if (!matchLimited || matchList.size() &lt; limit - 1) { //默认limit为0                  String match = input.subSequence(index, m.start()).toString();  //比如a:b:c，返回a。m.start()返回第一个匹配字符的索引即1                  matchList.add(match);   //存入List                  index = m.end();    //返回最后一个匹配字符的后一个字符的索引，这里是2              } else if (matchList.size() == limit - 1) { // 最后一个元素                  String match = input.subSequence(index,                                                   input.length()).toString();                  matchList.add(match);                  index = m.end();              }          }            // 没有找到匹配串          if (index == 0)              return new String[] {input.toString()};            // 把最后一部分的片段添加进来          if (!matchLimited || matchList.size() &lt; limit)              matchList.add(input.subSequence(index, input.length()).toString());            // Construct result          int resultSize = matchList.size();          if (limit == 0) //如果limit为0              while (resultSize &gt; 0 &amp;&amp; matchList.get(resultSize-1).equals(""))                  resultSize--;   //剔除尾部空串          String[] result = new String[resultSize];          return matchList.subList(0, resultSize).toArray(result);      }  }  </string></string></code></pre><p>目前的应用编程接口API：套接字接口(插口接口)<br>这里需要注意一点，websocket在连接的时候有一个握手阶段，但是这和TCP的三次握手又是不一样的。TCP的三次握手是为了保证连接可靠，当TCP三次握手成功的时候，websocket的握手阶段才真正开始。TCP三次握手传送的是TCP报文，而websocket的握手传送的是HTTP报文，这个是不太一样的地方。</p><p>握手开始的时候，我们需要现发送一个HTTP 1.1的请求头部：</p><pre class=" language-language-shell"><code class="language-language-shell">GET /chat HTTP/1.1Host: server.example.comUpgrade: websocketConnection: UpgradeSec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==Origin: http://example.comSec-WebSocket-Protocol: chat, superchatSec-WebSocket-Version: 13</code></pre><p>服务端返回的成功握手请求头部如下：</p><pre class=" language-language-java"><code class="language-language-java">HTTP/1.1 101 Switching ProtocolsUpgrade: websocketConnection: UpgradeSec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=Sec-WebSocket-Protocol: chat</code></pre><p>Upgrade:WebSocket表示这是一个特殊的 HTTP 请求，请求的目的就是要将客户端和服务器端的通讯协议从 HTTP 协议升级到 WebSocket 协议。</p><h3 id="常用的系统调用">常用的系统调用</h3><p>TCP服务：<br><img src="http://dingdm.online/f0afb365fe254a1485a3460b13776aef.png" alt=""></p><h3 id="鉴别">鉴别</h3><p><strong>概念</strong>：验证通信的对方的确是自己要通信的对象，所传送的报文是完整的。</p><h4 id="报文鉴别">报文鉴别</h4><p>密码散列函数(Hash函数)<br>特点：输入长度可以很长，但其输出长度是固定的，并且较短。<br>不同的散列值肯定对应不同的输入，不同的输入却可能得到相同的散列值。<br>一个优良的Hash函数必须满足如下几个性质:</p><ul><li>任意y，找x，使得H(x) = y，非常困难</li><li>给定x1, 找x2, 使得H(x1) == H(x2), 非常困难</li><li>找任意的x1, x2, 使得H(x1) == H(x2), 非常困难 生日定理</li></ul><p><strong>常用的Hash算法</strong><br>MD5<br>SHA1<br>SHA224<br>SHA256<br>SHA384<br>SHA512<br>SM3</p><pre class=" language-language-java"><code class="language-language-java">#!/usr/bin/python#coding:utf8import hashlibdef b2s(bytes):    rets = []    for c in bytes:        rets.append("%02X" % (ord(c)))    r = ' '.join(rets)    return rdef md5(data):    hashobj = hashlib.md5()    hashobj.update(data)    return hashobj.digest()def sha1(data):    hashobj = hashlib.sha1()    hashobj.update(data)    return hashobj.digest()def sha224(data):    hashobj = hashlib.sha224()    hashobj.update(data)    return hashobj.digest()def sha256(data):    hashobj = hashlib.sha256()    hashobj.update(data)    return hashobj.digest()def sha384(data):    hashobj = hashlib.sha384()    hashobj.update(data)    return hashobj.digest()def sha512(data):    hashobj = hashlib.sha512()    hashobj.update(data)    return hashobj.digest()def main():    hash_fun_list = (md5, sha1, sha224, sha256, sha384, sha512)    data = '\x12\x34'    for fun in hash_fun_list:        print fun        r = fun(data)        print b2s(r)if __name__ == '__main__':    main()</code></pre><h4 id="MD5">MD5</h4><p>算法过程：<br>先将报文按模2^64计算余数，追加在报文后面<br>报文和余数之填充1~512位，填充的首位时1，后面都是0<br>报文分割为一个个512位的数据块，每个512位的报文数据再分成4个128位的数据块依次送到不同的散列函数进行4轮计算，每一轮又按32位的小数据块进行运算</p><pre class=" language-language-java"><code class="language-language-java">public class MD5 {    static final String hexs[]={"0","1","2","3","4","5","6","7","8","9","A","B","C","D","E","F"};    //标准的幻数    private static final long A=0x67452301L;    private static final long B=0xefcdab89L;    private static final long C=0x98badcfeL;    private static final long D=0x10325476L;    //下面这些S11-S44实际上是一个4*4的矩阵，在四轮循环运算中用到    static final int S11 = 7;    static final int S12 = 12;    static final int S13 = 17;    static final int S14 = 22;    static final int S21 = 5;    static final int S22 = 9;    static final int S23 = 14;    static final int S24 = 20;    static final int S31 = 4;    static final int S32 = 11;    static final int S33 = 16;    static final int S34 = 23;    static final int S41 = 6;    static final int S42 = 10;    static final int S43 = 15;    static final int S44 = 21;    //java不支持无符号的基本数据（unsigned）    private long [] result={A,B,C,D};//存储hash结果，共4×32=128位，初始化值为（幻数的级联）    public static void main(String []args){        MD5 md=new MD5();        System.out.println("md5(abc)="+md.digest("abc"));    }    private String digest(String inputStr){        byte [] inputBytes=inputStr.getBytes();        int byteLen=inputBytes.length;//长度（字节）        int groupCount=0;//完整分组的个数        groupCount=byteLen/64;//每组512位（64字节）        long []groups=null;//每个小组(64字节)再细分后的16个小组(4字节)        //处理每一个完整 分组        for(int step=0;step<groupcount;step++){ groups="divGroup(inputBytes,step*64);" trans(groups);="" 处理分组，核心算法="" }="" 处理完整分组后的尾巴="" int="" rest="byteLen%64;//512位分组后的余数" byte="" []="" tempbytes="new" byte[64];="" if(rest<="56){" for(int="" i="0;i<rest;i++)" tempbytes[i]="inputBytes[byteLen-rest+i];" if(rest<56){="" tempbytes[rest]="(byte)(1<<7);" tempbytes[rest+i]="0;" long="" len="(long)(byteLen<<3);" tempbytes[56+i]="(byte)(len&amp;0xFFL);">&gt;8;            }            groups=divGroup(tempBytes,0);            trans(groups);//处理分组        }else{            for(int i=0;i<rest;i++) tempbytes[i]="inputBytes[byteLen-rest+i];" tempbytes[rest]="(byte)(1<<7);" for(int="" i="rest+1;i<64;i++)" groups="divGroup(tempBytes,0);" trans(groups);="" 处理分组="" long="" len="(long)(byteLen<<3);" tempbytes[56+i]="(byte)(len&amp;0xFFL);">&gt;8;            }            groups=divGroup(tempBytes,0);            trans(groups);//处理分组        }        //将Hash值转换成十六进制的字符串        String resStr="";        long temp=0;        for(int i=0;i&lt;4;i++){            for(int j=0;j&lt;4;j++){                temp=result[i]&amp;0x0FL;                String a=hexs[(int)(temp)];                result[i]=result[i]&gt;&gt;4;                temp=result[i]&amp;0x0FL;                resStr+=hexs[(int)(temp)]+a;                result[i]=result[i]&gt;&gt;4;            }        }        return resStr;    }    /**     * 从inputBytes的index开始取512位，作为新的分组     * 将每一个512位的分组再细分成16个小组，每个小组64位（8个字节）     * @param inputBytes     * @param index     * @return     */    private static long[] divGroup(byte[] inputBytes,int index){        long [] temp=new long[16];        for(int i=0;i&lt;16;i++){            temp[i]=b2iu(inputBytes[4*i+index])|                (b2iu(inputBytes[4*i+1+index]))&lt;&lt;8|                (b2iu(inputBytes[4*i+2+index]))&lt;&lt;16|                (b2iu(inputBytes[4*i+3+index]))&lt;&lt;24;        }        return temp;    }    /**     * 这时不存在符号位（符号位存储不再是代表正负），所以需要处理一下     * @param b     * @return     */    public static long b2iu(byte b){        return b &lt; 0 ? b &amp; 0x7F + 128 : b;     }    /**     * 主要的操作，四轮循环     * @param groups[]--每一个分组512位（64字节）     */    private void trans(long[] groups) {        long a = result[0], b = result[1], c = result[2], d = result[3];        /*第一轮*/        a = FF(a, b, c, d, groups[0], S11, 0xd76aa478L); /* 1 */        d = FF(d, a, b, c, groups[1], S12, 0xe8c7b756L); /* 2 */        c = FF(c, d, a, b, groups[2], S13, 0x242070dbL); /* 3 */        b = FF(b, c, d, a, groups[3], S14, 0xc1bdceeeL); /* 4 */        a = FF(a, b, c, d, groups[4], S11, 0xf57c0fafL); /* 5 */        d = FF(d, a, b, c, groups[5], S12, 0x4787c62aL); /* 6 */        c = FF(c, d, a, b, groups[6], S13, 0xa8304613L); /* 7 */        b = FF(b, c, d, a, groups[7], S14, 0xfd469501L); /* 8 */        a = FF(a, b, c, d, groups[8], S11, 0x698098d8L); /* 9 */        d = FF(d, a, b, c, groups[9], S12, 0x8b44f7afL); /* 10 */        c = FF(c, d, a, b, groups[10], S13, 0xffff5bb1L); /* 11 */        b = FF(b, c, d, a, groups[11], S14, 0x895cd7beL); /* 12 */        a = FF(a, b, c, d, groups[12], S11, 0x6b901122L); /* 13 */        d = FF(d, a, b, c, groups[13], S12, 0xfd987193L); /* 14 */        c = FF(c, d, a, b, groups[14], S13, 0xa679438eL); /* 15 */        b = FF(b, c, d, a, groups[15], S14, 0x49b40821L); /* 16 */        /*第二轮*/        a = GG(a, b, c, d, groups[1], S21, 0xf61e2562L); /* 17 */        d = GG(d, a, b, c, groups[6], S22, 0xc040b340L); /* 18 */        c = GG(c, d, a, b, groups[11], S23, 0x265e5a51L); /* 19 */        b = GG(b, c, d, a, groups[0], S24, 0xe9b6c7aaL); /* 20 */        a = GG(a, b, c, d, groups[5], S21, 0xd62f105dL); /* 21 */        d = GG(d, a, b, c, groups[10], S22, 0x2441453L); /* 22 */        c = GG(c, d, a, b, groups[15], S23, 0xd8a1e681L); /* 23 */        b = GG(b, c, d, a, groups[4], S24, 0xe7d3fbc8L); /* 24 */        a = GG(a, b, c, d, groups[9], S21, 0x21e1cde6L); /* 25 */        d = GG(d, a, b, c, groups[14], S22, 0xc33707d6L); /* 26 */        c = GG(c, d, a, b, groups[3], S23, 0xf4d50d87L); /* 27 */        b = GG(b, c, d, a, groups[8], S24, 0x455a14edL); /* 28 */        a = GG(a, b, c, d, groups[13], S21, 0xa9e3e905L); /* 29 */        d = GG(d, a, b, c, groups[2], S22, 0xfcefa3f8L); /* 30 */        c = GG(c, d, a, b, groups[7], S23, 0x676f02d9L); /* 31 */        b = GG(b, c, d, a, groups[12], S24, 0x8d2a4c8aL); /* 32 */        /*第三轮*/        a = HH(a, b, c, d, groups[5], S31, 0xfffa3942L); /* 33 */        d = HH(d, a, b, c, groups[8], S32, 0x8771f681L); /* 34 */        c = HH(c, d, a, b, groups[11], S33, 0x6d9d6122L); /* 35 */        b = HH(b, c, d, a, groups[14], S34, 0xfde5380cL); /* 36 */        a = HH(a, b, c, d, groups[1], S31, 0xa4beea44L); /* 37 */        d = HH(d, a, b, c, groups[4], S32, 0x4bdecfa9L); /* 38 */        c = HH(c, d, a, b, groups[7], S33, 0xf6bb4b60L); /* 39 */        b = HH(b, c, d, a, groups[10], S34, 0xbebfbc70L); /* 40 */        a = HH(a, b, c, d, groups[13], S31, 0x289b7ec6L); /* 41 */        d = HH(d, a, b, c, groups[0], S32, 0xeaa127faL); /* 42 */        c = HH(c, d, a, b, groups[3], S33, 0xd4ef3085L); /* 43 */        b = HH(b, c, d, a, groups[6], S34, 0x4881d05L); /* 44 */        a = HH(a, b, c, d, groups[9], S31, 0xd9d4d039L); /* 45 */        d = HH(d, a, b, c, groups[12], S32, 0xe6db99e5L); /* 46 */        c = HH(c, d, a, b, groups[15], S33, 0x1fa27cf8L); /* 47 */        b = HH(b, c, d, a, groups[2], S34, 0xc4ac5665L); /* 48 */        /*第四轮*/        a = II(a, b, c, d, groups[0], S41, 0xf4292244L); /* 49 */        d = II(d, a, b, c, groups[7], S42, 0x432aff97L); /* 50 */        c = II(c, d, a, b, groups[14], S43, 0xab9423a7L); /* 51 */        b = II(b, c, d, a, groups[5], S44, 0xfc93a039L); /* 52 */        a = II(a, b, c, d, groups[12], S41, 0x655b59c3L); /* 53 */        d = II(d, a, b, c, groups[3], S42, 0x8f0ccc92L); /* 54 */        c = II(c, d, a, b, groups[10], S43, 0xffeff47dL); /* 55 */        b = II(b, c, d, a, groups[1], S44, 0x85845dd1L); /* 56 */        a = II(a, b, c, d, groups[8], S41, 0x6fa87e4fL); /* 57 */        d = II(d, a, b, c, groups[15], S42, 0xfe2ce6e0L); /* 58 */        c = II(c, d, a, b, groups[6], S43, 0xa3014314L); /* 59 */        b = II(b, c, d, a, groups[13], S44, 0x4e0811a1L); /* 60 */        a = II(a, b, c, d, groups[4], S41, 0xf7537e82L); /* 61 */        d = II(d, a, b, c, groups[11], S42, 0xbd3af235L); /* 62 */        c = II(c, d, a, b, groups[2], S43, 0x2ad7d2bbL); /* 63 */        b = II(b, c, d, a, groups[9], S44, 0xeb86d391L); /* 64 */        /*加入到之前计算的结果当中*/        result[0] += a;        result[1] += b;        result[2] += c;        result[3] += d;        result[0]=result[0]&amp;0xFFFFFFFFL;        result[1]=result[1]&amp;0xFFFFFFFFL;        result[2]=result[2]&amp;0xFFFFFFFFL;        result[3]=result[3]&amp;0xFFFFFFFFL;    }    /**     * 下面是处理要用到的线性函数     */    private static long F(long x, long y, long z) {        return (x &amp; y) | ((~x) &amp; z);    }    private static long G(long x, long y, long z) {        return (x &amp; z) | (y &amp; (~z));    }    private static long H(long x, long y, long z) {        return x ^ y ^ z;    }    private static long I(long x, long y, long z) {        return y ^ (x | (~z));    }    private static long FF(long a, long b, long c, long d, long x, long s,            long ac) {        a += (F(b, c, d)&amp;0xFFFFFFFFL) + x + ac;        a = ((a&amp;0xFFFFFFFFL)&lt;&lt; s) | ((a&amp;0xFFFFFFFFL) &gt;&gt;&gt; (32 - s));        a += b;        return (a&amp;0xFFFFFFFFL);    }    private static long GG(long a, long b, long c, long d, long x, long s,            long ac) {        a += (G(b, c, d)&amp;0xFFFFFFFFL) + x + ac;        a = ((a&amp;0xFFFFFFFFL) &lt;&lt; s) | ((a&amp;0xFFFFFFFFL) &gt;&gt;&gt; (32 - s));        a += b;        return (a&amp;0xFFFFFFFFL);    }    private static long HH(long a, long b, long c, long d, long x, long s,            long ac) {        a += (H(b, c, d)&amp;0xFFFFFFFFL) + x + ac;        a = ((a&amp;0xFFFFFFFFL) &lt;&lt; s) | ((a&amp;0xFFFFFFFFL) &gt;&gt;&gt; (32 - s));        a += b;        return (a&amp;0xFFFFFFFFL);    }    private static long II(long a, long b, long c, long d, long x, long s,            long ac) {        a += (I(b, c, d)&amp;0xFFFFFFFFL) + x + ac;        a = ((a&amp;0xFFFFFFFFL) &lt;&lt; s) | ((a&amp;0xFFFFFFFFL) &gt;&gt;&gt; (32 - s));        a += b;        return (a&amp;0xFFFFFFFFL);    }}</rest;i++)></groupcount;step++){></code></pre><h4 id="报文鉴别使用散列函数">报文鉴别使用散列函数</h4><hr><ul><li>用户A首先根据自己的明文X计算出散列H(X)，</li><li>用户A把散列H拼接在明文X的后面，生成了扩展的报文(X,H)，然后发送给B</li><li>用户B收到了这个扩展的报文(X,H)，因为散列的长度H是已知道的固定值，因此可以把收到的散列H和明文X分离开。B通过散列函数的计算，计算出明文X的散列H(X)。</li></ul><p>散列加密防止伪造报文<br><img src="http://dingdm.online/5181df2368ec4c359bc18a6737b3212f.png" alt=""></p><h3 id="密钥分配">密钥分配</h3><p>密钥管理：密码的产生、分配、注入、验证和使用</p><h4 id="对称密钥的分配">对称密钥的分配</h4><p>目前密钥分发的方式：<br>　　1、A选择一个密钥后以物理的方式传递给B<br>　　2、第三方选择密钥后物理地传给A和B<br>　　3、如果A和B先前或最近使用过一个密钥，则一方可以将 新密钥用旧密钥发送给另一方<br>　　4、如果A和B到第三方C有加密连接，则C可以在加密连接上发送密钥给A、B<br>分析：<br>1和2都需要人工交付，对链路加密（设备一对一连接）可行，对网络通信则不可行，因为网络通信涉及大量密钥<br>对于3，一旦攻击者获得一个密钥，则后序所有密钥便都不再安全。<br>4需要第三方即密钥分发中心，在网络通信中得到了广泛的应用<br>举例：</p><ol><li>你带好身份证和相应的材料去派出所，向JCSS说明你要办居住证，需要开据相应的证明。</li><li>JCSS根据他们的内部系统，核实了你提供的材料并开据了证明，上面盖有派出所的红章。</li><li>你再拿着这个证明再去社区事务中心，社区事务中心的工作人员看到了JCSS提供的证明，就可以确定你的身份，便开始给你办理业务。<br>图解：<br><img src="http://dingdm.online/QQ%E6%88%AA%E5%9B%BE20200805112435.png" alt=""></li></ol><ul><li>A携带A、B的身份以及唯一标识通过明文的方式向KDC发送请求</li><li>KDC通过通话密钥和收到的请求判断消息到达之前是否被篡改，然后把响应的信息用A的密钥加密返回给Ａ</li><li>KDC通过通话密钥和Ａ的身份，将Ｂ的信息用B的密钥加密然后送给Ａ</li><li>A、B进行通话验证，Ｂ使用会话密钥和唯一标识发送给Ａ，Ａ对标识进行函数变换发送给Ｂ验证</li><li>Ａ发送信息给B</li></ul><h4 id="公钥的分配">公钥的分配</h4><p><img src="http://dingdm.online/0dec14b8796f425091844c2b97ae1400.png" alt=""></p><ul><li>Ａ向管理员发送请求，申请Ｂ的公钥</li><li>管理员通过自己的加密方式将请求响应给Ａ，Ａ通过管理员加密的方式解密来获得消息</li><li>Ａ通过Ｂ的公钥和自身的标识以及随机数加密消息发送给Ｂ<br>缺点：管理员的缺陷</li></ul><h3 id="安全协议">安全协议</h3><h4 id="SSH">SSH</h4><p><strong>概念</strong><br>传统的网络服务程序，如：ftp、pop和telnet在本质上都是不安全的，因为它们在网络上用明文传送口令和数据， 别有用心的人非常容易就可以截获这些口令和数据。而且，这些服务程序的安全验证方式也是有其弱点的， 就是很容易受到“中间人”（man-in-the-middle）这种方式的攻击。所谓“中间人”的攻击方式， 就是“中间人”冒充真正的服务器接收你的传给服务器的数据，然后再冒充你把数据传给真正的服务器。 服务器和你之间的数据传送被“中间人”一转手做了手脚之后，就会出现很严重的问题。<br><strong>两种级别的安全验证</strong><br>第一种级别（基于口令的安全验证）只要你知道自己帐号和口令，就可以登录到远程主机。所有传输的数据都会被加密， 但是不能保证你正在连接的服务器就是你想连接的服务器。可能会有别的服务器在冒充真正的服务器， 也就是受到“中间人”这种方式的攻击。<br>第二种级别（基于密匙的安全验证）需要依靠密匙，也就是你必须为自己创建一对密匙，并把公用密匙放在需要访问的服务器上。 如果你要连接到SSH服务器上，客户端软件就会向服务器发出请求，请求用你的密匙进行安全验证。服务器收到请求之后， 先在你在该服务器的家目录下寻找你的公用密匙，然后把它和你发送过来的公用密匙进行比较。如果两个密匙一致， 服务器就用公用密匙加密“质询”（challenge）并把它发送给客户端软件。 客户端软件收到“质询”之后就可以用你的私人密匙解密再把它发送给服务器。</p><h4 id="SSL">SSL</h4><p>举例：<br>当顾客想从 Web 站点购买某个产品时，顾客和 Web 站点都要进行认证。顾客通常是以提供名字和密码的方式来认证他自己。 另一方面，Web 站点通过交换一块签名数据和一个有效的 X.509 证书（作为 SSL 握手的一部分）来认证它自己。 顾客的浏览器验证该证书并用所附的公用密钥验证签名数据。一旦双方都认证了，则交易就可以开始了。<br>安全套接字层（Secure Sockets Layer（SSL）） ，SSL 是一种安全协议，它为网络（例如因特网）的通信提供私密性。SSL 使应用程序在通信时不用担心被窃听和篡改。 SSL 实际上是共同工作的两个协议：“SSL 记录协议”（SSL Record Protocol）和“SSL 握手协议” （SSL Handshake Protocol）。“SSL 记录协议”是两个协议中较低级别的协议，它为较高级别的协议， 例如 SSL 握手协议对数据的变长的记录进行加密和解密。SSL 握手协议处理应用程序凭证的交换和验证。<br>名为 A 和 B 的两台对等机想安全地进行通信。在我们简单的 p2p 应用程序的环境中，对等机 A 想查询对等机 B 上的一个资源。 每个对等机都有包含其专用密钥的一个数据库（名为 keystore）和包含其公用密钥的证书。密码保护数据库的内容。 该数据库还包含一个或多个来自被信任的对等机的自签名证书。 对等机 A 发起这项事务，每台对等机相互认证，两台对等机协商采用的密码及其长度并建立一个安全通道。完成这些操作之后， 每个对等机都知道它正在跟谁交谈并且知道通道是安全的。 SSL (Secure socket Layer)安全套接层协议主要是使用公开密钥体制和X.509数字证书技术保护信息传输的机密性和完整性， 它不能保证信息的不可抵赖性，主要适用于点对点之间的信息传输，常用Web Server方式。</p><h4 id="PKI">PKI</h4><p>PKI体系结构采用证书管理公钥，通过第三方的可信机构CA， 把用户的公钥和用户的其他标识信息（如名称、e-mail、身份证号等）捆绑在一起，在Internet网上验证用户的身份， PKI体系结构把公钥密码和对称密码结合起来，在Internet网上实现密钥的自动管理，保证网上数据的机密性、完整性。</p><h4 id="SET">SET</h4><p>SET(Secure Electronic Transaction)安全电子交易协议是由美国Visa和MasterCard两大信用卡组织提出的应用于 Internet上的以信用卡为基础的电子支付系统协议。它采用公钥密码体制和X.509数字证书标准， 主要应用于B to C模式中保障支付信息的安全性。SET协议本身比较复杂，设计比较严格，安全性高， 它能保证信息传输的机密性、真实性、完整性和不可否认性。SET协议是PKI框架下的一个典型实现，同时也在不断升级和完善， 如SET 2.0将支持借记卡电子交易。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
          <category> 加密算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
            <tag> TCP </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
